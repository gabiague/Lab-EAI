var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
define("lib/types/matrix.types", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("lib/types/model.types", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Base type definition for all the models
     * @ignore
     */
    var IMlModel = /** @class */ (function () {
        function IMlModel() {
        }
        return IMlModel;
    }());
    exports.IMlModel = IMlModel;
});
define("lib/types/index", ["require", "exports", "lib/types/model.types"], function (require, exports, model_types_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IMlModel = model_types_1.IMlModel;
});
define("lib/ops/tensor_ops", ["require", "exports", "@tensorflow/tfjs", "lodash"], function (require, exports, tf, lodash_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    tf = __importStar(tf);
    /**
     * Infers shape of a tensor using TF
     *
     * @example
     * inferShape(1) // exception
     * inferShape(true) // exception
     * inferShape([1, 2]) // [2]
     * inferShape([[1, 2], [3, 4]]) // [2, 2]
     *
     * @param X
     * @ignore
     */
    function inferShape(X) {
        return tf.tensor(X).shape;
    }
    exports.inferShape = inferShape;
    /**
     * Validates the input matrix's types with the targetted types.
     * Specified target types must be one of https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof#Description
     *
     * @example
     * validateMatrixType([['z', 'z']],['string']); // no errors
     * validateMatrixType([['z', 'z']],['test']); // error: Input matrix type of ["string"] does not match with the target types ["test"]
     *
     * @param X - The input matrix
     * @param targetTypes - Target matrix types
     * @ignore
     */
    function validateMatrixType(X, targetTypes) {
        var flatX = lodash_1.flattenDeep(X);
        var xTypes = lodash_1.uniq(flatX.map(function (x) { return typeof x; }));
        var sortedXTypes = lodash_1.sortBy(xTypes, function (x) { return x; });
        var sortedTargetTypes = lodash_1.sortBy(targetTypes, function (x) { return x; });
        if (!lodash_1.isEqual(sortedXTypes, sortedTargetTypes)) {
            throw new TypeError("Input matrix type of " + JSON.stringify(sortedXTypes) + " does not match with the target types " + JSON.stringify(sortedTargetTypes));
        }
    }
    exports.validateMatrixType = validateMatrixType;
    /**
     * Validate typical X and y train data and check they are 2D and 1D shaped respectively
     *
     * @example
     * validateTrainInputs([ [1, 2], [3, 4] ], [ 1, 2 ]) // No errors
     * validateTrainInputs([ [[1, 2], [3, 3]], [[1, 2], [3, 3]] ], [ 1, 2 ]) // Error: The matrix is not 1D shaped: [ [[1, 2], [3, 3]], [[1, 2], [3, 3]] ] of [2, 2, 2]
     *
     * @param X
     * @param y
     * @ignore
     */
    function validateFitInputs(X, y) {
        if ((Array.isArray(X) && X.length === 0) ||
            (Array.isArray(y) && y.length === 0)) {
            throw new Error('Input cannot be an empty array');
        }
        // Check X is always a matrix
        var sampleShape = validateMatrix2D(X);
        // Check y is always a vector
        var targetShape = validateMatrix1D(y);
        if (sampleShape[0] !== targetShape[0]) {
            throw new TypeError("Number of labels=" + targetShape[0] + " does not math number of samples=" + sampleShape[0]);
        }
    }
    exports.validateFitInputs = validateFitInputs;
    /**
     * Validate the matrix is 1D shaped by checking the shape's length is exactly  1
     * @param X
     * @ignore
     */
    function validateMatrix1D(X) {
        var shape = inferShape(X);
        if (shape.length !== 1 || shape[0] === 0) {
            throw new TypeError("The matrix is not 1D shaped: " + JSON.stringify(X) + " of " + JSON.stringify(shape));
        }
        return shape;
    }
    exports.validateMatrix1D = validateMatrix1D;
    /**
     * Validate the matrix is 2D shaped by checking the shape's length is exactly 2
     * @param X - An input array
     * @ignore
     */
    function validateMatrix2D(X) {
        var shape = inferShape(X);
        if (shape.length !== 2) {
            throw new TypeError("The matrix is not 2D shaped: " + JSON.stringify(X) + " of " + JSON.stringify(shape));
        }
        return shape;
    }
    exports.validateMatrix2D = validateMatrix2D;
    /**
     * Reshapes any size of array into a new shape.
     *
     * The code was borrowed from math.js (https://github.com/josdejong/mathjs/blob/5750a1845442946d236822505c607a522be23474/src/utils/array.js#L258),
     * which enables us to use a specific method from Math.js instead of installing an entire library.
     *
     * TF.js has implemented an efficient way to return raw values from its Tensor implementation that always returns a 1D array,
     * which is not ideal in situations where we need a return value with correct shapes.
     *
     * Please check out https://github.com/tensorflow/tfjs/issues/939 for more information
     *
     * @example
     * reshape([1, 2, 3, 4, 5, 6], [2, 3]); // [[1, 2, 3], [4, 5, 6]]
     * reshape([1, 2, 3, 4, 5, 6], [2, 3, 1]); // [[[1], [2], [3]], [[4], [5], [6]]]
     *
     * @param array - Target array
     * @param sizes - New array shape to resize into
     * @ignore
     */
    function reshape(array, sizes) {
        // Initial validations
        if (!Array.isArray(array)) {
            throw new TypeError('The input array must be an array!');
        }
        if (!Array.isArray(sizes)) {
            throw new TypeError('The sizes must be an array!');
        }
        var deepFlatArray = lodash_1.flattenDeep(array);
        // If the reshaping is to single dimensional
        if (sizes.length === 1 && deepFlatArray.length === sizes[0]) {
            return deepFlatArray;
        }
        else if (sizes.length === 1 && deepFlatArray.length !== sizes[0]) {
            throw new TypeError("Target array shape [" + deepFlatArray.length + "] cannot be reshaped into " + sizes);
        }
        // testing if there are enough elements for the requested shape
        var tmpArray = deepFlatArray;
        var tmpArray2;
        // for each dimensions starting by the last one and ignoring the first one
        for (var sizeIndex = sizes.length - 1; sizeIndex > 0; sizeIndex--) {
            var size = sizes[sizeIndex];
            tmpArray2 = [];
            // aggregate the elements of the current tmpArray in elements of the requested size
            var length_1 = tmpArray.length / size;
            for (var i = 0; i < length_1; i++) {
                tmpArray2.push(tmpArray.slice(i * size, (i + 1) * size));
            }
            // set it as the new tmpArray for the next loop turn or for return
            tmpArray = tmpArray2;
        }
        return tmpArray;
    }
    exports.reshape = reshape;
});
define("lib/ops/index", ["require", "exports", "lib/ops/tensor_ops"], function (require, exports, tensor_ops_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.inferShape = tensor_ops_1.inferShape;
    exports.reshape = tensor_ops_1.reshape;
    exports.validateFitInputs = tensor_ops_1.validateFitInputs;
    exports.validateMatrix1D = tensor_ops_1.validateMatrix1D;
    exports.validateMatrix2D = tensor_ops_1.validateMatrix2D;
    exports.validateMatrixType = tensor_ops_1.validateMatrixType;
});
define("lib/utils/MathExtra", ["require", "exports", "lodash"], function (require, exports, _) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    _ = __importStar(_);
    /**
     * Return the number of elements along a given axis.
     * @param {any} X: Array like input data
     * @param {any} axis
     * @ignore
     */
    var size = function (X, axis) {
        if (axis === void 0) { axis = 0; }
        var rows = _.size(X);
        if (rows === 0) {
            throw new Error('Invalid input array of size 0!');
        }
        if (axis === 0) {
            return rows;
        }
        else if (axis === 1) {
            return _.flowRight(_.size, function (a) { return _.get(a, '[0]'); })(X);
        }
        throw new Error("Invalid axis value " + axis + " was given");
    };
    /**
     * Just a dumb version of subset, which is sufficient enough for now.
     * It can only handle range of rows with a single column.
     *
     * TODO: Improve.
     * @param X
     * @param rowsRange
     * @param colsRange
     * @ignore
     */
    var subset = function (X, rowsRange, colsRange, replacement) {
        if (replacement === void 0) { replacement = null; }
        // console.log('checking subset', X, rowsRange, colsRange, replacement);
        if (replacement) {
            var _X_1 = _.cloneDeep(X);
            var _loop_1 = function (i) {
                var rowIndex = rowsRange[i];
                colsRange.forEach(function (col) {
                    _X_1[rowIndex][col] = replacement[i];
                });
            };
            for (var i = 0; i < rowsRange.length; i++) {
                _loop_1(i);
            }
            return _X_1;
        }
        else {
            var result = [];
            var _loop_2 = function (i) {
                var rowIndex = rowsRange[i];
                var subSection = [];
                colsRange.forEach(function (col) {
                    subSection.push(X[rowIndex][col]);
                });
                // result.push([X[rowIndex][col]]);
                result.push(subSection);
            };
            // TODO: Replace it with a proper matrix subset method. e.g. http://mathjs.org/docs/reference/functions/subset.html
            for (var i = 0; i < rowsRange.length; i++) {
                _loop_2(i);
            }
            return result;
        }
    };
    /**
     * Get range of values
     * @param start
     * @param stop
     * @ignore
     */
    var range = function (start, stop) {
        if (!_.isNumber(start) || !_.isNumber(stop)) {
            throw new Error('start and stop arguments need to be numbers');
        }
        return _.range(start, stop);
    };
    /**
     * Checking the maxtrix is a matrix of a certain data type (e.g. number)
     * The function also performs isMatrix against the passed in dataset
     * @param matrix
     * @param {string} _type
     * @ignore
     */
    var isMatrixOf = function (matrix, _type) {
        if (_type === void 0) { _type = 'number'; }
        if (!isMatrix(matrix)) {
            throw Error("Cannot perform isMatrixOf " + _type + " unless the data is matrix");
        }
        // Checking each elements inside the matrix is not number
        // Returns an array of result per row
        var vectorChecks = matrix.map(function (arr) {
            return arr.some(function (x) {
                // Checking type of each element
                if (_type === 'number') {
                    return !_.isNumber(x);
                }
                else {
                    throw Error('Cannot check matrix of an unknown type');
                }
            });
        });
        // All should be false
        return vectorChecks.indexOf(true) === -1;
    };
    /**
     * Checking the matrix is a data of multiple rows
     * @param matrix
     * @returns {boolean}
     * @ignore
     */
    var isMatrix = function (matrix) {
        if (!Array.isArray(matrix)) {
            return false;
        }
        if (_.size(matrix) === 0) {
            return false;
        }
        var isAllArray = matrix.map(function (arr) { return _.isArray(arr); });
        return isAllArray.indexOf(false) === -1;
    };
    /**
     * Checking the array is a type of X
     * @param arr
     * @param {string} _type
     * @returns {boolean}
     * @ignore
     */
    var isArrayOf = function (arr, _type) {
        if (_type === void 0) { _type = 'number'; }
        if (_type === 'number') {
            return !arr.some(isNaN);
        }
        else if (_type === 'string') {
            return !arr.some(function (x) { return !_.isString(x); });
        }
        throw Error("Failed to check the array content of type " + _type);
    };
    /**
     *
     * @param {number[]} v1
     * @param {number[]} v2
     * @returns {number}
     * @ignore
     */
    var euclideanDistance = function (v1, v2) {
        var v1Range = _.range(0, v1.length);
        var initialTotal = 0;
        var total = _.reduce(v1Range, function (sum, i) {
            return sum + Math.pow(v2[i] - v1[i], 2);
        }, initialTotal);
        return Math.sqrt(total);
    };
    /**
     *
     * @param {number[]} v1
     * @param {number[]} v2
     * @returns {number}
     * @ignore
     */
    var manhattanDistance = function (v1, v2) {
        var v1Range = _.range(0, v1.length);
        var initialTotal = 0;
        return _.reduce(v1Range, function (total, i) {
            return total + Math.abs(v2[i] - v1[i]);
        }, initialTotal);
    };
    /**
     * Subtracts two matrices
     * @param X
     * @param y
     * @ignore
     */
    var subtract = function (X, y) {
        var _X = _.clone(X);
        for (var rowIndex = 0; rowIndex < _X.length; rowIndex++) {
            var row = X[rowIndex];
            for (var colIndex = 0; colIndex < row.length; colIndex++) {
                var column = row[colIndex];
                // Supports y.length === 1 or y.length === row.length
                if (y.length === 1) {
                    var subs = y[0];
                    _X[rowIndex][colIndex] = column - subs;
                }
                else if (y.length === row.length) {
                    var subs = y[colIndex];
                    _X[rowIndex][colIndex] = column - subs;
                }
                else {
                    throw Error("Dimension of y " + y.length + " and row " + row.length + " are not compatible");
                }
            }
        }
        return _X;
    };
    /**
     * Calculates covariance
     * @param X
     * @param xMean
     * @param y
     * @param yMean
     * @returns {number}
     * @ignore
     */
    var covariance = function (X, xMean, y, yMean) {
        if (_.size(X) !== _.size(y)) {
            throw new Error('X and y should match in size');
        }
        var covar = 0.0;
        for (var i = 0; i < _.size(X); i++) {
            covar += (X[i] - xMean) * (y[i] - yMean);
        }
        return covar;
    };
    /**
     * Calculates the variance
     * needed for linear regression
     * @param X
     * @param mean
     * @returns {number}
     * @ignore
     */
    var variance = function (X, mean) {
        if (!Array.isArray(X)) {
            throw new Error('X must be an array');
        }
        var result = 0.0;
        for (var i = 0; i < _.size(X); i++) {
            result += Math.pow(X[i] - mean, 2);
        }
        return result;
    };
    /**
     * Stack arrays in sequence horizontally (column wise).
     * This is equivalent to concatenation along the second axis, except for 1-D
     * arrays where it concatenates along the first axis. Rebuilds arrays divided by hsplit.
     *
     * @example
     * hstack([[1], [1]], [[ 0, 1, 2 ], [ 1, 0, 3 ]])
     * returns [ [ 1, 0, 1, 2 ], [ 1, 1, 0, 3 ] ]
     * @param X
     * @param y
     * @ignore
     */
    var hstack = function (X, y) {
        var stack = [];
        if (isMatrix(X) && isMatrix(y)) {
            for (var i = 0; i < X.length; i++) {
                var xEntity = X[i];
                var yEntity = y[i];
                stack.push(hstack(xEntity, yEntity));
            }
        }
        else if (Array.isArray(X) && Array.isArray(y)) {
            stack = _.concat(X, y);
            stack = _.flatten(stack);
        }
        else {
            throw Error('Input should be either matrix or Arrays');
        }
        return stack;
    };
    /**
     * Validating the left input is an array, and the right input is a pure number.
     * @param a
     * @param b
     * @ignore
     */
    var isArrayNumPair = function (a, b) { return Array.isArray(a) && _.isNumber(b); };
    /**
     * Inner product of two arrays.
     * Ordinary inner product of vectors for 1-D arrays (without complex conjugation),
     * in higher dimensions a sum product over the last axes.
     * @param a
     * @param b
     * @ignore
     */
    var inner = function (a, b) {
        /**
         * Internal methods to process the inner product
         * @param a - First vector
         * @param b - Second vector or a number
         */
        // 1. If a and b are both pure numbers
        if (_.isNumber(a) && _.isNumber(b)) {
            return a * b;
        }
        // If a is a vector and b is a pure number
        if (isArrayNumPair(a, b)) {
            return a.map(function (x) { return x * b; });
        }
        // If b is a vector and a is a pure number
        if (isArrayNumPair(b, a)) {
            return b.map(function (x) { return x * a; });
        }
        // If a and b are both vectors with an identical size
        if (Array.isArray(a) && Array.isArray(b) && a.length === b.length) {
            var result = 0;
            for (var i = 0; i < a.length; i++) {
                result += a[i] * b[i];
            }
            return result;
        }
        else if (Array.isArray(a) && Array.isArray(b) && a.length !== b.length) {
            throw new Error("Dimensions (" + a.length + ",) and (" + b.length + ",) are not aligned");
        }
        throw new Error("Cannot process with the invalid inputs " + a + " and " + b);
    };
    var math = {
        covariance: covariance,
        euclideanDistance: euclideanDistance,
        hstack: hstack,
        isArrayOf: isArrayOf,
        inner: inner,
        isMatrix: isMatrix,
        isMatrixOf: isMatrixOf,
        manhattanDistance: manhattanDistance,
        range: range,
        subset: subset,
        size: size,
        subtract: subtract,
        variance: variance
    };
    exports.default = math;
});
define("lib/cluster/k_means", ["require", "exports", "lodash", "random-js", "lib/ops/index", "lib/utils/MathExtra"], function (require, exports, _, Random, ops_1, MathExtra_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    _ = __importStar(_);
    Random = __importStar(Random);
    MathExtra_1 = __importDefault(MathExtra_1);
    /**
     * K-Means clustering
     *
     * @example
     * import { KMeans } from 'machinelearn/cluster';
     *
     * const kmean = new KMeans({ k: 2 });
     * const clusters = kmean.fit([[1, 2], [1, 4], [1, 0], [4, 2], [4, 4], [4, 0]]);
     *
     * const result = kmean.predict([[0, 0], [4, 4]]);
     * // results in: [0, 1]
     */
    var KMeans = /** @class */ (function () {
        /**
         *
         * @param distance - Choice of distance method. Defaulting to euclidean
         * @param k - Number of clusters
         * @param maxIteration - Relative tolerance with regards to inertia to declare convergence
         * @param randomState - Random state value for sorting centroids during the getInitialCentroid phase
         */
        function KMeans(_a) {
            var _b = _a === void 0 ? {
                distance: 'euclidean',
                k: 3,
                maxIteration: 300,
                randomState: 0
            } : _a, _c = _b.distance, distance = _c === void 0 ? 'euclidean' : _c, _d = _b.k, k = _d === void 0 ? 3 : _d, _e = _b.maxIteration, maxIteration = _e === void 0 ? 300 : _e, _f = _b.randomState, randomState = _f === void 0 ? 0 : _f;
            this.k = k;
            // Assigning a distance method
            var distanceType = distance;
            switch (distanceType) {
                case 'euclidean':
                    this.distance = MathExtra_1.default.euclideanDistance;
                    break;
                case 'manhattan':
                    this.distance = MathExtra_1.default.manhattanDistance;
                    break;
                default:
                    throw new Error("Unknown distance type " + distanceType);
            }
            this.randomState = randomState;
            this.maxIteration = maxIteration;
            this.centroids = [];
        }
        /**
         * Compute k-means clustering.
         * @param {any} X - array-like or sparse matrix of shape = [n_samples, n_features]
         * @returns {{centroids: number[]; clusters: number[]}}
         */
        KMeans.prototype.fit = function (X) {
            var _this = this;
            if (X === void 0) { X = null; }
            ops_1.validateMatrix2D(X);
            this.assignment = new Array(_.size(X));
            this.centroids = this.getInitialCentroids(X, this.k);
            this.clusters = new Array(this.k);
            // Flag to check the convergence
            var movement = true;
            // Looping only within the maxIteration boundary
            for (var iter = 0; iter < this.maxIteration && movement; iter++) {
                // find the distance between the point and cluster; choose the nearest centroid
                _.forEach(X, function (data, i) {
                    _this.assignment[i] = _this.getClosestCentroids(data, _this.centroids, _this.distance);
                });
                // Flag set to false; giving opportunity to stop the loop upon the covergence
                movement = false;
                // Updating the location of each centroid
                for (var j = 0; j < this.k; j++) {
                    var assigned = [];
                    for (var i = 0; i < this.assignment.length; i++) {
                        if (this.assignment[i] === j) {
                            assigned.push(X[i]);
                        }
                    }
                    if (!assigned.length) {
                        continue;
                    }
                    // Getting the original data point
                    // TODO: Fix any type
                    var centroid = this.centroids[j];
                    var newCentroid = new Array(centroid.length);
                    for (var g = 0; g < centroid.length; g++) {
                        var sum = 0;
                        for (var i = 0; i < assigned.length; i++) {
                            sum += assigned[i][g];
                        }
                        newCentroid[g] = sum / assigned.length;
                        // Does not converge yet
                        if (newCentroid[g] !== centroid[g]) {
                            movement = true;
                        }
                    }
                    this.centroids[j] = newCentroid;
                    this.clusters[j] = assigned;
                }
            }
        };
        /**
         * Predicts the cluster index with the given X
         * @param {any} X - array-like or sparse matrix of shape = [n_samples, n_features]
         * @returns {number[]}
         */
        KMeans.prototype.predict = function (X) {
            var _this = this;
            if (X === void 0) { X = null; }
            ops_1.validateMatrix2D(X);
            return _.map(X, function (data) {
                return _this.getClosestCentroids(data, _this.centroids, _this.distance);
            });
        };
        /**
         * Get the model details in JSON format
         * @returns {{k: number; clusters: number[]; centroids: number[]}}
         */
        KMeans.prototype.toJSON = function () {
            return {
                centroids: this.centroids,
                clusters: this.clusters,
                k: this.k
            };
        };
        /**
         * Restores the model from checkpoints
         * @param {number} k
         * @param {number[]} clusters
         * @param {number[]} centroids
         */
        KMeans.prototype.fromJSON = function (_a) {
            var _b = _a.k, k = _b === void 0 ? null : _b, _c = _a.clusters, clusters = _c === void 0 ? null : _c, _d = _a.centroids, centroids = _d === void 0 ? null : _d;
            if (!k || !clusters || !centroids) {
                throw new Error('You must provide all the parameters include k, clusters and centroids');
            }
            this.k = k;
            this.clusters = clusters;
            this.centroids = centroids;
        };
        /**
         * Get initial centroids from X of k
         * @param {number[]} X
         * @param {number} k
         * @returns {number[]}
         */
        KMeans.prototype.getInitialCentroids = function (X, k) {
            // Create an initial copy
            var centroids = _.clone(X);
            // Sort the centroid randomly if the randomState is greater than 0
            if (this.randomState > 0) {
                var randomEngine_1 = Random.engines.mt19937();
                randomEngine_1.seed(this.randomState);
                centroids.sort(function () {
                    var randomInt = Random.integer(0, 1)(randomEngine_1);
                    return Math.round(randomInt) - 0.5;
                });
            }
            return centroids.slice(0, k);
        };
        /**
         * Get closest centroids based on the passed in distance method
         * @param {number[]} data
         * @param {number[]} centroids
         * @param distance
         * @returns {number}
         */
        KMeans.prototype.getClosestCentroids = function (data, centroids, distance) {
            var min = Infinity;
            var index = 0;
            _.forEach(centroids, function (centroid, i) {
                var dist = distance(data, centroid);
                if (dist < min) {
                    min = dist;
                    index = i;
                }
            });
            return index;
        };
        return KMeans;
    }());
    exports.KMeans = KMeans;
});
define("lib/cluster/index", ["require", "exports", "lib/cluster/k_means"], function (require, exports, k_means_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.KMeans = k_means_1.KMeans;
});
define("lib/preprocessing/label", ["require", "exports", "lodash", "lib/ops/index"], function (require, exports, lodash_2, ops_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Encode labels with value between 0 and n_classes-1.
     *
     * @example
     * import { LabelEncoder } from 'machinelearn/preprocessing';
     *
     * const labelEncoder = new LabelEncoder();
     * const labelX = ['amsterdam', 'paris', 'tokyo'];
     * labelEncoder.fit(labelX);
     * const transformX = ['tokyo', 'tokyo', 'paris'];
     * const result = labelEncoder.transform(transformX);
     * // [ 2, 2, 1 ]
     */
    var LabelEncoder = /** @class */ (function () {
        function LabelEncoder() {
        }
        /**
         * Fit label encoder
         * @param {any[]} X - Input data in array or matrix
         */
        LabelEncoder.prototype.fit = function (X) {
            if (X === void 0) { X = null; }
            ops_2.validateMatrix1D(X);
            this.classes = lodash_2.uniq(X);
        };
        /**
         * Transform labels to normalized encoding.
         *
         * Given classes of ['amsterdam', 'paris', 'tokyo']
         *
         * It transforms ["tokyo", "tokyo", "paris"]
         *
         * Into [2, 2, 1]
         * @param X - Input data to transform according to the fitted state
         */
        LabelEncoder.prototype.transform = function (X) {
            var _this = this;
            if (X === void 0) { X = null; }
            ops_2.validateMatrix1D(X);
            return lodash_2.map(X, function (item) {
                return lodash_2.findIndex(_this.classes, function (cur) { return cur === item; });
            });
        };
        return LabelEncoder;
    }());
    exports.LabelEncoder = LabelEncoder;
});
define("lib/datasets/BaseDataset", ["require", "exports", "fs-extra", "lodash", "path", "lib/preprocessing/label", "isomorphic-fetch"], function (require, exports, fs, lodash_3, path, label_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    fs = __importStar(fs);
    path = __importStar(path);
    /**
     * @ignore
     */
    var BaseDataset = /** @class */ (function () {
        function BaseDataset() {
        }
        /**
         * fetch load from a multiple
         * @param sources - A list of URLs to fetch the data from
         * @param type - type of data; for example CSV or JSON
         * @param delimiter - specify the data delimiter, which will be used to split the row data
         * @param lastIsTarget - tell the underlying processor that the last index of the dataset is the target data
         * @param trainType - data type to enforce on the training dataset
         * @param targetType - target type to enforce on the target dataset
         * @private
         */
        BaseDataset.prototype.fetchLoad = function (sources, _a) {
            if (sources === void 0) { sources = []; }
            var _b = _a === void 0 ? {
                // Default object if nothing is provided
                type: 'csv',
                delimiter: ',',
                lastIsTarget: true,
                trainType: 'float',
                targetType: 'float'
            } : _a, 
            // Params
            _c = _b.type, 
            // Params
            type = _c === void 0 ? 'csv' : _c, _d = _b.delimiter, delimiter = _d === void 0 ? ',' : _d, _e = _b.lastIsTarget, lastIsTarget = _e === void 0 ? true : _e, _f = _b.trainType, trainType = _f === void 0 ? 'float' : _f, _g = _b.targetType, targetType = _g === void 0 ? 'float' : _g;
            return __awaiter(this, void 0, void 0, function () {
                var data, i, url, response, status_1, textData;
                return __generator(this, function (_h) {
                    switch (_h.label) {
                        case 0:
                            data = null;
                            i = 0;
                            _h.label = 1;
                        case 1:
                            if (!(i < sources.length)) return [3 /*break*/, 5];
                            url = sources[i];
                            return [4 /*yield*/, fetch(url)];
                        case 2:
                            response = _h.sent();
                            status_1 = response.ok;
                            return [4 /*yield*/, response.text()];
                        case 3:
                            textData = _h.sent();
                            if (status_1 && textData) {
                                data = textData;
                                // No need to request data anymore
                                return [3 /*break*/, 5];
                            }
                            _h.label = 4;
                        case 4:
                            i++;
                            return [3 /*break*/, 1];
                        case 5:
                            if (type === 'csv') {
                                return [2 /*return*/, this.processCSV(data, delimiter, lastIsTarget, trainType, targetType)];
                            }
                            return [2 /*return*/, {
                                    data: null,
                                    targets: null,
                                    labels: null
                                }];
                    }
                });
            });
        };
        /**
         * Load data from the local data folder
         */
        BaseDataset.prototype.fsLoad = function (type, _a) {
            var _b = _a === void 0 ? {
                // Default object if nothing is provided
                delimiter: ',',
                lastIsTarget: true,
                trainType: 'float',
                targetType: 'float'
            } : _a, _c = _b.delimiter, delimiter = _c === void 0 ? ',' : _c, _d = _b.lastIsTarget, lastIsTarget = _d === void 0 ? true : _d, _e = _b.trainType, trainType = _e === void 0 ? 'float' : _e, _f = _b.targetType, targetType = _f === void 0 ? 'float' : _f;
            return __awaiter(this, void 0, void 0, function () {
                var data;
                return __generator(this, function (_g) {
                    data = fs.readFileSync(path.join(__dirname, "data/" + type + "/train.csv"), 'utf8');
                    return [2 /*return*/, this.processCSV(data, delimiter, lastIsTarget, trainType, targetType)];
                });
            });
        };
        /**
         * Processes CSV type dataset. Returns a training and testing data pair
         * @param data - a raw string data
         * @param delimiter - delimiter to split on
         * @param lastIsTarget - flag to indicate that the last element is the target data
         * @param trainType - training data type to enforce
         * @param targetType - target data type to enforce
         */
        BaseDataset.prototype.processCSV = function (data, delimiter, lastIsTarget, trainType, targetType) {
            if (delimiter === void 0) { delimiter = ','; }
            if (lastIsTarget === void 0) { lastIsTarget = true; }
            if (trainType === void 0) { trainType = 'float'; }
            if (targetType === void 0) { targetType = 'float'; }
            // Split the rows by newlines
            var splitRows = data.split(/\r\n|\n|\r/);
            // Trim any excessive spaces
            var trimmedRows = splitRows.map(function (row) { return row.trim(); });
            // Filtering out any empty rows
            var filteredRows = trimmedRows.filter(function (row) { return row; });
            // Organise training and target data
            var result = filteredRows.map(function (row) { return row.split(delimiter); });
            if (lastIsTarget) {
                result = result.reduce(function (sum, curValue) {
                    // Building the target values array
                    sum[1].push(curValue.pop());
                    // Building the train values array
                    sum[0].push(curValue);
                    return sum;
                }, [[], []]);
            }
            // Encode the classes
            var rawTest = result[1];
            var encoder = new label_1.LabelEncoder();
            // Get the unique labels
            var labelX = lodash_3.uniqBy(rawTest, function (x) { return x; });
            encoder.fit(labelX);
            // Encode the test values
            var targets = encoder.transform(rawTest);
            // Enforcing data type
            // 1. training data
            if (trainType === 'number') {
                result[0] = result[0].map(function (row) { return row.map(lodash_3.parseInt); });
            }
            else if (trainType === 'float') {
                result[0] = result[0].map(function (row) { return row.map(parseFloat); });
            }
            // 2. target data
            if (targetType === 'number') {
                result[1] = result[1].map(lodash_3.parseInt);
            }
            else if (targetType === 'float') {
                result[1] = result[1].map(parseFloat);
            }
            return {
                data: result[0],
                targets: targets,
                labels: result[1]
            };
        };
        return BaseDataset;
    }());
    exports.BaseDataset = BaseDataset;
});
/**
 * References:
 * - https://www.kaggle.com/c/boston-housing/data
 * - https://www.cs.toronto.edu/~delve/data/boston/bostonDetail.html
 */
define("lib/datasets/Boston", ["require", "exports", "lib/datasets/BaseDataset"], function (require, exports, BaseDataset_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * This dataset contains information collected by the U.S Census Service concerning housing in the area of Boston Mass.
     * It was obtained from the StatLib archive (http://lib.stat.cmu.edu/datasets/boston),
     * and has been used extensively throughout the literature to benchmark algorithms.
     * However, these comparisons were primarily done outside of Delve and are thus somewhat suspect.
     * The dataset is small in size with only 506 cases.
     *
     * The data was originally published by Harrison, D. and Rubinfeld, D.L.
     * `Hedonic prices and the demand for clean air', J. Environ. Economics & Management, vol.5, 81-102, 1978.
     *
     * @example
     * import { Boston } from "machinelearn/datasets";
     *
     * (async function() {
     *   const bostonData = new Boston();
     *   const {
     *     data,
     *     targets,
     *     labels,
     *   } = await bostonData.load();
     * });
     *
     */
    var Boston = /** @class */ (function (_super) {
        __extends(Boston, _super);
        function Boston() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * Load the dataset
         */
        Boston.prototype.load = function () {
            return __awaiter(this, void 0, void 0, function () {
                var _a, data, targets, labels;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0: return [4 /*yield*/, this.fsLoad('boston')];
                        case 1:
                            _a = _b.sent(), data = _a.data, targets = _a.targets, labels = _a.labels;
                            // console.info('checking data', data[0]);
                            return [2 /*return*/, {
                                    data: data,
                                    targets: targets,
                                    labels: labels
                                }];
                    }
                });
            });
        };
        return Boston;
    }(BaseDataset_1.BaseDataset));
    exports.Boston = Boston;
});
define("lib/datasets/Iris", ["require", "exports", "fs", "path", "lib/datasets/BaseDataset", "isomorphic-fetch"], function (require, exports, fs, path, BaseDataset_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    fs = __importStar(fs);
    path = __importStar(path);
    /**
     * The Iris flower data set or Fisher's Iris data set is a multivariate data set introduced by the British statistician and biologist Ronald Fisher
     * in his 1936 paper The use of multiple measurements in taxonomic problems as an example of linear discriminant analysis.
     *
     * It contains 50 samples with 3 classes of 'Setosa', 'versicolor' and 'virginica'
     *
     * @example
     * import { Iris } from 'machinelearn/datasets';
     *
     * (async function() {
     *   const irisData = new Iris();
     *   const {
     *     data,         // returns the iris data (X)
     *     targets,      // list of target values (y)
     *     labels,       // list of labels
     *     targetNames,  // list of short target labels
     *     description   // dataset description
     *   } = await irisData.load(); // loads the data internally
     * })();
     *
     */
    var Iris = /** @class */ (function (_super) {
        __extends(Iris, _super);
        function Iris() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * Load datasets
         */
        Iris.prototype.load = function () {
            return __awaiter(this, void 0, void 0, function () {
                var _a, data, targets, labels, targetNames, description;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0: return [4 /*yield*/, this.fsLoad('iris')];
                        case 1:
                            _a = _b.sent(), data = _a.data, targets = _a.targets, labels = _a.labels;
                            targetNames = ['setosa', 'versicolor', 'virginica'];
                            return [4 /*yield*/, fs.readFileSync(path.join(__dirname, './data/iris/iris.names'), 'utf8')];
                        case 2:
                            description = _b.sent();
                            return [2 /*return*/, {
                                    data: data,
                                    targets: targets,
                                    labels: labels,
                                    targetNames: targetNames,
                                    description: description
                                }];
                    }
                });
            });
        };
        return Iris;
    }(BaseDataset_2.BaseDataset));
    exports.Iris = Iris;
});
define("lib/datasets/index", ["require", "exports", "lib/datasets/Boston", "lib/datasets/Iris"], function (require, exports, Boston_1, Iris_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Boston = Boston_1.Boston;
    exports.Iris = Iris_1.Iris;
});
define("lib/decomposition/pca", ["require", "exports", "@tensorflow/tfjs", "numeric", "lib/ops/index"], function (require, exports, tf, numeric, ops_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    tf = __importStar(tf);
    numeric = __importStar(numeric);
    /**
     * Principal component analysis (PCA)
     *
     * Linear dimensionality reduction using Singular Value Decomposition of
     * the data to project it to a lower dimensional space.
     *
     * - It uses the LAPACK implementation of the full SVD
     * - or randomized a randomised truncated SVD by the method of
     * Halko et al. 2009, depending on the shape
     * of the input data and the number of components to extract. (Will be implemented)
     *
     * @example
     * import { PCA } from 'machinelearn/decomposition';
     *
     * const pca = new PCA();
     * const X = [[1, 2], [3, 4], [5, 6]];
     * pca.fit(X);
     * console.log(pca.components); // result: [ [ 0.7071067811865476, 0.7071067811865474 ], [ 0.7071067811865474, -0.7071067811865476 ] ]
     * console.log(pca.explained_variance); // result: [ [ -0.3535533905932736, 0 ], [ 0, 0.5 ], [ 0.35355339059327373, 0 ] ]
     */
    var PCA = /** @class */ (function () {
        function PCA() {
        }
        /**
         * Fit the model with X.
         * At the moment it does not take n_components into consideration
         * so it will only calculate Singular value decomposition
         * @param {any} X
         */
        PCA.prototype.fit = function (X) {
            ops_3.validateMatrix2D(X);
            ops_3.validateMatrixType(X, ['number']);
            var nSamples = X.length;
            // Renaming X to A for readability
            var A = tf.tensor2d(X);
            // const transposed = tf.transpose(A, [1, 0]);
            var AT = tf.transpose(A, [1, 0]);
            var M = tf.mean(AT, 1);
            var rawC = tf.sub(A, M);
            var C = ops_3.reshape(__spread(rawC.dataSync()), rawC.shape);
            var svd = numeric.svd(C);
            this.components = svd.V;
            this.explained_variance = numeric.div(numeric.pow(svd.U), nSamples - 1);
        };
        /**
         * Predict does nothing in PCA
         * @param X - A 2D matrix
         */
        PCA.prototype.predict = function (X) {
            if (X === void 0) { X = null; }
            console.info('Predict does nothing in PCA\n', X);
            return null;
        };
        /**
         * Saves the model's states
         */
        PCA.prototype.toJSON = function () {
            return {
                components: this.components,
                explained_variance: this.explained_variance
            };
        };
        /**
         * Restores the model from given states
         * @param components - Principal axes in feature space, representing the directions of maximum variance in the data.
         * @param explained_variance - The amount of variance explained by each of the selected components.
         */
        PCA.prototype.fromJSON = function (_a) {
            var _b = _a === void 0 ? {
                components: null,
                explained_variance: null
            } : _a, _c = _b.components, components = _c === void 0 ? null : _c, _d = _b.explained_variance, explained_variance = _d === void 0 ? null : _d;
            this.components = components;
            this.explained_variance = explained_variance;
        };
        return PCA;
    }());
    exports.PCA = PCA;
});
define("lib/decomposition/index", ["require", "exports", "lib/decomposition/pca"], function (require, exports, pca_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PCA = pca_1.PCA;
});
define("lib/tree/tree", ["require", "exports", "lodash", "random-js", "lib/ops/index"], function (require, exports, lodash_4, Random, ops_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Random = __importStar(Random);
    /**
     * Question used by decision tree algorithm to determine whether to split branch or not
     * @ignore
     */
    var Question = /** @class */ (function () {
        function Question(features, column, value) {
            if (features === void 0) { features = null; }
            this.features = [];
            this.column = null;
            this.value = null;
            this.features = features;
            this.column = column;
            this.value = value;
        }
        Question.prototype.match = function (example) {
            var val = example[this.column];
            if (typeof val === 'number') {
                return val >= this.value;
            }
            else {
                return val === this.value;
            }
        };
        Question.prototype.toString = function () {
            if (!this.features) {
                throw Error('You must provide feature labels in order to render toString!');
            }
            var condition = typeof this.value === 'number' ? '>=' : '==';
            return "Is " + this.features[this.column] + " " + condition + " " + this.value;
        };
        return Question;
    }());
    exports.Question = Question;
    /**
     * According to the given targets array, count occurrences into an object.
     * @param {any[]} targets - list of class: count
     * @returns {}
     * @ignore
     */
    function classCounts(targets) {
        var result = {};
        for (var i = 0; i < targets.length; i++) {
            var target = targets[i];
            var count = result[target]; // the current
            if (typeof count === 'number' && count > 0) {
                result[target] = {
                    value: target,
                    count: count + 1
                };
            }
            else {
                result[target] = {
                    value: target,
                    count: 1
                };
            }
        }
        return result;
    }
    exports.classCounts = classCounts;
    /**
     * A leaf node that classifies data.
     * @ignore
     */
    var Leaf = /** @class */ (function () {
        function Leaf(y) {
            this.prediction = null;
            var counts = classCounts(y);
            var keys = Object.keys(counts); // Retrieving the keys for looping
            // Variable holders
            var maxCount = 0;
            var maxValue = null;
            // Finding the max count key(actual prediction value)
            for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                var count = counts[key].count;
                var value = counts[key].value;
                if (count > maxCount) {
                    maxValue = value;
                    maxCount = count;
                }
            }
            this.prediction = maxValue;
        }
        return Leaf;
    }());
    exports.Leaf = Leaf;
    /**
     * It holds a reference to the question, and to the two children nodes
     * @ignore
     */
    var DecisionNode = /** @class */ (function () {
        function DecisionNode(question, trueBranch, falseBranch) {
            this.question = null;
            this.trueBranch = null;
            this.falseBranch = null;
            this.question = question;
            this.trueBranch = trueBranch;
            this.falseBranch = falseBranch;
        }
        return DecisionNode;
    }());
    exports.DecisionNode = DecisionNode;
    /**
     * A decision tree classifier.
     *
     * @example
     * import { DecisionTreeClassifier } from 'machinelearn/tree';
     * const features = ['color', 'diameter', 'label'];
     * const decision = new DecisionTreeClassifier({ featureLabels: features });
     *
     * const X = [['Green', 3], ['Yellow', 3], ['Red', 1], ['Red', 1], ['Yellow', 3]];
     * const y = ['Apple', 'Apple', 'Grape', 'Grape', 'Lemon'];
     * decision.fit({ X, y });
     * decision.printTree(); // try it out yourself! =)
     *
     * decision.predict({ X: [['Green', 3]] }); // [ 'Apple' ]
     * decision.predict({ X }); // [ [ 'Apple' ], [ 'Apple', 'Lemon' ], [ 'Grape', 'Grape' ], [ 'Grape', 'Grape' ], [ 'Apple', 'Lemon' ] ]
     *
     * @example
     * import { DecisionTreeClassifier } from 'machinelearn/tree';
     * const decision = new DecisionTreeClassifier({ featureLabels: null });
     *
     * const X = [[0, 0], [1, 1]];
     * const Y = [0, 1];
     * decision.fit({ X, y });
     * decision2.predict({ row: [[2, 2]] }); // [ 1 ]
     */
    var DecisionTreeClassifier = /** @class */ (function () {
        /**
         *
         * @param featureLabels - Literal names for each feature to be used while printing the tree out as a string
         * @param verbose - Logs the progress of the tree construction as console.info
         * @param random_state - A seed value for the random engine
         */
        function DecisionTreeClassifier(_a) {
            var _b = _a === void 0 ? {
                featureLabels: null,
                verbose: false,
                random_state: null
            } : _a, _c = _b.featureLabels, featureLabels = _c === void 0 ? null : _c, _d = _b.verbose, verbose = _d === void 0 ? false : _d, _e = _b.random_state, random_state = _e === void 0 ? null : _e;
            this.featureLabels = null;
            this.tree = null;
            this.verbose = true;
            this.randomState = null;
            this.randomEngine = null;
            this.featureLabels = featureLabels;
            this.verbose = verbose;
            this.randomState = random_state;
            if (!Number.isInteger(random_state)) {
                this.randomEngine = Random.engines.mt19937().autoSeed();
            }
            else {
                this.randomEngine = Random.engines.mt19937().seed(random_state);
            }
        }
        /**
         * Fit date, which builds a tree
         * @param {any} X - 2D Matrix of training
         * @param {any} y - 1D Vector of target
         * @returns {Leaf | DecisionNode}
         */
        DecisionTreeClassifier.prototype.fit = function (X, y) {
            if (X === void 0) { X = null; }
            if (y === void 0) { y = null; }
            ops_4.validateFitInputs(X, y);
            this.tree = this.buildTree({ X: X, y: y });
        };
        /**
         * Predict multiple rows
         *
         * @param X - 2D Matrix of testing data
         */
        DecisionTreeClassifier.prototype.predict = function (X) {
            if (X === void 0) { X = []; }
            ops_4.validateMatrix2D(X);
            var result = [];
            for (var i = 0; i < X.length; i++) {
                var row = X[i];
                result.push(this._predict({ row: row, node: this.tree }));
            }
            return result;
        };
        /**
         * Returns the model checkpoint
         * @returns {{featureLabels: string[]; tree: any; verbose: boolean}}
         */
        DecisionTreeClassifier.prototype.toJSON = function () {
            return {
                featureLabels: this.featureLabels,
                tree: this.tree,
                verbose: this.verbose,
                random_state: this.randomState
            };
        };
        /**
         * Restores the model from a checkpoint
         * @param {string[]} featureLabels - Literal names for each feature to be used while printing the tree out as a string
         * @param {any} tree - The model's state
         * @param {boolean} verbose - Logs the progress of the tree construction as console.info
         * @param {number} random_state - A seed value for the random engine
         */
        DecisionTreeClassifier.prototype.fromJSON = function (_a) {
            var _b = _a.featureLabels, featureLabels = _b === void 0 ? null : _b, _c = _a.tree, tree = _c === void 0 ? null : _c, _d = _a.verbose, verbose = _d === void 0 ? false : _d, _e = _a.random_state, random_state = _e === void 0 ? null : _e;
            this.featureLabels = featureLabels;
            this.tree = tree;
            this.verbose = verbose;
            this.randomState = random_state;
        };
        /**
         * Recursively print the tree into console
         * @param {string} spacing - Spacing used when printing the tree into the terminal
         */
        DecisionTreeClassifier.prototype.printTree = function (spacing) {
            if (spacing === void 0) { spacing = ''; }
            if (!this.tree) {
                throw new Error('You cannot print an empty tree');
            }
            this._printTree({ node: this.tree, spacing: spacing });
        };
        /**
         * Partition X and y into true and false branches
         * @param X
         * @param y
         * @param {Question} question
         * @returns {{trueX: Array<any>; trueY: Array<any>; falseX: Array<any>; falseY: Array<any>}}
         */
        DecisionTreeClassifier.prototype.partition = function (X, y, question) {
            var trueX = [];
            var trueY = [];
            var falseX = [];
            var falseY = [];
            for (var i = 0; i < X.length; i++) {
                var row = X[i];
                if (question.match(row)) {
                    trueX.push(X[i]);
                    trueY.push(y[i]);
                }
                else {
                    falseX.push(X[i]);
                    falseY.push(y[i]);
                }
            }
            return { trueX: trueX, trueY: trueY, falseX: falseX, falseY: falseY };
        };
        /**
         * Calculate the gini impurity of rows
         * Checkout: https://en.wikipedia.org/wiki/Decision_tree_learning#Gini_impurity
         * @param targets
         * @returns {number}
         */
        DecisionTreeClassifier.prototype.gini = function (targets) {
            var counts = classCounts(targets);
            var impurity = 1;
            var keys = Object.keys(counts);
            for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                var count = counts[key].count;
                if (count === null || count === undefined) {
                    throw Error('Invalid class count detected!');
                }
                var probOfClass = count / targets.length;
                impurity -= Math.pow(probOfClass, 2);
            }
            return impurity;
        };
        /**
         * Information Gain.
         *
         * The uncertainty of the starting node, minus the weighted impurity of
         * two child nodes.
         * @param left
         * @param right
         * @param uncertainty
         * @returns {number}
         */
        DecisionTreeClassifier.prototype.infoGain = function (left, right, uncertainty) {
            var p = left.length / (left.length + right.length);
            return uncertainty - p * this.gini(left) - (1 - p) * this.gini(right);
        };
        /**
         * Find the best split for the current X and y.
         * @param X
         * @param y
         * @returns {{bestGain: number; bestQuestion: any}}
         */
        DecisionTreeClassifier.prototype.findBestSplit = function (X, y) {
            var uncertainty = this.gini(y);
            var nFeatures = X[0].length;
            var bestGain = 0;
            var bestQuestion = null;
            var featureIndex = [];
            if (Number.isInteger(this.randomState)) {
                // method 1: Randomly selecting features
                while (featureIndex.length <= nFeatures) {
                    var index = Random.integer(0, nFeatures)(this.randomEngine);
                    featureIndex.push(index);
                }
            }
            else {
                featureIndex = lodash_4.range(0, X[0].length);
            }
            var _loop_3 = function (i) {
                var col = featureIndex[i];
                var uniqFeatureValues = lodash_4.uniqBy(lodash_4.map(X, function (row) { return row[col]; }), function (x) { return x; });
                for (var j = 0; j < uniqFeatureValues.length; j++) {
                    var feature = uniqFeatureValues[j];
                    // featureLabels is for the model interoperability
                    var question = new Question(this_1.featureLabels, col, feature);
                    // Try splitting the dataset
                    var _a = this_1.partition(X, y, question), trueY = _a.trueY, falseY = _a.falseY;
                    // Skip this dataset if it does not divide
                    if (trueY.length === 0 || falseY.length === 0) {
                        continue;
                    }
                    // Calculate information gained from this split
                    var gain = this_1.infoGain(trueY, falseY, uncertainty);
                    if (this_1.verbose) {
                        console.info("fn: " + col + " fval: " + feature + " gini: " + gain);
                    }
                    if (gain >= bestGain) {
                        bestGain = gain;
                        bestQuestion = question;
                    }
                }
            };
            var this_1 = this;
            for (var i = 0; i < featureIndex.length; i++) {
                _loop_3(i);
            }
            return { bestGain: bestGain, bestQuestion: bestQuestion };
        };
        /**
         * Interactively build tree until it reaches the terminal nodes
         * @param {any} X
         * @param {any} y
         * @returns {any}
         */
        DecisionTreeClassifier.prototype.buildTree = function (_a) {
            var X = _a.X, y = _a.y;
            var _b = this.findBestSplit(X, y), bestGain = _b.bestGain, bestQuestion = _b.bestQuestion;
            if (bestGain === 0) {
                return new Leaf(y);
            }
            // Partition the current passed in X ,y
            var _c = this.partition(X, y, bestQuestion), trueX = _c.trueX, trueY = _c.trueY, falseX = _c.falseX, falseY = _c.falseY;
            // Recursively build the true branch
            var trueBranch = this.buildTree({ X: trueX, y: trueY });
            // Recursively build the false branch
            var falseBranch = this.buildTree({ X: falseX, y: falseY });
            return new DecisionNode(bestQuestion, trueBranch, falseBranch);
        };
        /**
         * Internal predict method separated out for recursion purpose
         * @param {any} row
         * @param {any} node
         * @returns {any}
         * @private
         */
        DecisionTreeClassifier.prototype._predict = function (_a) {
            var row = _a.row, node = _a.node;
            if (node instanceof Leaf) {
                // Just return the highest voted
                return node.prediction;
            }
            if (node.question.match(row)) {
                return this._predict({ row: row, node: node.trueBranch });
            }
            else {
                return this._predict({ row: row, node: node.falseBranch });
            }
        };
        /**
         * Private method for printing tree; required for recursion
         * @param {any} node
         * @param {any} spacing
         */
        DecisionTreeClassifier.prototype._printTree = function (_a) {
            var node = _a.node, _b = _a.spacing, spacing = _b === void 0 ? '' : _b;
            if (node instanceof Leaf) {
                console.info(spacing + '' + node.prediction);
                return;
            }
            // Print the question of the node
            console.info(spacing + node.question.toString());
            // Call this function recursively for true branch
            console.info(spacing, '--> True');
            this._printTree({ node: node.trueBranch, spacing: spacing + ' ' });
            // Call this function recursively for false branch
            console.info(spacing, '--> False');
            this._printTree({ node: node.falseBranch, spacing: spacing + ' ' });
        };
        return DecisionTreeClassifier;
    }());
    exports.DecisionTreeClassifier = DecisionTreeClassifier;
});
define("lib/tree/index", ["require", "exports", "lib/tree/tree"], function (require, exports, tree_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DecisionTreeClassifier = tree_1.DecisionTreeClassifier;
});
define("lib/ensemble/forest", ["require", "exports", "lodash", "lib/ops/index", "lib/tree/index"], function (require, exports, lodash_5, ops_5, tree_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Base RandomForest implementation used by both classifier and regressor
     * @ignore
     */
    var BaseRandomForest = /** @class */ (function () {
        /**
         *
         * @param {number} nEstimator - Number of trees.
         * @param random_state - Random seed value for DecisionTrees
         */
        function BaseRandomForest(_a) {
            var _b = _a === void 0 ? {
                // Default value on empty constructor
                nEstimator: 10,
                random_state: null
            } : _a, 
            // Each object param default value
            _c = _b.nEstimator, 
            // Each object param default value
            nEstimator = _c === void 0 ? 10 : _c, _d = _b.random_state, random_state = _d === void 0 ? null : _d;
            this.trees = [];
            this.randomState = null;
            this.nEstimator = nEstimator;
            this.randomState = random_state;
        }
        /**
         * Build a forest of trees from the training set (X, y).
         * @param {Array} X - array-like or sparse matrix of shape = [n_samples, n_features]
         * @param {Array} y - array-like, shape = [n_samples] or [n_samples, n_outputs]
         * @returns void
         */
        BaseRandomForest.prototype.fit = function (X, y) {
            var _this = this;
            if (X === void 0) { X = null; }
            if (y === void 0) { y = null; }
            ops_5.validateFitInputs(X, y);
            this.trees = lodash_5.reduce(lodash_5.range(0, this.nEstimator), function (sum) {
                var tree = new tree_2.DecisionTreeClassifier({
                    featureLabels: null,
                    random_state: _this.randomState
                });
                tree.fit(X, y);
                return lodash_5.concat(sum, [tree]);
            }, []);
        };
        /**
         * Returning the current model's checkpoint
         * @returns {{trees: any[]}}
         */
        BaseRandomForest.prototype.toJSON = function () {
            return {
                trees: this.trees
            };
        };
        /**
         * Restore the model from a checkpoint
         * @param {any[]} trees - Decision trees
         */
        BaseRandomForest.prototype.fromJSON = function (_a) {
            var _b = _a.trees, trees = _b === void 0 ? null : _b;
            if (!trees) {
                throw new Error('You must provide both tree to restore the model');
            }
            this.trees = trees;
        };
        /**
         * Internal predict function used by either RandomForestClassifier or Regressor
         * @param X
         * @private
         */
        BaseRandomForest.prototype.predict = function (X) {
            if (X === void 0) { X = null; }
            ops_5.validateMatrix2D(X);
            return lodash_5.map(this.trees, function (tree) {
                // TODO: Check if it's a matrix or an array
                return tree.predict(X);
            });
        };
        return BaseRandomForest;
    }());
    exports.BaseRandomForest = BaseRandomForest;
    /**
     * Random forest classifier creates a set of decision trees from randomly selected subset of training set.
     * It then aggregates the votes from different decision trees to decide the final class of the test object.
     *
     * @example
     * import { RandomForestClassifier } from 'machinelearn/ensemble';
     *
     * const X = [[0, 0], [1, 1], [2, 1], [1, 5], [3, 2]];
     * const y = [0, 1, 2, 3, 7];
     *
     * const randomForest = new RandomForestClassifier();
     * randomForest.fit(X, y);
     *
     * // Results in a value such as [ '0', '2' ].
     * // Predictions will change as we have not set a seed value.
     */
    var RandomForestClassifier = /** @class */ (function (_super) {
        __extends(RandomForestClassifier, _super);
        function RandomForestClassifier() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * Predict class for X.
         *
         * The predicted class of an input sample is a vote by the trees in the forest, weighted by their probability estimates.
         * That is, the predicted class is the one with highest mean probability estimate across the trees.
         * @param {Array} X - array-like or sparse matrix of shape = [n_samples]
         * @returns {string[]}
         */
        RandomForestClassifier.prototype.predict = function (X) {
            if (X === void 0) { X = null; }
            var predictions = _super.prototype.predict.call(this, X);
            return this.votePredictions(predictions);
        };
        /**
         * @hidden
         * Bagging prediction helper method
         * According to the predictions returns by the trees, it will select the
         * class with the maximum number (votes)
         * @param {Array<any>} predictions - List of initial predictions that may look like [ [1, 2], [1, 1] ... ]
         * @returns {string[]}
         */
        RandomForestClassifier.prototype.votePredictions = function (predictions) {
            var counts = lodash_5.countBy(predictions, function (x) { return x; });
            var countsArray = lodash_5.reduce(lodash_5.keys(counts), function (sum, k) {
                var returning = {};
                returning[k] = counts[k];
                return lodash_5.concat(sum, returning);
            }, []);
            var max = lodash_5.maxBy(countsArray, function (x) { return lodash_5.head(lodash_5.values(x)); });
            var key = lodash_5.head(lodash_5.keys(max));
            // Find the actual class values from the predictions
            return lodash_5.find(predictions, function (pred) {
                return lodash_5.isEqual(pred.join(','), key);
            });
        };
        return RandomForestClassifier;
    }(BaseRandomForest));
    exports.RandomForestClassifier = RandomForestClassifier;
});
define("lib/ensemble/index", ["require", "exports", "lib/ensemble/forest"], function (require, exports, forest_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RandomForestClassifier = forest_1.RandomForestClassifier;
});
define("lib/utils/nlp", ["require", "exports", "lodash"], function (require, exports, lodash_6) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * @ignore
     */
    var WordTokenizer = /** @class */ (function () {
        function WordTokenizer() {
        }
        /**
         * Tokenize a given text
         * e.g.
         * given: "deep-learning ian good fellow learning jason shin shin"
         * returns: [ 'deep', 'learning', 'ian', 'good', 'fellow', 'learning', 'jason', 'shin', 'shin' ]
         * @param text
         * @returns {string[]}
         */
        WordTokenizer.prototype.tokenize = function (text) {
            if (!lodash_6.isString(text)) {
                throw new Error('Cannot process a non string value');
            }
            var regex = /[^A-Za-z--0-9_]+/g;
            return text.split(regex);
        };
        return WordTokenizer;
    }());
    exports.WordTokenizer = WordTokenizer;
});
define("lib/feature_extraction/stop_words", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * @ignore
     * @type {Array<string>}
     */
    exports.ENGLISH_STOP_WORDS = [
        'a',
        'about',
        'above',
        'across',
        'after',
        'afterwards',
        'again',
        'against',
        'all',
        'almost',
        'alone',
        'along',
        'already',
        'also',
        'although',
        'always',
        'am',
        'among',
        'amongst',
        'amoungst',
        'amount',
        'an',
        'and',
        'another',
        'any',
        'anyhow',
        'anyone',
        'anything',
        'anyway',
        'anywhere',
        'are',
        'around',
        'as',
        'at',
        'back',
        'be',
        'became',
        'because',
        'become',
        'becomes',
        'becoming',
        'been',
        'before',
        'beforehand',
        'behind',
        'being',
        'below',
        'beside',
        'besides',
        'between',
        'beyond',
        'bill',
        'both',
        'bottom',
        'but',
        'by',
        'call',
        'can',
        'cannot',
        'cant',
        'co',
        'con',
        'could',
        'couldnt',
        'cry',
        'de',
        'describe',
        'detail',
        'do',
        'done',
        'down',
        'due',
        'during',
        'each',
        'eg',
        'eight',
        'either',
        'eleven',
        'else',
        'elsewhere',
        'empty',
        'enough',
        'etc',
        'even',
        'ever',
        'every',
        'everyone',
        'everything',
        'everywhere',
        'except',
        'few',
        'fifteen',
        'fifty',
        'fill',
        'find',
        'fire',
        'first',
        'five',
        'for',
        'former',
        'formerly',
        'forty',
        'found',
        'four',
        'from',
        'front',
        'full',
        'further',
        'get',
        'give',
        'go',
        'had',
        'has',
        'hasnt',
        'have',
        'he',
        'hence',
        'her',
        'here',
        'hereafter',
        'hereby',
        'herein',
        'hereupon',
        'hers',
        'herself',
        'him',
        'himself',
        'his',
        'how',
        'however',
        'hundred',
        'i',
        'ie',
        'if',
        'in',
        'inc',
        'indeed',
        'interest',
        'into',
        'is',
        'it',
        'its',
        'itself',
        'keep',
        'last',
        'latter',
        'latterly',
        'least',
        'less',
        'ltd',
        'made',
        'many',
        'may',
        'me',
        'meanwhile',
        'might',
        'mill',
        'mine',
        'more',
        'moreover',
        'most',
        'mostly',
        'move',
        'much',
        'must',
        'my',
        'myself',
        'name',
        'namely',
        'neither',
        'never',
        'nevertheless',
        'next',
        'nine',
        'no',
        'nobody',
        'none',
        'noone',
        'nor',
        'not',
        'nothing',
        'now',
        'nowhere',
        'of',
        'off',
        'often',
        'on',
        'once',
        'one',
        'only',
        'onto',
        'or',
        'other',
        'others',
        'otherwise',
        'our',
        'ours',
        'ourselves',
        'out',
        'over',
        'own',
        'part',
        'per',
        'perhaps',
        'please',
        'put',
        'rather',
        're',
        'same',
        'see',
        'seem',
        'seemed',
        'seeming',
        'seems',
        'serious',
        'several',
        'she',
        'should',
        'show',
        'side',
        'since',
        'sincere',
        'six',
        'sixty',
        'so',
        'some',
        'somehow',
        'someone',
        'something',
        'sometime',
        'sometimes',
        'somewhere',
        'still',
        'such',
        'system',
        'take',
        'ten',
        'than',
        'that',
        'the',
        'their',
        'them',
        'themselves',
        'then',
        'thence',
        'there',
        'thereafter',
        'thereby',
        'therefore',
        'therein',
        'thereupon',
        'these',
        'they',
        'thick',
        'thin',
        'third',
        'this',
        'those',
        'though',
        'three',
        'through',
        'throughout',
        'thru',
        'thus',
        'to',
        'together',
        'too',
        'top',
        'toward',
        'towards',
        'twelve',
        'twenty',
        'two',
        'un',
        'under',
        'until',
        'up',
        'upon',
        'us',
        'very',
        'via',
        'was',
        'we',
        'well',
        'were',
        'what',
        'whatever',
        'when',
        'whence',
        'whenever',
        'where',
        'whereafter',
        'whereas',
        'whereby',
        'wherein',
        'whereupon',
        'wherever',
        'whether',
        'which',
        'while',
        'whither',
        'who',
        'whoever',
        'whole',
        'whom',
        'whose',
        'why',
        'will',
        'with',
        'within',
        'without',
        'would',
        'yet',
        'you',
        'your',
        'yours',
        'yourself',
        'yourselves'
    ];
});
define("lib/feature_extraction/text", ["require", "exports", "lodash", "stopword", "lib/ops/index", "lib/utils/nlp", "lib/feature_extraction/stop_words"], function (require, exports, _, sw, ops_6, nlp_1, stop_words_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    _ = __importStar(_);
    sw = __importStar(sw);
    /**
     * The CountVectorizer provides a simple way to both tokenize a collection
     * of text documents and build a vocabulary of known words, but also
     * to encode new documents using that vocabulary.
     *
     * @example
     * import { CountVectorizer } from 'machinelearn/feature_extraction';
     *
     * const corpus = ['deep learning ian good fellow learning jason shin shin', 'yoshua bengio'];
     * const vocabCounts = cv.fit_transform(corpus);
     * console.log(vocabCounts); // [ [ 0, 1, 1, 1, 1, 1, 2, 2, 0 ], [ 1, 0, 0, 0, 0, 0, 0, 0, 1 ] ]
     * console.log(cv.vocabulary); // { bengio: 0, deep: 1, fellow: 2, good: 3, ian: 4, jason: 5, learning: 6, shin: 7, yoshua: 8 }
     * console.log(cv.getFeatureNames()); // [ 'bengio', 'deep', 'fellow', 'good', 'ian', 'jason', 'learning', 'shin', 'yoshua' ]
     *
     * const newVocabCounts = cv.transform(['ian good fellow jason duuog']);
     * console.log(newVocabCounts); // [ [ 0, 0, 1, 1, 1, 1, 0, 0, 0 ] ]
     */
    var CountVectorizer = /** @class */ (function () {
        function CountVectorizer() {
            this.vocabulary = {};
        }
        /**
         * Learn a vocabulary dictionary of all tokens in the raw documents.
         * @param {string[]} doc - An array of strings
         * @returns {CountVectorizer}
         */
        CountVectorizer.prototype.fit = function (doc) {
            if (doc === void 0) { doc = null; }
            ops_6.validateMatrix1D(doc);
            this.fit_transform(doc);
            return this;
        };
        /**
         * fit transform applies
         * @param {string[]} doc - An array of strings
         * @returns {number[][]}
         */
        CountVectorizer.prototype.fit_transform = function (doc) {
            if (doc === void 0) { doc = null; }
            ops_6.validateMatrix1D(doc);
            var _a = this.buildVocabulary(doc), internalVocabulary = _a.internalVocabulary, pubVocabulary = _a.pubVocabulary;
            this.vocabulary = pubVocabulary;
            this.internalVocabulary = internalVocabulary;
            return this.countVocab(doc);
        };
        /**
         * Transform documents to document-term matrix.
         * Extract token counts out of raw text documents using the vocabulary
         * fitted with fit or the one provided to the constructor.
         * @param {string[]} doc - An array of strings
         * @returns {number[][]}
         */
        CountVectorizer.prototype.transform = function (doc) {
            if (doc === void 0) { doc = null; }
            ops_6.validateMatrix1D(doc);
            return this.countVocab(doc);
        };
        /**
         * Array mapping from feature integer indices to feature name
         * @returns {Object}
         */
        CountVectorizer.prototype.getFeatureNames = function () {
            if (!this.internalVocabulary) {
                throw new Error('You must fit a document first before you can retrieve the feature names!');
            }
            return this.internalVocabulary;
        };
        /**
         * Build a tokenizer/vectorizer
         * @returns {(x: string) => string[]}
         */
        CountVectorizer.prototype.buildAnalyzer = function () {
            var _this = this;
            return function (x) { return _this.preprocess(x, { removeSW: true }); };
        };
        /**
         * Calculates list of vocabularies in the entire document and come up with
         * vocab: index pairs
         * @param doc
         */
        CountVectorizer.prototype.buildVocabulary = function (doc) {
            var analyze = this.buildAnalyzer();
            var processedDoc = _.flowRight(function (d) { return _.uniq(d); }, function (d) { return _.sortBy(d, function (z) { return z; }); }, function (d) { return _.flatten(d); }, function (d) { return _.map(d, function (text) { return analyze(text); }); })(doc);
            var pubVocabulary = _.reduce(processedDoc, function (sum, val, index) {
                return _.set(sum, val, index);
            }, {});
            return {
                internalVocabulary: processedDoc,
                pubVocabulary: pubVocabulary
            };
        };
        /**
         * @ignore
         * Counting number of vocab occurences in the current token of a sentence
         * ['yoshua', 'bengio', 'deep', 'learning'] = vocabulary
         * ['yohua', 'bengio'] => tokens
         * results in
         * [1, 1, 0, 0]
         * @param doc
         */
        CountVectorizer.prototype.countVocab = function (doc) {
            var _this = this;
            var analyze = this.buildAnalyzer();
            // 1. Reducing the doc
            return _.reduce(doc, function (sum, text) {
                var tokens = analyze(text);
                // 2. Looping each vocab for counting
                var sentenceCounted = _.reduce(_this.internalVocabulary, function (sentenceCounts, vocab) {
                    // 3. Getting number of occurences of vocab in each tokens (tokens of a sentence)
                    var vocabCount = _.reduce(tokens, function (tokenCounts, t) {
                        if (_.isEqual(t, vocab)) {
                            return tokenCounts + 1;
                        }
                        else {
                            return tokenCounts;
                        }
                    }, 0);
                    return _.concat(sentenceCounts, [vocabCount]);
                }, []);
                return _.concat(sum, [sentenceCounted]);
            }, []);
        };
        /**
         * @ignore
         * preprocess a line of text by applying
         * 1) tokenization
         * 2) removing stopwords
         * @param text
         * @param {any} removeSW
         * @returns {any}
         */
        CountVectorizer.prototype.preprocess = function (text, _a) {
            var _b = _a.removeSW, removeSW = _b === void 0 ? false : _b;
            var tokenizer = new nlp_1.WordTokenizer();
            return _.flowRight(function (x) { return tokenizer.tokenize(x); }, function (x) { return x.join(' '); }, 
            // TODO: Somehow it's removing too many words??!!
            function (x) {
                return removeSW ? sw.removeStopwords(x, stop_words_1.ENGLISH_STOP_WORDS) : x;
            }, function (x) { return x.split(' '); })(text);
        };
        return CountVectorizer;
    }());
    exports.CountVectorizer = CountVectorizer;
});
define("lib/feature_extraction/index", ["require", "exports", "lib/feature_extraction/text"], function (require, exports, text_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CountVectorizer = text_1.CountVectorizer;
});
define("lib/utils/permutations", ["require", "exports", "lodash"], function (require, exports, _) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    _ = __importStar(_);
    /**
     * Generate all combination of arguments from objects
     * @param optObj - An object or arrays with keys describing options  {firstName:['Ben','Jade','Darren'],lastName:['Smith','Miller']}
     * @private
     * @return - An array of objects e.g. [{firstName:'Ben',LastName:'Smith'},{..]
     * @ignore
     */
    function _cartesianProductObj(optObj) {
        var keys = _.keys(optObj);
        var opts = _.values(optObj);
        var combs = _cartesianProductOf(opts);
        return _.map(combs, function (comb) {
            return _.zipObject(keys, comb);
        });
    }
    /**
     * Generate all combination of arguments when given arrays or strings
     * e.g. [['Ben','Jade','Darren'],['Smith','Miller']] to [['Ben','Smith'],[..]]
     * e.g. 'the','cat' to [['t', 'c'],['t', 'a'], ...]
     * @param args
     * @private
     * @ignore
     */
    function _cartesianProductOf(args) {
        var _args = args;
        if (arguments.length > 1) {
            _args = _.toArray(arguments);
        }
        // strings to arrays of letters
        _args = _.map(_args, function (opt) { return (typeof opt === 'string' ? _.toArray(opt) : opt); });
        return _.reduce(_args, function (a, b) {
            return _.flatten(_.map(a, function (x) {
                return _.map(b, function (y) {
                    return _.concat(x, [y]);
                });
            }));
        }, [[]]);
    }
    /**
     * Generate the cartesian product of input objects, arrays, or strings
     *
     *
     * product('me','hi')
     * // => [["m","h"],["m","i"],["e","h"],["e","i"]]
     *
     * product([1,2,3],['a','b','c']
     * // => [[1,"a"],[1,"b"],[1,"c"],[2,"a"],[2,"b"],[2,"c"],[3,"a"],[3,"b"],[3,"c"]]
     *
     * product({who:['me','you'],say:['hi','by']})
     * // => [{"who":"me","say":"hi"},{"who":"me","say":"by"},{"who":"you","say":"hi"},{"who":"you","say":"by"}]
     *
     * // It also takes in a single array of args
     * product(['me','hi'])
     * // => [["m","h"],["m","i"],["e","h"],["e","i"]]
     * @ignore
     */
    function product(opts) {
        if (arguments.length === 1 && !_.isArray(opts)) {
            return _cartesianProductObj(opts);
        }
        else if (arguments.length === 1) {
            return _cartesianProductOf(opts);
        }
        else {
            return _cartesianProductOf(arguments);
        }
    }
    /**
     * Generate n combinations with repeat values.
     * @param X - Matrix input
     * @param n - number of repeats
     * @ignore
     */
    function combinationsWithReplacement(X, n) {
        var _n = n;
        var _X = X;
        if (typeof _X === 'string') {
            _X = _.toArray(_X);
        }
        // If repeat is 1, simply return the original value
        if (_n === 0) {
            return null;
        }
        if (_n === 1) {
            return X;
        }
        // Falls back to X.length as default value is _n is undefined
        _n = _n ? _n : X.length;
        // make n copies of keys/indices
        var nInds = [];
        for (var j = 0; j < _n; j++) {
            nInds.push(_.keys(_X));
        }
        // get product of the indices, then filter to keep elements in order
        var arrangements = product(nInds).filter(function (pair) { return pair[0] <= pair[1]; });
        return _.map(arrangements, function (indices) { return _.map(indices, function (i) { return _X[i]; }); });
    }
    exports.combinationsWithReplacement = combinationsWithReplacement;
});
define("lib/preprocessing/data", ["require", "exports", "@tensorflow/tfjs", "lodash", "lib/ops/index", "lib/utils/MathExtra", "lib/utils/permutations"], function (require, exports, tf, _, ops_7, MathExtra_2, permutations_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    tf = __importStar(tf);
    _ = __importStar(_);
    MathExtra_2 = __importDefault(MathExtra_2);
    /**
     * Augment dataset with an additional dummy feature.
     * This is useful for fitting an intercept term with implementations which cannot otherwise fit it directly.
     *
     * @example
     * import { add_dummy_feature } from 'machinelearn/preprocessing';
     * const dummy = add_dummy_feature([[0, 1, 2], [1, 0, 3]]);
     * console.log(dummy); // returns: [ [ 1, 0, 1, 2 ], [ 1, 1, 0, 3 ] ]
     *
     * @param X - A matrix of data
     * @param value - Value to use for the dummy feature.
     */
    function add_dummy_feature(X, value) {
        if (X === void 0) { X = null; }
        if (value === void 0) { value = 1.0; }
        if (Array.isArray(X) && X.length === 0) {
            throw new TypeError('X cannot be empty');
        }
        ops_7.validateMatrix2D(X);
        var tensorX = tf.tensor2d(X);
        var _a = __read(tensorX.shape, 1), nSamples = _a[0];
        var ones = tf.ones([nSamples, 1]);
        var sValue = tf.scalar(value);
        var multipledOnes = tf.mul(ones, sValue);
        var hStacked = tf.concat([multipledOnes, tensorX], 1);
        return ops_7.reshape(Array.from(hStacked.dataSync()), hStacked.shape);
    }
    exports.add_dummy_feature = add_dummy_feature;
    /**
     * Encode categorical integer features using a one-hot aka one-of-K scheme.
     *
     * The input to this transformer should be a matrix of integers, denoting the
     * values taken on by categorical (discrete) features. The output will be a sparse
     * matrix where each column corresponds to one possible value of one feature.
     * It is assumed that input features take on values in the range [0, n_values).
     *
     * This encoding is needed for feeding categorical data to many
     * scikit-learn estimators, notably linear models and SVMs with the standard kernels.
     *
     * Note: a one-hot encoding of y labels should use a LabelBinarizer instead.
     *
     * @example
     * const enc = new OneHotEncoder();
     * const planetList = [
     *  { planet: 'mars', isGasGiant: false, value: 10 },
     *  { planet: 'saturn', isGasGiant: true, value: 20 },
     *  { planet: 'jupiter', isGasGiant: true, value: 30 }
     * ];
     * const encodeInfo = enc.encode(planetList, {
     *  dataKeys: ['value', 'isGasGiant'],
     *  labelKeys: ['planet']
     * });
     * // encodeInfo.data -> [ [ -1, 0, 1, 0, 0 ], [ 0, 1, 0, 1, 0 ], [ 1, 1, 0, 0, 1 ] ]
     * const decodedInfo = enc.decode(encodeInfo.data, encodeInfo.decoders);
     * // gives you back the original value, which is `planetList`
     */
    var OneHotEncoder = /** @class */ (function () {
        function OneHotEncoder() {
            /**
             * Calculating the sample standard deviation (vs population stddev).
             * @param lst
             * @param {number} mean
             * @returns {number}
             */
            this.calculateStd = function (lst, mean) {
                var deviations = _.map(lst, function (n) { return Math.pow(n - mean, 2); });
                return Math.pow(_.sum(deviations) / (lst.length - 1), 0.5);
            };
        }
        /**
         * encode data according to dataKeys and labelKeys
         *
         * @param data - list of records to encode
         * @param options
         */
        OneHotEncoder.prototype.encode = function (data, _a) {
            var _this = this;
            if (data === void 0) { data = null; }
            var _b = _a === void 0 ? {
                dataKeys: null,
                labelKeys: null
            } : _a, 
            /**
             * Independent variables
             */
            _c = _b.dataKeys, 
            /**
             * Independent variables
             */
            dataKeys = _c === void 0 ? null : _c, 
            /**
             * Depdenent variables
             */
            _d = _b.labelKeys, 
            /**
             * Depdenent variables
             */
            labelKeys = _d === void 0 ? null : _d;
            var decoders = [];
            // shortcut to allow caller to default to "all non-label keys are data keys"
            var _dataKeys = dataKeys ? dataKeys : _.keys(data[0]);
            // validations
            if (_.size(data) < 1) {
                throw Error('data cannot be empty!');
            }
            // data keys
            _.forEach(_dataKeys, function (dataKey) {
                // TODO: it's only checking data[0] -> It should also check all the others
                if (!_.has(data[0], dataKey)) {
                    // TODO: Find the correct error to throw
                    throw Error("Cannot find " + dataKey + " from data");
                }
            });
            // label keys
            _.forEach(labelKeys, function (labelKey) {
                // TODO: it's only checking data[0] -> It should also check all the others
                if (!_.has(data[0], labelKey)) {
                    // TODO Find the correct error to throw
                    throw Error("Cannot find " + labelKey + " from labels");
                }
            });
            // maybe a little too clever but also the simplest;
            // serialize every value for a given data key, then zip the results back up into a (possibly nested) array
            var transform = function (keys) {
                return _.zip.apply(_, __spread(_.map(keys, function (key) {
                    var standardized = _this.standardizeField(key, data);
                    var encoded = _.get(standardized, 'encoded');
                    var decode = _.get(standardized, 'decode');
                    if (encoded && decode) {
                        // TODO: We need to prefer immutable datastructure
                        decoders.push(decode);
                        return encoded;
                    }
                    // Otherwise just return values itself
                    return standardized;
                })));
            };
            var features = transform(_dataKeys);
            var labels = transform(labelKeys);
            return {
                // zip the label data back into the feature data (to ensure label data is at the end)
                data: _.map(_.zip(features, labels), _.flattenDeep),
                decoders: decoders
            };
        };
        /**
         * Decode the encoded data back into its original format
         */
        OneHotEncoder.prototype.decode = function (encoded, decoders) {
            var _this = this;
            return _.map(encoded, function (row) { return _this.decodeRow(row, decoders); });
        };
        /**
         * Decode an encoded row back into its original format
         * @param row
         * @param decoders
         * @returns {Object}
         */
        OneHotEncoder.prototype.decodeRow = function (row, decoders) {
            var i = 0;
            var numFieldsDecoded = 0;
            var record = {};
            var getStrVal = function (X, ix, decoder) {
                var data = X.slice(ix, ix + decoder.offset);
                return decoder.lookupTable[_.indexOf(data, 1)];
            };
            var getBoolVal = function (X, ix) { return !!X[ix]; };
            var getNumbVal = function (X, ix, decoder) {
                return decoder.std * X[ix] + decoder.mean;
            };
            while (i < row.length) {
                var decoder = decoders[numFieldsDecoded++];
                if (decoder.type === 'string') {
                    record[decoder.key] = getStrVal(row, i, decoder);
                }
                else if (decoder.type === 'number') {
                    record[decoder.key] = getNumbVal(row, i, decoder);
                }
                else if (decoder.type === 'boolean') {
                    record[decoder.key] = getBoolVal(row, i);
                }
                else {
                    record[decoder.key] = row[i];
                }
                // record[decoder.key] = getValue(row, i, decoder);
                i += decoder.offset ? decoder.offset : 1;
            }
            return record;
        };
        /**
         * Standardizing field
         * Example dataset:
         * [ { planet: 'mars', isGasGiant: false, value: 10 },
         * { planet: 'saturn', isGasGiant: true, value: 20 },
         * { planet: 'jupiter', isGasGiant: true, value: 30 } ]
         *
         * @param key: each key/feature such as planet, isGasGiant and value
         * @param data: the entire dataset
         * @returns {any}
         */
        OneHotEncoder.prototype.standardizeField = function (key, data) {
            var type = typeof data[0][key];
            var values = _.map(data, key);
            switch (type) {
                case 'string': {
                    var result = this.buildStringOneHot(type, key, values);
                    return {
                        decode: result.decode,
                        encoded: result.encoded
                    };
                }
                case 'number': {
                    // Apply std to values if type is number
                    // standardize: ((n - mean)/std)
                    // TODO: add support for scaling to [0, 1]
                    var result = this.buildNumberOneHot(type, key, values);
                    return {
                        decode: result.decode,
                        encoded: result.encoded
                    };
                }
                case 'boolean': {
                    // True == 1
                    // False == 0
                    var result = this.buildBooleanOneHot(type, key, values);
                    return {
                        decode: result.decode,
                        encoded: result.encoded
                    };
                }
                default:
                    return values;
            }
        };
        /**
         * One hot encode a number value
         *
         * @param type
         * @param key
         * @param values
         * @returns {{encoded: any[]; decode: {type: any; mean: number; std: number; key: any}}}
         */
        OneHotEncoder.prototype.buildNumberOneHot = function (type, key, values) {
            var mean = _.mean(values);
            var std = this.calculateStd(values, mean);
            return {
                decode: { type: type, mean: mean, std: std, key: key },
                encoded: _.map(values, function (value) { return (value - mean) / std; })
            };
        };
        /**
         * One hot encode a boolean value
         *
         * Example usage:
         * boolEncoder.encode(true) => 1
         * boolEncoder.encode(false) => 0
         *
         * @param type
         * @param key
         * @param values
         * @returns {{encode}}
         */
        OneHotEncoder.prototype.buildBooleanOneHot = function (type, key, values) {
            return {
                decode: { type: type, key: key },
                encoded: _.map(values, function (value) { return (value ? 1 : 0); })
            };
        };
        /**
         * One hot encode a string value
         *
         * Example for internal reference (unnecessary details for those just using this module)
         *
         * const encoder = buildOneHot(['RAIN', 'RAIN', 'SUN'])
         * // encoder == { encode: () => ... , lookupTable: ['RAIN', 'SUN'] }
         * encoder.encode('SUN')  // [0, 1]
         * encoder.encode('RAIN') // [1, 0]
         * encoder.encode('SUN')  // [1, 0]
         * // encoder.lookupTable can then be passed into this.decode to translate [0, 1] back into 'SUN'
         *
         * It's not ideal (ideally it would all just be done in-memory and we could return a "decode" closure,
         * but it needs to be serializable to plain old JSON.
         */
        OneHotEncoder.prototype.buildStringOneHot = function (type, key, values) {
            var lookup = {};
            var i = 0;
            var lookupTable = _.map(_.uniq(values), function (value) {
                _.set(lookup, value, i++);
                return value;
            });
            var encoded = _.map(values, function (value) {
                return _.range(0, i).map(function (pos) { return (_.get(lookup, value) === pos ? 1 : 0); });
            });
            return {
                decode: {
                    key: key,
                    lookupTable: lookupTable,
                    offset: encoded[0].length,
                    type: type
                },
                encoded: encoded
            };
        };
        return OneHotEncoder;
    }());
    exports.OneHotEncoder = OneHotEncoder;
    /**
     * Transforms features by scaling each feature to a given range.
     *
     * This estimator scales and translates each feature individually such that it is in the given range on the training set, i.e. between zero and one.
     *
     * The transformation is given by:
     *
     * ```
     * X_std = (X - X.min(axis=0)) / (X.max(axis=0) - X.min(axis=0))
     * X_scaled = X_std * (max - min) + min
     * ```
     *
     * where min, max = feature_range.
     *
     * This transformation is often used as an alternative to zero mean, unit variance scaling.
     *
     * @example
     * import { MinMaxScaler } from 'machinelearn/preprocessing';
     *
     * const minmaxScaler = new MinMaxScaler({ featureRange: [0, 1] });
     *
     * // Fitting an 1D matrix
     * minmaxScaler.fit([4, 5, 6]);
     * const result = minmaxScaler.transform([4, 5, 6]);
     * // result = [ 0, 0.5, 1 ]
     *
     * // Fitting a 2D matrix
     * const minmaxScaler2 = new MinMaxScaler({ featureRange: [0, 1] });
     * minmaxScaler2.fit([[1, 2, 3], [4, 5, 6]]);
     * const result2 = minmaxScaler2.transform([[1, 2, 3]]);
     * // result2 = [ [ 0, 0.2, 0.4000000000000001 ] ]
     *
     */
    var MinMaxScaler = /** @class */ (function () {
        /**
         * @param featureRange - scaling range
         */
        function MinMaxScaler(_a) {
            var _b = (_a === void 0 ? {
                featureRange: [0, 1]
            } : _a).featureRange, featureRange = _b === void 0 ? [0, 1] : _b;
            this.featureRange = featureRange;
        }
        /**
         * Compute the minimum and maximum to be used for later scaling.
         * @param {number[]} X - Array or sparse-matrix data input
         */
        MinMaxScaler.prototype.fit = function (X) {
            if (X === void 0) { X = null; }
            var rowMax = tf.tensor(X);
            var rowMin = tf.tensor(X);
            var xShape = ops_7.inferShape(X);
            // If input is a Matrix...
            if (xShape.length === 0 || xShape[0] === 0) {
                throw new TypeError('Cannot fit with an empty value');
            }
            else if (xShape.length === 2) {
                rowMax = tf.max(rowMax, 0);
                rowMin = tf.min(rowMin, 0);
            }
            this.dataMax = tf.max(rowMax).dataSync()[0];
            this.dataMin = tf.min(rowMin).dataSync()[0];
            this.featureMax = this.featureRange[1];
            this.featureMin = this.featureRange[0];
            // const zz = zzdataMax - zzdataMin;
            this.dataRange = this.dataMax - this.dataMin;
            // We need different data range for multi-dimensional
            this.scale = (this.featureMax - this.featureMin) / this.dataRange;
            this.baseMin = this.featureMin - this.dataMin * this.scale;
        };
        /**
         * Fit to data, then transform it.
         * @param X - Original input vector
         */
        MinMaxScaler.prototype.fit_transform = function (X) {
            this.fit(X);
            return this.transform(X);
        };
        /**
         * Scaling features of X according to feature_range.
         * @param X - Original input vector
         */
        MinMaxScaler.prototype.transform = function (X) {
            var _this = this;
            if (X === void 0) { X = null; }
            // Transforms a single vector
            var transform_single = function (_X) {
                var X1 = _X.map(function (x) { return x * _this.scale; });
                return X1.map(function (x) { return x + _this.baseMin; });
            };
            var shapes = ops_7.inferShape(X);
            if (shapes.length === 2) {
                return X.map(function (z) { return transform_single(z); });
            }
            else if (shapes.length === 1) {
                return transform_single(X);
            }
            else {
                throw new TypeError("The input shape " + JSON.stringify(shapes) + " cannot be transformed");
            }
        };
        /**
         * Undo the scaling of X according to feature_range.
         * @param {number[]} X - Scaled input vector
         */
        MinMaxScaler.prototype.inverse_transform = function (X) {
            var _this = this;
            if (X === void 0) { X = null; }
            ops_7.validateMatrix1D(X);
            var X1 = X.map(function (x) { return x - _this.baseMin; });
            return X1.map(function (x) { return x / _this.scale; });
        };
        return MinMaxScaler;
    }());
    exports.MinMaxScaler = MinMaxScaler;
    /**
     * Binarizer transform your data using a binary threshold.
     * All values above the threshold are marked 1 and all equal to or below are marked as 0.
     *
     * It can also be used as a pre-processing step for estimators that consider
     * boolean random variables (e.g. modelled using the Bernoulli distribution in
     * a Bayesian setting).
     *
     * @example
     * import { Binarizer } from 'machinelearn/preprocessing';
     *
     * const binX = [[1, -1, 2], [2, 0, 0], [0, 1, -1]];
     * const binarizer = new Binarizer({ threshold: 0 });
     * const result = binarizer.transform(binX);
     * // [ [ 1, 0, 1 ], [ 1, 0, 0 ], [ 0, 1, 0 ] ]
     */
    var Binarizer = /** @class */ (function () {
        /**
         *
         * @param {number} threshold - Feature values below or equal to this are replaced by 0, above it by 1.
         * @param {boolean} copy - Flag to clone the input value.
         */
        function Binarizer(_a) {
            var _b = _a === void 0 ? {
                // Default value on empty constructor
                copy: true,
                threshold: 0
            } : _a, 
            // Each object param default value
            _c = _b.copy, 
            // Each object param default value
            copy = _c === void 0 ? true : _c, _d = _b.threshold, threshold = _d === void 0 ? 0 : _d;
            this.threshold = threshold;
            this.copy = copy;
        }
        /**
         * Currently fit does nothing
         * @param {any[]} X - Does nothing
         */
        Binarizer.prototype.fit = function (X) {
            if (X === void 0) { X = null; }
            if (Array.isArray(X) && X.length === 0) {
                throw new TypeError('X cannot be empty');
            }
            ops_7.validateMatrix2D(X);
            console.info("Currently Bianrizer's fit is designed to do nothing");
        };
        /**
         * Transforms matrix into binarized form
         * X = [[ 1., -1.,  2.],
         *      [ 2.,  0.,  0.],
         *      [ 0.,  1., -1.]]
         * becomes
         * array([[ 1.,  0.,  1.],
         *    [ 1.,  0.,  0.],
         *    [ 0.,  1.,  0.]])
         * @param {any[]} X - The data to binarize.
         */
        Binarizer.prototype.transform = function (X) {
            if (X === void 0) { X = null; }
            var _X = this.copy ? _.clone(X) : X;
            if (Array.isArray(_X) && _X.length === 0) {
                throw new TypeError('X cannot be empty');
            }
            ops_7.validateMatrix2D(_X);
            for (var row = 0; row < _.size(X); row++) {
                var rowValue = _.get(X, "[" + row + "]");
                for (var column = 0; column < _.size(rowValue); column++) {
                    var item = _.get(X, "[" + row + "][" + column + "]");
                    // Type checking item; It must be a number type
                    if (!_.isNumber(item)) {
                        throw new Error("Value " + item + " is not a number");
                    }
                    // If current item is less than
                    _X[row][column] = item <= this.threshold ? 0 : 1;
                }
            }
            return _X;
        };
        return Binarizer;
    }());
    exports.Binarizer = Binarizer;
    /**
     * Generate polynomial and interaction features.
     *
     * Generate a new feature matrix consisting of all polynomial combinations of the features
     * with degree less than or equal to the specified degree. For example, if an input sample
     * is two dimensional and of the form [a, b], the degree-2 polynomial features are [1, a, b, a^2, ab, b^2].
     *
     * @example
     * import { PolynomialFeatures } from 'machinelearn/preprocessing';
     * const poly = new PolynomialFeatures();
     * const X = [[0, 1], [2, 3], [4, 5]];
     * poly.transform(X);
     * // Result:
     * // [ [ 1, 0, 1, 0, 0, 1 ],
     * // [ 1, 2, 3, 4, 6, 9 ],
     * // [ 1, 4, 5, 16, 20, 25 ] ]
     *
     */
    var PolynomialFeatures = /** @class */ (function () {
        /**
         *
         * @param degree - The degree of the polynomial features. Default = 2.
         */
        function PolynomialFeatures(_a) {
            var _b = (_a === void 0 ? {
                degree: 2
            } : _a).degree, degree = _b === void 0 ? 2 : _b;
            // Constructor variables validation
            if (!Number.isInteger(degree)) {
                throw new Error('Degree must be a number');
            }
            this.degree = degree;
        }
        /**
         * Transforms the input data
         * @param X - a matrix
         */
        PolynomialFeatures.prototype.transform = function (X) {
            if (X === void 0) { X = null; }
            if (Array.isArray(X) && X.length === 0) {
                throw new TypeError('X cannot be empty');
            }
            ops_7.validateMatrix2D(X);
            var matrix = tf.tensor2d(X);
            var _a = __read(matrix.shape, 2), nSamples = _a[0], nFeatures = _a[1];
            var indexCombination = this.indexCombination(nFeatures, this.degree);
            var nOutputFeatures = indexCombination.length;
            // Polynomial feature extraction loop begins
            var tfOnes = tf.ones([nSamples, nOutputFeatures]);
            var result = ops_7.reshape(Array.from(tfOnes.dataSync()), tfOnes.shape);
            var rowRange = _.range(0, X.length);
            for (var i = 0; i < indexCombination.length; i++) {
                var c = indexCombination[i];
                var colsRange = Array.isArray(c) ? c : [c];
                // Retrieves column values from X using the index of the indexCombination in the loop
                var srcColValues = c !== null ? MathExtra_2.default.subset(X, rowRange, colsRange) : [];
                var xc = null;
                if (srcColValues.length === 0) {
                    xc = _.fill(rowRange.slice(), 1);
                }
                else {
                    xc = tf
                        .tensor2d(srcColValues)
                        .prod(1)
                        .dataSync();
                }
                result = MathExtra_2.default.subset(result, rowRange, [i], xc);
            }
            return result;
        };
        /**
         * Creates a combination of index according to nFeautres and degree
         * @param nFeatures
         * @param degree
         */
        PolynomialFeatures.prototype.indexCombination = function (nFeatures, degree) {
            var range = _.range(0, degree + 1);
            var combs = range.map(function (i) {
                return permutations_1.combinationsWithReplacement(_.range(nFeatures), i);
            });
            return combs.reduce(function (sum, cur) {
                return sum.concat(cur);
            }, []);
        };
        return PolynomialFeatures;
    }());
    exports.PolynomialFeatures = PolynomialFeatures;
    /**
     * Data normalization is a process of scaling dataset based on Vector Space Model, and by default, it uses L2 normalization.
     * At a higher level, the chief difference between the L1 and the L2 terms is that the L2 term is proportional
     * to the square of the   values, while the L1 norm is proportional the absolute value of the values in   .
     *
     * @example
     * import { normalize } from 'machinelearn/preprocessing';
     *
     * const result = normalize([
     *   [1, -1, 2],
     *   [2, 0, 0],
     *   [0, 1, -1],
     * ], { norm: 'l2' });
     * console.log(result);
     * // [ [ 0.4082482904638631, -0.4082482904638631, 0.8164965809277261 ],
     * // [ 1, 0, 0 ],
     * // [ 0, 0.7071067811865475, -0.7071067811865475 ] ]
     *
     * @param X - The data to normalize
     * @param norm - The norm to use to normalize each non zero sample; can be either 'l1' or 'l2'
     * @return number[][]
     */
    function normalize(X, _a) {
        if (X === void 0) { X = null; }
        var _b = (_a === void 0 ? {
            norm: 'l2'
        } : _a).norm, norm = _b === void 0 ? 'l2' : _b;
        if (Array.isArray(X) && X.length === 0) {
            throw new TypeError('X cannot be empty');
        }
        ops_7.validateMatrix2D(X);
        var normalizedMatrix = [];
        for (var i = 0; i < X.length; i++) {
            var row = X[i];
            // Adding a placeholder array
            normalizedMatrix.push([]);
            // Getting the row's square root
            var proportion = 0; // note: any because math.pow return MathType
            // Normalization proportion value
            if (norm === 'l1') {
                proportion = row.reduce(function (accum, r) { return accum + Math.abs(r); }, 0);
            }
            else if (norm === 'l2') {
                proportion = row.reduce(function (accum, r) { return accum + Math.pow(r, 2); }, 0);
                proportion = Math.sqrt(proportion);
            }
            else {
                throw new Error(norm + " is not a recognised normalization method");
            }
            // Finally applying a cubic root to the total value
            for (var k = 0; k < row.length; k++) {
                var value = row[k] / proportion;
                normalizedMatrix[i].push(value);
            }
        }
        return normalizedMatrix;
    }
    exports.normalize = normalize;
});
define("lib/preprocessing/Imputer", ["require", "exports", "lodash", "lib/ops/index", "lib/utils/MathExtra"], function (require, exports, _, ops_8, MathExtra_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    _ = __importStar(_);
    MathExtra_3 = __importDefault(MathExtra_3);
    /**
     * Imputation transformer for completing missing values.
     *
     * @example
     * import { Imputer } from 'preprocessing/Imputer';
     *
     * const testX = [[1, 2], [null, 3], [7, 6]];
     * const imp = new Imputer({ missingValues: null, axis: 0 });
     * imp.fit(testX);
     * const impResult = imp.fit_transform([[null, 2], [6, null], [7, 6]]);
     * // [ [ 4, 2 ], [ 6, 3.6666666666666665 ], [ 7, 6 ] ]
     */
    var Imputer = /** @class */ (function () {
        /**
         *
         * @param {any} missingValues - Target missing value to impute
         * @param {any} strategy - Missing value replacement strategy
         * @param {any} axis - Direction to impute
         * @param {any} copy - To clone the input value
         */
        function Imputer(_a) {
            var _b = _a.missingValues, missingValues = _b === void 0 ? null : _b, _c = _a.strategy, strategy = _c === void 0 ? 'mean' : _c, _d = _a.axis, axis = _d === void 0 ? 0 : _d, 
            // verbose = 0,
            _e = _a.copy, 
            // verbose = 0,
            copy = _e === void 0 ? false : _e;
            var _this = this;
            /**
             * Calculate array of numbers as array of mean values
             * Examples:
             * [ [ 1, 2 ], [ null, 3 ], [ 123, 3 ] ]
             * => [ 1.5, 3, 63 ]
             *
             * [ [ 1, 123 ], [ 2, 3, 3 ] ]
             * => [ 62, 2.6666666666666665 ]
             *
             * @param matrix
             * @param {string[]} steps
             */
            this.calcArrayMean = function (matrix, steps) {
                // TODO: Fix any return type
                // TODO: Fix matrix type any
                return _.reduce(steps, function (result, step) {
                    switch (step) {
                        case 'flatten':
                            return _.map(result, _.flatten);
                        case 'filter':
                            return _.map(result, 
                            // Expecting any type of matrics array
                            // TODO: implement a correct type
                            function (arr) {
                                return _.filter(arr, function (z) { return z !== _this.missingValues; });
                            });
                        case 'mean':
                            return _.map(result, _.mean);
                        default:
                            return result;
                    }
                }, matrix);
            };
            this.missingValues = missingValues;
            this.strategy = strategy;
            this.axis = axis;
            // this.verbose = verbose;
            this.copy = copy;
            this.means = [];
        }
        /**
         * Fit the imputer on X.
         * @param {any[]} X - Input data in array or sparse matrix format
         */
        Imputer.prototype.fit = function (X) {
            if (X === void 0) { X = null; }
            ops_8.validateMatrix2D(X);
            var _X = this.copy ? _.clone(X) : X;
            var rowLen = MathExtra_3.default.size(_X, 0);
            var colLen = MathExtra_3.default.size(_X, 1);
            var rowRange = MathExtra_3.default.range(0, rowLen);
            var colRange = MathExtra_3.default.range(0, colLen);
            if (this.strategy === 'mean') {
                if (this.axis === 0) {
                    var colNumbers = _.map(colRange, function (col) {
                        return MathExtra_3.default.subset(_X, rowRange, [col]);
                    });
                    this.means = this.calcArrayMean(colNumbers, [
                        'flatten',
                        'filter',
                        'mean'
                    ]);
                }
                else if (this.axis === 1) {
                    var rowNumbers = _.map(rowRange, function (row) { return _.get(_X, "[" + row + "]"); });
                    this.means = this.calcArrayMean(rowNumbers, ['filter', 'mean']);
                }
            }
            else {
                throw new Error("Unsupported strategy " + this.strategy + " was given");
            }
        };
        /**
         * Fit to data, then transform it.
         * @param {any[]} X - Input data in array or sparse matrix format
         * @returns {any[]}
         */
        Imputer.prototype.fit_transform = function (X) {
            if (X === void 0) { X = null; }
            ops_8.validateMatrix2D(X);
            var _X = _.clone(X);
            if (this.strategy === 'mean' && this.axis === 0) {
                // Mean column direction transform
                for (var row = 0; row < _.size(_X); row++) {
                    for (var col = 0; col < _.size(_X[row]); col++) {
                        var value = _X[row][col];
                        _X[row][col] = value === this.missingValues ? this.means[row] : value;
                    }
                }
            }
            else if (this.strategy === 'mean' && this.axis === 1) {
                // Mean row direction transform
                for (var row = 0; row < _.size(_X); row++) {
                    for (var col = 0; col < _.size(_X[row]); col++) {
                        var value = _X[row][col];
                        _X[row][col] = value === this.missingValues ? this.means[col] : value;
                    }
                }
            }
            else {
                throw new Error("Unknown transformation with strategy " + this.strategy + " and axis " + this.axis);
            }
            return _X;
        };
        return Imputer;
    }());
    exports.Imputer = Imputer;
});
define("lib/preprocessing/index", ["require", "exports", "lib/preprocessing/data", "lib/preprocessing/Imputer"], function (require, exports, data_1, Imputer_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.add_dummy_feature = data_1.add_dummy_feature;
    exports.Binarizer = data_1.Binarizer;
    exports.MinMaxScaler = data_1.MinMaxScaler;
    exports.normalize = data_1.normalize;
    exports.OneHotEncoder = data_1.OneHotEncoder;
    exports.PolynomialFeatures = data_1.PolynomialFeatures;
    exports.Imputer = Imputer_1.Imputer;
});
define("lib/linear_model/stochastic_gradient", ["require", "exports", "@tensorflow/tfjs", "lodash", "random-js", "lib/ops/index"], function (require, exports, tf, lodash_7, Random, ops_9) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    tf = __importStar(tf);
    Random = __importStar(Random);
    var TypeLoss;
    (function (TypeLoss) {
        TypeLoss["L1"] = "L1";
        TypeLoss["L2"] = "L2";
        TypeLoss["L1L2"] = "L1L2";
    })(TypeLoss = exports.TypeLoss || (exports.TypeLoss = {}));
    /**
     * Ordinary base class for SGD classier or regressor
     * @ignore
     */
    var BaseSGD = /** @class */ (function () {
        /**
         * @param preprocess - preprocess methodology can be either minmax or null. Default is minmax.
         * @param learning_rate - Used to limit the amount each coefficient is corrected each time it is updated.
         * @param epochs - Number of iterations.
         * @param clone - To clone the passed in dataset.
         */
        function BaseSGD(_a) {
            var _b = _a === void 0 ? {
                learning_rate: 0.0001,
                epochs: 10000,
                clone: true,
                random_state: null,
                loss: TypeLoss.L2,
                reg_factor: null
            } : _a, _c = _b.learning_rate, learning_rate = _c === void 0 ? 0.0001 : _c, _d = _b.epochs, epochs = _d === void 0 ? 10000 : _d, _e = _b.clone, clone = _e === void 0 ? true : _e, _f = _b.random_state, random_state = _f === void 0 ? null : _f, _g = _b.loss, loss = _g === void 0 ? TypeLoss.L2 : _g, _h = _b.reg_factor, reg_factor = _h === void 0 ? null : _h;
            this.clone = true;
            this.weights = null;
            this.learningRate = learning_rate;
            this.epochs = epochs;
            this.clone = clone;
            this.randomState = random_state;
            this.loss = loss;
            this.regFactor = reg_factor;
            // Setting a loss function according to the input option
            if (this.loss === TypeLoss.L1 && this.regFactor) {
                this.loss = tf.regularizers.l1({
                    l1: this.regFactor.l1
                });
            }
            else if (this.loss === TypeLoss.L1L2 && this.regFactor) {
                this.loss = tf.regularizers.l1l2({
                    l1: this.regFactor.l1,
                    l2: this.regFactor.l2
                });
            }
            else if (this.loss === TypeLoss.L2 && this.regFactor) {
                this.loss = tf.regularizers.l2({
                    l2: this.regFactor.l2
                });
            }
            else {
                this.loss = tf.regularizers.l2();
            }
            // Random Engine
            if (Number.isInteger(this.randomState)) {
                this.randomEngine = Random.engines.mt19937().seed(this.randomState);
            }
            else {
                this.randomEngine = Random.engines.mt19937().autoSeed();
            }
        }
        /**
         * Train the base SGD
         * @param X - Matrix of data
         * @param y - Matrix of targets
         */
        BaseSGD.prototype.fit = function (X, y) {
            if (X === void 0) { X = null; }
            if (y === void 0) { y = null; }
            ops_9.validateFitInputs(X, y);
            // holds all the preprocessed X values
            // Clone according to the clone flag
            var clonedX = this.clone ? lodash_7.cloneDeep(X) : X;
            var clonedY = this.clone ? lodash_7.cloneDeep(y) : y;
            this.sgd(clonedX, clonedY);
        };
        /**
         * Save the model's checkpoint
         */
        BaseSGD.prototype.toJSON = function () {
            return {
                learning_rate: this.learningRate,
                epochs: this.epochs,
                weights: __spread(this.weights.dataSync()),
                random_state: this.randomState
            };
        };
        /**
         * Restore the model from a checkpoint
         * @param learning_rate - Training learning rate
         * @param epochs - Number of model's training epochs
         * @param weights - Model's training state
         * @param random_state - Static random state for the model initialization
         */
        BaseSGD.prototype.fromJSON = function (_a) {
            var _b = _a === void 0 ? {
                learning_rate: 0.0001,
                epochs: 10000,
                weights: [],
                random_state: null
            } : _a, _c = _b.learning_rate, learning_rate = _c === void 0 ? 0.0001 : _c, _d = _b.epochs, epochs = _d === void 0 ? 10000 : _d, _e = _b.weights, weights = _e === void 0 ? [] : _e, _f = _b.random_state, random_state = _f === void 0 ? null : _f;
            this.learningRate = learning_rate;
            this.epochs = epochs;
            this.weights = tf.tensor(weights);
            this.randomState = random_state;
        };
        /**
         * Predictions according to the passed in test set
         * @param X - Matrix of data
         */
        BaseSGD.prototype.predict = function (X) {
            if (X === void 0) { X = null; }
            ops_9.validateMatrix2D(X);
            // Adding bias
            var biasX = this.addBias(X);
            var tensorX = tf.tensor(biasX);
            var yPred = tensorX.dot(this.weights);
            return __spread(yPred.dataSync());
        };
        /**
         * Initialize weights based on the number of features
         *
         * @example
         * initializeWeights(3);
         * // this.w = [-0.213981293, 0.12938219, 0.34875439]
         *
         * @param nFeatures
         */
        BaseSGD.prototype.initializeWeights = function (nFeatures) {
            var _this = this;
            var limit = 1 / Math.sqrt(nFeatures);
            var distribution = Random.real(-limit, limit);
            var getRand = function () { return distribution(_this.randomEngine); };
            this.weights = tf.tensor1d(lodash_7.range(0, nFeatures).map(function () { return getRand(); }));
        };
        /**
         * Adding bias to a given array
         *
         * @example
         * addBias([[1, 2], [3, 4]], 1);
         * // [[1, 1, 2], [1, 3, 4]]
         *
         * @param X
         * @param bias
         */
        BaseSGD.prototype.addBias = function (X, bias) {
            if (bias === void 0) { bias = 1; }
            // TODO: Is there a TF way to achieve it?
            return X.reduce(function (sum, cur) {
                sum.push([bias].concat(cur));
                return sum;
            }, []);
        };
        /**
         * SGD based on linear model to calculate coefficient
         * @param X - training data
         * @param y - target data
         */
        BaseSGD.prototype.sgd = function (X, y) {
            var tensorX = tf.tensor2d(this.addBias(X));
            this.initializeWeights(tensorX.shape[1]);
            var tensorY = tf.tensor1d(y);
            var tensorLR = tf.tensor(this.learningRate);
            for (var e = 0; e < this.epochs; e++) {
                var yPred = tensorX.dot(this.weights);
                var gradW = tensorY
                    .sub(yPred)
                    .neg()
                    .dot(tensorX)
                    .add(this.loss.apply(this.weights));
                this.weights = this.weights.sub(tensorLR.mul(gradW));
            }
        };
        return BaseSGD;
    }());
    exports.BaseSGD = BaseSGD;
    /**
     * Linear classifiers (SVM, logistic regression, a.o.) with SGD training.
     *
     * This estimator implements regularized linear models with
     * stochastic gradient descent (SGD) learning: the gradient of
     * the loss is estimated each sample at a time and the model is
     * updated along the way with a decreasing strength schedule
     * (aka learning rate). SGD allows minibatch (online/out-of-core)
     * learning, see the partial_fit method. For best results using
     * the default learning rate schedule, the data should have zero mean
     * and unit variance.
     *
     * @example
     * import { SGDClassifier } from 'machinelearn/linear_model';
     * const clf = new SGDClassifier();
     * const X = [[0., 0.], [1., 1.]];
     * const y = [0, 1];
     * clf.fit(X ,y);
     * clf.predict([[2., 2.]]); // result: [ 1 ]
     *
     */
    var SGDClassifier = /** @class */ (function (_super) {
        __extends(SGDClassifier, _super);
        function SGDClassifier() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * Predicted values with Math.round applied
         * @param X - Matrix of data
         */
        SGDClassifier.prototype.predict = function (X) {
            if (X === void 0) { X = null; }
            var results = _super.prototype.predict.call(this, X);
            return results.map(function (x) { return Math.round(x); });
        };
        return SGDClassifier;
    }(BaseSGD));
    exports.SGDClassifier = SGDClassifier;
    /**
     * Linear model fitted by minimizing a regularized empirical loss with SGD
     * SGD stands for Stochastic Gradient Descent: the gradient of the loss
     * is estimated each sample at a time and the model is updated along
     * the way with a decreasing strength schedule (aka learning rate).
     *
     * @example
     * import { SGDRegressor } from 'machinelearn/linear_model';
     * const reg = new SGDRegressor();
     * const X = [[0., 0.], [1., 1.]];
     * const y = [0, 1];
     * reg.fit(X, y);
     * reg.predict([[2., 2.]]); // result: [ 1.281828588248001 ]
     *
     */
    var SGDRegressor = /** @class */ (function (_super) {
        __extends(SGDRegressor, _super);
        function SGDRegressor() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * Predicted values
         * @param X - Matrix of data
         */
        SGDRegressor.prototype.predict = function (X) {
            if (X === void 0) { X = null; }
            return _super.prototype.predict.call(this, X);
        };
        return SGDRegressor;
    }(BaseSGD));
    exports.SGDRegressor = SGDRegressor;
});
define("lib/linear_model/coordinate_descent", ["require", "exports", "lib/preprocessing/index", "lib/linear_model/stochastic_gradient"], function (require, exports, preprocessing_1, stochastic_gradient_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Linear least squares with l2 regularization.
     *
     * Mizimizes the objective function:
     *
     *
     * ||y - Xw||^2_2 + alpha * ||w||^2_2
     *
     *
     * This model solves a regression model where the loss function is the linear least squares function
     * and regularization is given by the l2-norm. Also known as Ridge Regression or Tikhonov regularization.
     * This estimator has built-in support for multi-variate regression (i.e., when y is a 2d-array of shape [n_samples, n_targets]).
     *
     * @example
     * import { Iris } from 'machinelearn/datasets';
     * import { Ridge } from 'machinelearn/linear_model';
     * (async function() {
     *   const irisData = new Iris();
     *   const {
     *     data,         // returns the iris data (X)
     *     targets,      // list of target values (y)
     *   } = await irisData.load(); // loads the data internally
     *
     *   const reg = new Ridge({ l2: 1 });
     *   reg.fit(data, target);
     *   reg.predict([[5.1,3.5,1.4,0.2]]);
     * })();
     *
     */
    var Ridge = /** @class */ (function (_super) {
        __extends(Ridge, _super);
        /**
         * @param l2 - Regularizer factor
         * @param epochs - Number of epochs
         * @param learning_rate - learning rate
         */
        function Ridge(_a) {
            var _b = _a === void 0 ? {
                l2: null,
                epochs: 1000,
                learning_rate: 0.001
            } : _a, _c = _b.l2, l2 = _c === void 0 ? null : _c, _d = _b.epochs, epochs = _d === void 0 ? 1000 : _d, _e = _b.learning_rate, learning_rate = _e === void 0 ? 0.001 : _e;
            var _this = this;
            if (l2 === null) {
                throw TypeError('Ridge cannot be initiated with null l2');
            }
            _this = _super.call(this, {
                reg_factor: { l2: l2 },
                learning_rate: learning_rate,
                epochs: epochs,
                loss: stochastic_gradient_1.TypeLoss.L2.toString()
            }) || this;
            return _this;
        }
        return Ridge;
    }(stochastic_gradient_1.SGDRegressor));
    exports.Ridge = Ridge;
    /**
     * Linear Model trained with L1 prior as regularizer (aka the Lasso)
     *
     * The optimization objective for Lasso is:
     *
     * (1 / (2 * n_samples)) * ||y - Xw||^2_2 + alpha * ||w||_1
     *
     * Technically the Lasso model is optimizing the same objective function as the Elastic Net with l1_ratio value (no L2 penalty).
     *
     * @example
     * import { Iris } from 'machinelearn/datasets';
     * import { Lasso } from 'machinelearn/linear_model';
     * (async function() {
     *   const irisData = new Iris();
     *   const {
     *     data,         // returns the iris data (X)
     *     targets,      // list of target values (y)
     *   } = await irisData.load(); // loads the data internally
     *
     *   const reg = new Lasso({ degree: 2, l1: 1 });
     *   reg.fit(data, target);
     *   reg.predict([[5.1,3.5,1.4,0.2]]);
     * })();
     *
     */
    var Lasso = /** @class */ (function (_super) {
        __extends(Lasso, _super);
        /**
         * @param degree - Polynomial feature extraction degree
         * @param l1 - Regularizer factor
         * @param epochs - Number of epochs
         * @param learning_rate - Learning rate
         */
        function Lasso(_a) {
            var _b = _a === void 0 ? {
                degree: null,
                l1: null,
                epochs: 1000,
                learning_rate: 0.001
            } : _a, _c = _b.degree, degree = _c === void 0 ? null : _c, l1 = _b.l1, _d = _b.epochs, epochs = _d === void 0 ? 1000 : _d, _e = _b.learning_rate, learning_rate = _e === void 0 ? 0.001 : _e;
            var _this = this;
            if (l1 === null) {
                throw TypeError('Lasso cannot be initiated with null l1');
            }
            if (degree === null) {
                throw TypeError('Lasso cannot be initiated with null degree');
            }
            _this = _super.call(this, {
                reg_factor: { l1: l1 },
                learning_rate: learning_rate,
                epochs: epochs,
                loss: stochastic_gradient_1.TypeLoss.L1.toString()
            }) || this;
            _this.degree = degree;
            return _this;
        }
        /**
         * Fit model with coordinate descent.
         * @param X - A matrix of samples
         * @param y - A vector of targets
         */
        Lasso.prototype.fit = function (X, y) {
            if (X === void 0) { X = null; }
            if (y === void 0) { y = null; }
            var polynomial = new preprocessing_1.PolynomialFeatures({ degree: this.degree });
            var newX = preprocessing_1.normalize(polynomial.transform(X));
            _super.prototype.fit.call(this, newX, y);
        };
        /**
         * Predict using the linear model
         * @param X - A matrix of test data
         */
        Lasso.prototype.predict = function (X) {
            if (X === void 0) { X = null; }
            var polynomial = new preprocessing_1.PolynomialFeatures({ degree: this.degree });
            var newX = preprocessing_1.normalize(polynomial.transform(X));
            return _super.prototype.predict.call(this, newX);
        };
        return Lasso;
    }(stochastic_gradient_1.SGDRegressor));
    exports.Lasso = Lasso;
});
define("lib/linear_model/linear_regression", ["require", "exports", "@tensorflow/tfjs", "lodash", "numeric", "lib/ops/index", "lib/utils/MathExtra"], function (require, exports, tf, lodash_8, numeric, ops_10, MathExtra_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    tf = __importStar(tf);
    numeric = __importStar(numeric);
    MathExtra_4 = __importDefault(MathExtra_4);
    /**
     * Type of Linear Regression
     * Univariate = It can handle a 1 dimensional input
     * Multivariate = It can handle a 2 dimensional input
     * @ignore
     */
    var TypeLinearReg;
    (function (TypeLinearReg) {
        TypeLinearReg["UNIVARIATE"] = "UNIVARIATE";
        TypeLinearReg["MULTIVARIATE"] = "MULTIVARIATE";
    })(TypeLinearReg = exports.TypeLinearReg || (exports.TypeLinearReg = {}));
    /**
     * Ordinary least squares Linear Regression.
     *
     * It supports both univariate and multivariate linear regressions.
     *
     * @example
     * import { LinearRegression } from './linear_regression';
     * const linearRegression = new LinearRegression();
     * const X = [1, 2, 4, 3, 5];
     * const y = [1, 3, 3, 2, 5];
     * linearRegression.fit(X, y);
     * lr.predict([1, 2]);
     * // [ 1.1999999999999995, 1.9999999999999996 ]
     *
     * const linearRegression2 = new LinearRegression();
     * const X2 = [[1, 1], [1, 2], [2, 2], [2, 3]];
     * const y2 = [1, 1, 2, 2];
     * linearRegression2.fit(X2, y2);
     * lr.predict([[1, 2]]);
     * // [1.0000001788139343]
     */
    var LinearRegression = /** @class */ (function () {
        function LinearRegression() {
            this.weights = [];
            this.type = TypeLinearReg.MULTIVARIATE;
        }
        /**
         * fit linear model
         * @param {any} X - training values
         * @param {any} y - target values
         */
        LinearRegression.prototype.fit = function (X, y) {
            if (X === void 0) { X = null; }
            if (y === void 0) { y = null; }
            var xShape = ops_10.inferShape(X);
            var yShape = ops_10.inferShape(y);
            if (xShape.length === 1 && yShape.length === 1 && xShape[0] === yShape[0]) {
                // Univariate linear regression
                this.type = TypeLinearReg.UNIVARIATE;
                this.weights = this.calculateUnivariateCoeff(X, y); // getting b0 and b1
            }
            else if (xShape.length === 2 &&
                yShape.length === 1 &&
                xShape[0] === yShape[0]) {
                this.type = TypeLinearReg.MULTIVARIATE;
                this.weights = this.calculateMultiVariateCoeff(X, y);
            }
            else {
                throw new Error("Sample(" + xShape[0] + ") and target(" + yShape[0] + ") sizes do not match");
            }
        };
        /**
         * Predict using the linear model
         * @param {number} X - Values to predict.
         * @returns {number}
         */
        LinearRegression.prototype.predict = function (X) {
            if (X === void 0) { X = null; }
            var xShape = ops_10.inferShape(X);
            if (xShape.length === 1 &&
                this.type.toString() === TypeLinearReg.UNIVARIATE.toString()) {
                return this.univariatePredict(X);
            }
            else if (xShape.length === 2 &&
                this.type.toString() === TypeLinearReg.MULTIVARIATE.toString()) {
                return this.multivariatePredict(X);
            }
            else {
                throw new TypeError("The matrix is incorrectly shaped: while X is " + xShape.length + ", type is " + this.type.toString().toLowerCase());
            }
        };
        /**
         * Get the model details in JSON format
         */
        LinearRegression.prototype.toJSON = function () {
            return {
                weights: this.weights,
                type: this.type
            };
        };
        /**
         * Restore the model from a checkpoint
         */
        LinearRegression.prototype.fromJSON = function (_a) {
            var 
            /**
             * Model's weights
             */
            _b = _a.weights, 
            /**
             * Model's weights
             */
            weights = _b === void 0 ? null : _b, 
            /**
             * Type of linear regression, it can be either UNIVARIATE or MULTIVARIATE
             */
            _c = _a.type, 
            /**
             * Type of linear regression, it can be either UNIVARIATE or MULTIVARIATE
             */
            type = _c === void 0 ? null : _c;
            if (!weights || !type) {
                throw new Error('You must provide both weights and type to restore the linear regression model');
            }
            this.weights = weights;
            this.type = type;
        };
        /**
         * Univariate prediction
         * y = b0 + b1 * X
         *
         * @param X
         */
        LinearRegression.prototype.univariatePredict = function (X) {
            if (X === void 0) { X = null; }
            var preds = [];
            for (var i = 0; i < lodash_8.size(X); i++) {
                preds.push(this.weights[0] + this.weights[1] * X[i]);
            }
            return preds;
        };
        /**
         * Multivariate prediction
         * y = (b0 * X0) + (b1 * X1) + (b2 * X2) + ....
         *
         * @param X
         */
        LinearRegression.prototype.multivariatePredict = function (X) {
            if (X === void 0) { X = null; }
            var preds = [];
            for (var i = 0; i < X.length; i++) {
                var row = X[i];
                var yPred = 0;
                for (var j = 0; j < row.length; j++) {
                    yPred += this.weights[j] * row[j];
                }
                preds.push(yPred);
            }
            return preds;
        };
        /**
         * Calculates univariate coefficients for linear regression
         * @param X - X values
         * @param y - y targets
         */
        LinearRegression.prototype.calculateUnivariateCoeff = function (X, y) {
            var xMean = tf.mean(X).dataSync();
            var yMean = tf.mean(y).dataSync();
            var b1 = MathExtra_4.default.covariance(X, xMean, y, yMean) / MathExtra_4.default.variance(X, xMean);
            var b0 = yMean - b1 * xMean;
            return this.weights.concat([b0, b1]);
        };
        /**
         * Calculate multivariate coefficients for linear regression
         * @param X
         * @param y
         */
        LinearRegression.prototype.calculateMultiVariateCoeff = function (X, y) {
            var _a = __read(tf.linalg.qr(tf.tensor2d(X)), 2), q = _a[0], r = _a[1];
            var rawR = ops_10.reshape(Array.from(r.dataSync()), r.shape);
            var weights = tf
                .tensor(numeric.inv(rawR))
                .dot(q.transpose())
                .dot(tf.tensor(y))
                .dataSync();
            return Array.from(weights);
        };
        return LinearRegression;
    }());
    exports.LinearRegression = LinearRegression;
});
define("lib/linear_model/index", ["require", "exports", "lib/linear_model/coordinate_descent", "lib/linear_model/linear_regression", "lib/linear_model/stochastic_gradient"], function (require, exports, coordinate_descent_1, linear_regression_1, stochastic_gradient_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Lasso = coordinate_descent_1.Lasso;
    exports.Ridge = coordinate_descent_1.Ridge;
    exports.LinearRegression = linear_regression_1.LinearRegression;
    exports.SGDClassifier = stochastic_gradient_2.SGDClassifier;
    exports.SGDRegressor = stochastic_gradient_2.SGDRegressor;
    exports.TypeLoss = stochastic_gradient_2.TypeLoss;
});
define("lib/utils/validation", ["require", "exports", "lodash"], function (require, exports, _) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    _ = __importStar(_);
    /**
     * Check below array conditions
     * - multiclass
     *    - e.g. [ [1, 2], [2, 3] ]
     *      Then it sets multiclass value to true
     * - isArray<boolean>
     *   If the given arr is an array then the value is true else false
     * @param arr
     * @returns {any}
     * @ignore
     */
    function checkArray(arr) {
        var result = {
            isArray: false,
            multiclass: false
        };
        // Setting isArray flag
        if (_.isArray(arr)) {
            result = _.set(result, 'isArray', true);
        }
        else {
            result = _.set(result, 'isArray', false);
        }
        // Setting multiclass flag
        var firstElm = _.get(arr, '[0]');
        if (_.isArray(firstElm)) {
            result = _.set(result, 'multiclass', true);
        }
        else {
            result = _.set(result, 'multiclass', false);
        }
        return result;
    }
    exports.checkArray = checkArray;
});
define("lib/metrics/classification", ["require", "exports", "@tensorflow/tfjs", "lodash", "lib/ops/index", "lib/utils/validation"], function (require, exports, tf, _, ops_11, validation_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    tf = __importStar(tf);
    _ = __importStar(_);
    /**
     * util function to calculate a weighted sum
     * @param {any} sampleScore
     * @param {any} normalize
     * @returns {number}
     * @ignore
     */
    function _weightedSum(_a) {
        var sampleScore = _a.sampleScore, 
        // sampleWeight = null,
        _b = _a.normalize, 
        // sampleWeight = null,
        normalize = _b === void 0 ? false : _b;
        if (normalize) {
            return _.mean(sampleScore);
        }
        else {
            return _.sum(sampleScore);
        }
    }
    /**
     * Validator for classification exceptions
     * @param y_true
     * @param y_pred
     * @param labels
     * @param options
     * @ignore
     */
    exports.validateInitialInputs = function (y_true, y_pred, labels, options) {
        if (options === void 0) { options = {}; }
        var checkMultiClass = _.get(options, 'multiclass');
        // Multiclass
        if (checkMultiClass) {
            // TODO: Multi label
            if (validation_1.checkArray(y_true).multiclass || validation_1.checkArray(y_pred).multiclass) {
                throw new Error('Multiclass is not supported yet!');
            }
        }
        // Checking nullity or empty
        if (!y_true || _.isEmpty(y_true)) {
            throw new Error('y_true cannot be null or empty');
        }
        if (!y_pred || _.isEmpty(y_pred)) {
            throw new Error('y_pred cannot be null or empty');
        }
        // Checking the size equality
        if (_.size(y_true) !== _.size(y_pred)) {
            throw new Error('y_true and y_pred are not equal in size!');
        }
        // Checking labels equal to both y_true and y_pred classes
        // Labels is optional
        if (labels) {
            var yTrueCls = _.flowRight(function (x) { return _.sortBy(x, function (y) { return y; }); }, function (x) { return _.uniq(x); })(y_true);
            var yPredCls = _.flowRight(function (x) { return _.sortBy(x, function (y) { return y; }); }, function (x) { return _.uniq(x); })(y_pred);
            var sortedLabels = _.sortBy(labels, function (x) { return x; });
            if (!_.isEqual(sortedLabels, yTrueCls) ||
                !_.isEqual(sortedLabels, yPredCls)) {
                throw new Error('Labels must match the classes');
            }
        }
    };
    /**
     * Accuracy classification score.
     *
     * In multilabel classification, this function computes subset accuracy:
     * the set of labels predicted for a sample must exactly match the corresponding set of labels in y_true.
     *
     * @example
     * import { accuracyScore } from 'machinelearn/metrics';
     *
     * const accResult = accuracyScore(
     *  [0, 1, 2, 3],
     *  [0, 2, 1, 3]
     * );
     *
     * // accuracy result: 0.5
     *
     * @param y_true - 1d array-like, or label indicator array / sparse matrix
     * @param y_pred - 1d array-like, or label indicator array / sparse matrix
     * @param normalize
     */
    function accuracyScore(y_true, y_pred, _a) {
        if (y_true === void 0) { y_true = null; }
        if (y_pred === void 0) { y_pred = null; }
        var _b = (_a === void 0 ? {
            normalize: true
        } : _a).normalize, normalize = _b === void 0 ? true : _b;
        exports.validateInitialInputs(y_true, y_pred, null, { multiclass: true });
        var yTrueRange = _.range(0, _.size(y_true));
        var normalised = _.map(yTrueRange, function (index) {
            var yTrue = y_true[index];
            var yPred = y_pred[index];
            return yTrue === yPred ? 1 : 0;
        });
        return _weightedSum({
            normalize: normalize,
            sampleScore: normalised
        });
    }
    exports.accuracyScore = accuracyScore;
    /**
     * Zero-one classification loss.
     *
     * If normalize is `true`, return the fraction of misclassifications (float),
     * else it returns the number of misclassifications (int). The best performance is 0.
     *
     * @example
     * import { zeroOneLoss } from 'machinelearn/metrics';
     *
     * const loss_zero_one_result = zeroOneLoss(
     *   [1, 2, 3, 4],
     *   [2, 2, 3, 5]
     * );
     * console.log(loss_zero_one_result); // 0.5
     *
     * @param {any} y_true - Ground truth (correct) labels.
     * @param {any} y_pred - Predicted labels, as returned by a classifier.
     * @param {any} normalize
     * @returns {number}
     */
    function zeroOneLoss(y_true, y_pred, _a) {
        if (y_true === void 0) { y_true = null; }
        if (y_pred === void 0) { y_pred = null; }
        var 
        /**
         * If False, return the number of misclassifications. Otherwise, return the fraction of misclassifications.
         */
        _b = (_a === void 0 ? {
            normalize: true
        } : _a).normalize, 
        /**
         * If False, return the number of misclassifications. Otherwise, return the fraction of misclassifications.
         */
        normalize = _b === void 0 ? true : _b;
        if (normalize) {
            return 1 - accuracyScore(y_true, y_pred);
        }
        // TODO: Fix return 0; implement when normalize === false
        return 0;
    }
    exports.zeroOneLoss = zeroOneLoss;
    /**
     * A confusion matrix is a technique for summarizing the performance of a classification algorithm.
     *
     * Classification accuracy alone can be misleading if you have an unequal number of observations in each class or if you have more than two classes in your dataset.
     *
     * Calculating a confusion matrix can give you a better idea of what your classification model is getting right and what types of errors it is making.
     *
     * @example
     * import { confusion_matrix } from 'machinelearn/metrics';
     *
     * const matrix1 = confusion_matrix([1, 2, 3], [1, 2, 3]);
     * console.log(matrix1); // [ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ]
     *
     * const matrix2 = confusion_matrix(
     *   ['cat', 'ant', 'cat', 'cat', 'ant', 'bird'],
     *   ['ant', 'ant', 'cat', 'cat', 'ant', 'cat']
     * );
     * console.log(matrix2); // [ [ 1, 2, 0 ], [ 2, 0, 0 ], [ 0, 1, 0 ] ]
     *
     * @param y_true - Ground truth (correct) target values.
     * @param y_pred - Estimated targets as returned by a classifier.
     * @param labels
     */
    function confusion_matrix(y_true, y_pred, _a) {
        if (y_true === void 0) { y_true = null; }
        if (y_pred === void 0) { y_pred = null; }
        var 
        /**
         * List of labels to index the matrix. This may be used to reorder or
         * select a subset of labels. If none is given, those that appear
         * at least once in y_true or y_pred are used in sorted order.
         */
        _b = (_a === void 0 ? {
            labels: null
        } : _a).labels, 
        /**
         * List of labels to index the matrix. This may be used to reorder or
         * select a subset of labels. If none is given, those that appear
         * at least once in y_true or y_pred are used in sorted order.
         */
        labels = _b === void 0 ? null : _b;
        exports.validateInitialInputs(y_true, y_pred, labels);
        // TODO: Sorting if set by options
        // TODO: classes should be based on yTrue
        var yTrueCls = _.uniqBy(y_true, function (x) { return x; });
        var yPredCls = _.uniqBy(y_pred, function (x) { return x; });
        // TODO: Issue was raisen to fix the typing: https://github.com/josdejong/mathjs/issues/1150
        var yTrueSize = _.size(yTrueCls);
        // const placeholder: any = math.zeros(_.size(yTrueCls), _.size(yTrueCls));
        var rawZeros = __spread(tf.zeros([yTrueSize, yTrueSize]).dataSync());
        var placeholder = ops_11.reshape(rawZeros, [yTrueSize, yTrueSize]);
        // Calculating the confusion matrix
        // Looping the index for y_true
        var rowRange = _.range(0, _.size(placeholder));
        _.forEach(rowRange, function (rowIndex) {
            // Looping the index for y_pred
            var colRange = _.range(0, _.size(placeholder[rowIndex]));
            _.forEach(colRange, function (colIndex) {
                // Get current target y true and y pred
                var yTargetTrueVal = yTrueCls[rowIndex];
                var yTargetPredVal = yPredCls[colIndex];
                // Looping the range of y true for pairing
                var yTrueRange = _.range(0, _.size(y_true));
                var score = _.reduce(yTrueRange, function (sum, n) {
                    var trueVal = y_true[n];
                    var predVal = y_pred[n];
                    if (_.isEqual(trueVal, yTargetTrueVal) &&
                        _.isEqual(predVal, yTargetPredVal)) {
                        return sum + 1;
                    }
                    return sum;
                }, 0);
                // Recording the score
                placeholder[rowIndex][colIndex] = score;
            });
        });
        return placeholder;
    }
    exports.confusion_matrix = confusion_matrix;
});
define("lib/metrics/regression", ["require", "exports", "@tensorflow/tfjs", "lodash", "lib/ops/index"], function (require, exports, tf, lodash_9, ops_12) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    tf = __importStar(tf);
    /**
     * Mean absolute error regression loss
     *
     * @example
     * import { mean_absolute_error } from 'machinelearn/metrics';
     * const y_true = [3, -0.5, 2, 7]
     * const y_pred = [2.5, 0.0, 2, 8]
     * mean_absolute_error(y_true, y_pred); // 0.5
     *
     * @param y_true - Ground truth (correct) target values.
     * @param y_pred - Estimated target values.
     * @param sample_weight - Sample weights.
     */
    function mean_absolute_error(y_true, y_pred, 
    // Options
    _a) {
        if (y_true === void 0) { y_true = null; }
        if (y_pred === void 0) { y_pred = null; }
        var _b = (_a === void 0 ? {
            sample_weight: null
        } : _a).sample_weight, sample_weight = _b === void 0 ? null : _b;
        var yTrueShape = ops_12.inferShape(y_true);
        var yPredShape = ops_12.inferShape(y_pred);
        // Validation 1: empty array check
        if (yTrueShape[0] === 0 || yPredShape[0] === 0) {
            throw new TypeError("y_true " + JSON.stringify(y_true) + " and y_pred " + JSON.stringify(y_pred) + " cannot be empty");
        }
        if (sample_weight !== null) {
            var weightShape = ops_12.inferShape(sample_weight);
            if (!lodash_9.isEqual(yTrueShape, weightShape)) {
                throw new TypeError("The shape of " + JSON.stringify(weightShape) + "\n       does not match with the sample size " + JSON.stringify(yTrueShape));
            }
        }
        // Validation 2: Same shape
        if (!lodash_9.isEqual(yTrueShape, yPredShape)) {
            throw new TypeError("The shapes of y_true " + JSON.stringify(yTrueShape) + " and y_pred " + JSON.stringify(yPredShape) + " should be equal");
        }
        /**
         * Compute the weighted average along the specified axis.
         *
         * @example
         * average(tf.tensor1d([1, 2, 3, 4])).dataSync(); // [2.5]
         *
         * @param X - Array containing data to be averaged. If a is not an array, a conversion is attempted.
         * @param axis - Axis along which to average a. If None, averaging is done over the flattened array.
         * @param w - An array of weights associated with the values in a. Each value in a contributes to the average according to its associated weight. The weights array can either be 1-D (in which case its length must be the size of a along the given axis) or of the same shape as a. If weights=None, then all data in a are assumed to have a weight equal to one.
         * @ignore
         */
        var average = function (X, axis, w) {
            if (axis === void 0) { axis = 0; }
            if (w === void 0) { w = null; }
            if (w !== null) {
                var wgt = tf.tensor1d(w);
                var scl = wgt.sum(axis);
                return tf
                    .mul(X, wgt)
                    .sum(axis)
                    .div(scl);
            }
            else {
                var sample_size = X.size;
                return tf.div(tf.sum(X), tf.scalar(sample_size));
            }
        };
        var output_errors = tf.abs(tf.sub(y_true, y_pred));
        var avg_errors = average(output_errors, 0, sample_weight);
        return average(avg_errors).dataSync()[0];
    }
    exports.mean_absolute_error = mean_absolute_error;
    /**
     * Mean squared error regression loss
     *
     * @example
     * import { mean_squared_error } from 'machinelearn/metrics';
     *
     * const y_true = [3, -0.5, 2, 7];
     * const y_pred = [2.5, 0.0, 2, 8];
     *
     * console.log(mean_squared_error(y_true, y_pred));
     * // result: 0.375
     *
     * const y_true1 = [[0.5, 1], [-1, 1], [7, -6]];
     * const y_pred1 = [[0, 2], [-1, 2], [8, -5]];
     *
     * console.log(mean_squared_error(y_true1, y_pred1));
     * // result: 0.7083333134651184
     *
     * @param y_true - Ground truth (correct) target values.
     * @param y_pred - Estimated target values.
     */
    function mean_squared_error(y_true, y_pred, 
    // Options
    _a) {
        if (y_true === void 0) { y_true = null; }
        if (y_pred === void 0) { y_pred = null; }
        var 
        /**
         * Sample weights.
         */
        _b = (_a === void 0 ? {
            sample_weight: null
        } : _a).sample_weight, 
        /**
         * Sample weights.
         */
        sample_weight = _b === void 0 ? null : _b;
        var yTrueShape = ops_12.inferShape(y_true);
        var yPredShape = ops_12.inferShape(y_pred);
        // Validation 1: empty array check
        if (yTrueShape[0] === 0 || yPredShape[0] === 0) {
            throw new TypeError("y_true " + JSON.stringify(y_true) + " and y_pred " + JSON.stringify(y_pred) + " cannot be empty");
        }
        // Validation 2: Same shape
        if (!lodash_9.isEqual(yTrueShape, yPredShape)) {
            throw new TypeError("Shapes of y_true " + JSON.stringify(yTrueShape) + " and y_pred " + JSON.stringify(yPredShape) + " should be equal");
        }
        return tf.losses
            .meanSquaredError(y_true, y_pred, sample_weight)
            .dataSync()[0];
    }
    exports.mean_squared_error = mean_squared_error;
});
define("lib/metrics/index", ["require", "exports", "lib/metrics/classification", "lib/metrics/regression"], function (require, exports, classification_1, regression_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.accuracyScore = classification_1.accuracyScore;
    exports.confusion_matrix = classification_1.confusion_matrix;
    exports.zeroOneLoss = classification_1.zeroOneLoss;
    exports.mean_absolute_error = regression_1.mean_absolute_error;
    exports.mean_squared_error = regression_1.mean_squared_error;
});
define("lib/model_selection/_split", ["require", "exports", "lodash", "random-js", "lib/ops/index"], function (require, exports, _, Random, ops_13) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    _ = __importStar(_);
    Random = __importStar(Random);
    /**
     * K-Folds cross-validator
     *
     * Provides train/test indices to split data in train/test sets. Split dataset into k consecutive folds (without shuffling by default).
     *
     * Each fold is then used once as a validation while the k - 1 remaining folds form the training set.
     *
     * @example
     * import { KFold } from 'machinelearn/model_selection';
     *
     * const kFold = new KFold({ k: 5 });
     * const X1 = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
     * console.log(kFold.split(X1, X1));
     *
     * /* [ { trainIndex: [ 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19 ],
     * *  testIndex: [ 0, 1, 2, 3 ] },
     * * { trainIndex: [ 0, 1, 2, 3, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19 ],
     * *  testIndex: [ 4, 5, 6, 7 ] },
     * * { trainIndex: [ 0, 1, 2, 3, 4, 5, 6, 7, 12, 13, 14, 15, 16, 17, 18, 19 ],
     * *  testIndex: [ 8, 9, 10, 11 ] },
     * * { trainIndex: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 16, 17, 18, 19 ],
     * *  testIndex: [ 12, 13, 14, 15 ] },
     * * { trainIndex: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 ],
     * *  testIndex: [ 16, 17, 18, 19 ] } ]
     *
     */
    var KFold = /** @class */ (function () {
        /**
         *
         * @param {any} k - Number of folds. Must be at least 2.
         * @param {any} shuffle - Whether to shuffle the data before splitting into batches.
         */
        function KFold(_a) {
            var _b = _a.k, k = _b === void 0 ? 2 : _b, _c = _a.shuffle, shuffle = _c === void 0 ? false : _c;
            if (k < 2) {
                throw Error('Number of folds cannot be less than 2');
            }
            this.k = k;
            this.shuffle = shuffle;
        }
        /**
         *
         * @param X - Training data, where n_samples is the number of samples and n_features is the number of features.
         * @param y - The target variable for supervised learning problems.
         * @returns {any[]}
         */
        KFold.prototype.split = function (X, y) {
            var _this = this;
            if (X === void 0) { X = null; }
            if (y === void 0) { y = null; }
            var xShape = ops_13.inferShape(X);
            var yShape = ops_13.inferShape(y);
            if (xShape.length > 0 && yShape.length > 0 && xShape[0] !== yShape[0]) {
                throw Error('X and y must have an identical size');
            }
            if (this.k > X.length || this.k > y.length) {
                throw Error("Cannot have number of splits k=" + this.k + " greater than the number of samples: " + _.size(X));
            }
            var binSize = _.floor(_.size(X) / this.k);
            var xRange = _.range(0, _.size(X));
            var splitRange = _.range(0, this.k);
            return _.reduce(splitRange, function (sum, index) {
                // Calculate binSizeRange according to k value. e.g. 0 -> [0,1]. 1 -> [2, 3].
                var binSizeRange = _.range(index * binSize, index * binSize + binSize);
                // X index range used for test set. It can either be shuffled e.g. [ 2, 0, 1 ] or raw value [ 0, 1, 2 ]
                var testXRange = _.flowRight(function (x) { return (_this.shuffle ? _.shuffle(x) : x); }, function () { return _.clone(xRange); })();
                // Getting testIndex according to binSizeRange from testXRange
                var testIndex = _.reduce(binSizeRange, function (xIndeces, i) {
                    return _.concat(xIndeces, [testXRange[i]]);
                }, []);
                var trainIndex = _.pullAll(_.clone(xRange), testIndex);
                return _.concat(sum, [{ trainIndex: trainIndex, testIndex: testIndex }]);
            }, []);
        };
        return KFold;
    }());
    exports.KFold = KFold;
    /**
     * Split arrays or matrices into random train and test subsets
     *
     * @example
     * import { train_test_split } from 'machinelearn/model_selection';
     *
     * const X = [[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]];
     * const y = [0, 1, 2, 3, 4];
     *
     * train_test_split(X, y, {
     *   test_size: 0.33,
     *   train_size: 0.67,
     *   random_state: 42
     * });
     *
     * /*
     * * { xTest: [ [ 0, 1 ], [ 8, 9 ] ],
     * *  xTrain: [ [ 4, 5 ], [ 6, 7 ], [ 2, 3 ] ],
     * *  yTest: [ 0, 4 ],
     * *  yTrain: [ 2, 3, 1 ] }
     *
     * @param {any} X - input data
     * @param {any} y - target data
     * @param {number} test_size - size of the returning test set
     * @param {number} train_size - size of the returning training set
     * @param {number} random_state - state used to shuffle data
     * @param {boolean} clone - to clone the original data
     * @returns {{xTest: any[]; xTrain: any[]; yTest: any[]; yTrain: any[]}}
     */
    function train_test_split(X, y, _a) {
        if (X === void 0) { X = null; }
        if (y === void 0) { y = null; }
        var _b = _a === void 0 ? {
            // Default if nothing is given
            test_size: 0.25,
            train_size: 0.75,
            random_state: 0,
            clone: true
        } : _a, 
        // Arguments and their default values
        _c = _b.test_size, 
        // Arguments and their default values
        test_size = _c === void 0 ? 0.25 : _c, _d = _b.train_size, train_size = _d === void 0 ? 0.75 : _d, _e = _b.random_state, random_state = _e === void 0 ? 0 : _e, _f = _b.clone, clone = _f === void 0 ? true : _f;
        var _X = clone ? _.cloneDeep(X) : X;
        var _y = clone ? _.cloneDeep(y) : y;
        // Checking if either of these params is not array
        if (!_.isArray(_X) || !_.isArray(_y) || _X.length === 0 || _y.length === 0) {
            throw Error('X and y must be array and cannot be empty');
        }
        ops_13.validateFitInputs(_X, _y);
        // Training dataset size accoding to X
        var trainSizeLength = _.round(train_size * _X.length);
        var testSizeLength = _.round(test_size * _X.length);
        if (_.round(test_size + train_size) !== 1) {
            throw Error('Sum of test_size and train_size does not equal 1');
        }
        // Initiate Random engine
        var randomEngine = Random.engines.mt19937();
        randomEngine.seed(random_state);
        // split
        var xTrain = [];
        var yTrain = [];
        var xTest = [];
        var yTest = [];
        // Getting X_train and y_train
        while (xTrain.length < trainSizeLength && yTrain.length < trainSizeLength) {
            var index = Random.integer(0, X.length - 1)(randomEngine);
            // X_train
            xTrain.push(_X[index]);
            _X.splice(index, 1);
            // y_train
            yTrain.push(_y[index]);
            _y.splice(index, 1);
        }
        while (xTest.length < testSizeLength) {
            var index = Random.integer(0, _X.length - 1)(randomEngine);
            // X test
            xTest.push(_X[index]);
            _X.splice(index, 1);
            // y train
            yTest.push(_y[index]);
            _y.splice(index, 1);
        }
        // Filter return results
        var clean = function (items) {
            return _.filter(items, function (item) { return !_.isUndefined(item); });
        };
        return {
            xTest: clean(xTest),
            xTrain: clean(xTrain),
            yTest: clean(yTest),
            yTrain: clean(yTrain)
        };
    }
    exports.train_test_split = train_test_split;
});
define("lib/model_selection/index", ["require", "exports", "lib/model_selection/_split"], function (require, exports, _split_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.KFold = _split_1.KFold;
    exports.train_test_split = _split_1.train_test_split;
});
/* tslint:disable */
/*
 * Original code from:
 *
 * k-d Tree JavaScript - V 1.01
 *
 * https://github.com/ubilabs/kd-tree-javascript
 *
 * @author Mircea Pricop <pricop@ubilabs.net>, 2012
 * @author Martin Kleppe <kleppe@ubilabs.net>, 2012
 * @author Ubilabs http://ubilabs.net, 2012
 * @license MIT License <http://www.opensource.org/licenses/mit-license.php>
 */
define("lib/neighbors/KDTree", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * @ignore
     */
    var Node = /** @class */ (function () {
        function Node(obj, dimension, parent) {
            this.obj = null;
            this.left = null;
            this.right = null;
            this.parent = null;
            this.dimension = null;
            this.obj = obj;
            this.left = null;
            this.right = null;
            this.parent = parent;
            this.dimension = dimension;
        }
        return Node;
    }());
    exports.Node = Node;
    /**
     * @ignore
     */
    var KDTree = /** @class */ (function () {
        function KDTree(points, metric) {
            this.dimensions = null;
            this.root = null;
            this.metric = null;
            // If points is not an array, assume we're loading a pre-built tree
            if (!Array.isArray(points)) {
                this.dimensions = points.dimensions;
                this.root = points;
                restoreParent(this.root);
            }
            else {
                this.dimensions = new Array(points[0].length);
                for (var i = 0; i < this.dimensions.length; i++) {
                    this.dimensions[i] = i;
                }
                this.root = buildTree(points, 0, null, this.dimensions);
            }
            this.metric = metric;
        }
        // Convert to a JSON serializable structure; this just requires removing
        // the `parent` property
        KDTree.prototype.toJSON = function () {
            var result = toJSONImpl(this.root);
            // Renamed dimensions to dimension
            result.dimension = this.dimensions;
            return result;
        };
        KDTree.prototype.nearest = function (point, maxNodes, maxDistance) {
            var metric = this.metric;
            var dimensions = this.dimensions;
            var i;
            var bestNodes = new BinaryHeap(function (e) { return -e[1]; });
            function nearestSearch(node) {
                var dimension = dimensions[node.dimension];
                var ownDistance = metric(point, node.obj);
                var linearPoint = {};
                var bestChild, linearDistance, otherChild, i;
                function saveNode(node, distance) {
                    bestNodes.push([node, distance]);
                    if (bestNodes.size() > maxNodes) {
                        bestNodes.pop();
                    }
                }
                for (i = 0; i < dimensions.length; i += 1) {
                    if (i === node.dimension) {
                        linearPoint[dimensions[i]] = point[dimensions[i]];
                    }
                    else {
                        linearPoint[dimensions[i]] = node.obj[dimensions[i]];
                    }
                }
                linearDistance = metric(linearPoint, node.obj);
                if (node.right === null && node.left === null) {
                    if (bestNodes.size() < maxNodes || ownDistance < bestNodes.peek()[1]) {
                        saveNode(node, ownDistance);
                    }
                    return;
                }
                if (node.right === null) {
                    bestChild = node.left;
                }
                else if (node.left === null) {
                    bestChild = node.right;
                }
                else {
                    if (point[dimension] < node.obj[dimension]) {
                        bestChild = node.left;
                    }
                    else {
                        bestChild = node.right;
                    }
                }
                nearestSearch(bestChild);
                if (bestNodes.size() < maxNodes || ownDistance < bestNodes.peek()[1]) {
                    saveNode(node, ownDistance);
                }
                if (bestNodes.size() < maxNodes || Math.abs(linearDistance) < bestNodes.peek()[1]) {
                    if (bestChild === node.left) {
                        otherChild = node.right;
                    }
                    else {
                        otherChild = node.left;
                    }
                    if (otherChild !== null) {
                        nearestSearch(otherChild);
                    }
                }
            }
            if (maxDistance) {
                for (i = 0; i < maxNodes; i += 1) {
                    bestNodes.push([null, maxDistance]);
                }
            }
            if (this.root) {
                nearestSearch(this.root);
            }
            var result = [];
            for (i = 0; i < Math.min(maxNodes, bestNodes.content.length); i += 1) {
                if (bestNodes.content[i][0]) {
                    result.push([bestNodes.content[i][0].obj, bestNodes.content[i][1]]);
                }
            }
            return result;
        };
        return KDTree;
    }());
    exports.default = KDTree;
    /**
     *
     * @param src
     * @returns {Node}
     * @ignore
     */
    function toJSONImpl(src) {
        var dest = new Node(src.obj, src.dimension, null);
        if (src.left)
            dest.left = toJSONImpl(src.left);
        if (src.right)
            dest.right = toJSONImpl(src.right);
        return dest;
    }
    /**
     *
     * @param points
     * @param depth
     * @param parent
     * @param dimensions
     * @returns {any}
     * @ignore
     */
    function buildTree(points, depth, parent, dimensions) {
        var dim = depth % dimensions.length;
        if (points.length === 0) {
            return null;
        }
        if (points.length === 1) {
            return new Node(points[0], dim, parent);
        }
        points.sort(function (a, b) { return a[dimensions[dim]] - b[dimensions[dim]]; });
        var median = Math.floor(points.length / 2);
        var node = new Node(points[median], dim, parent);
        node.left = buildTree(points.slice(0, median), depth + 1, node, dimensions);
        node.right = buildTree(points.slice(median + 1), depth + 1, node, dimensions);
        return node;
    }
    /**
     * @param root
     * @ignore
     */
    function restoreParent(root) {
        if (root.left) {
            root.left.parent = root;
            restoreParent(root.left);
        }
        if (root.right) {
            root.right.parent = root;
            restoreParent(root.right);
        }
    }
    // Binary heap implementation from:
    // http://eloquentjavascript.net/appendix2.html
    /**
     * @ignore
     */
    var BinaryHeap = /** @class */ (function () {
        function BinaryHeap(scoreFunction) {
            this.content = [];
            this.content = [];
            this.scoreFunction = scoreFunction;
        }
        BinaryHeap.prototype.push = function (element) {
            // Add the new element to the end of the array.
            this.content.push(element);
            // Allow it to bubble up.
            this.bubbleUp(this.content.length - 1);
        };
        BinaryHeap.prototype.pop = function () {
            // Store the first element so we can return it later.
            var result = this.content[0];
            // Get the element at the end of the array.
            var end = this.content.pop();
            // If there are any elements left, put the end element at the
            // start, and let it sink down.
            if (this.content.length > 0) {
                this.content[0] = end;
                this.sinkDown(0);
            }
            return result;
        };
        BinaryHeap.prototype.peek = function () {
            return this.content[0];
        };
        BinaryHeap.prototype.size = function () {
            return this.content.length;
        };
        BinaryHeap.prototype.bubbleUp = function (n) {
            // Fetch the element that has to be moved.
            var element = this.content[n];
            // When at 0, an element can not go up any further.
            while (n > 0) {
                // Compute the parent element's index, and fetch it.
                var parentN = Math.floor((n + 1) / 2) - 1;
                var parent_1 = this.content[parentN];
                // Swap the elements if the parent is greater.
                if (this.scoreFunction(element) < this.scoreFunction(parent_1)) {
                    this.content[parentN] = element;
                    this.content[n] = parent_1;
                    // Update 'n' to continue at the new position.
                    n = parentN;
                }
                else {
                    // Found a parent that is less, no need to move it further.
                    break;
                }
            }
        };
        BinaryHeap.prototype.sinkDown = function (n) {
            // Look up the target element and its score.
            var length = this.content.length;
            var element = this.content[n];
            var elemScore = this.scoreFunction(element);
            while (true) {
                // Compute the indices of the child elements.
                var child2N = (n + 1) * 2;
                var child1N = child2N - 1;
                // This is used to store the new position of the element,
                // if any.
                var swap = null;
                // If the first child exists (is inside the array)...
                if (child1N < length) {
                    // Look it up and compute its score.
                    var child1 = this.content[child1N];
                    var child1Score = this.scoreFunction(child1);
                    // If the score is less than our element's, we need to swap.
                    if (child1Score < elemScore) {
                        swap = child1N;
                    }
                }
                // Do the same checks for the other child.
                if (child2N < length) {
                    var child2 = this.content[child2N];
                    var child2Score = this.scoreFunction(child2);
                    if (child2Score < (swap === null ? elemScore : child1Score)) {
                        swap = child2N;
                    }
                }
                // If the element needs to be moved, swap it, and continue.
                if (swap !== null) {
                    this.content[n] = this.content[swap];
                    this.content[swap] = element;
                    n = swap;
                }
                else {
                    // Otherwise, we are done.
                    break;
                }
            }
        };
        return BinaryHeap;
    }());
});
define("lib/neighbors/classification", ["require", "exports", "lodash", "lib/ops/index", "lib/utils/MathExtra", "lib/neighbors/KDTree"], function (require, exports, lodash_10, ops_14, MathExtra_5, KDTree_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    MathExtra_5 = __importDefault(MathExtra_5);
    KDTree_1 = __importDefault(KDTree_1);
    var euclideanDistance = MathExtra_5.default.euclideanDistance, manhattanDistance = MathExtra_5.default.manhattanDistance;
    var DIST_EUC = 'euclidean';
    var DIST_MAN = 'manhattan';
    var TYPE_KD = 'kdtree';
    /**
     * Classifier implementing the k-nearest neighbors vote.
     *
     * @example
     * const knn = new KNeighborsClassifier();
     * const X = [[0, 0, 0], [0, 1, 1], [1, 1, 0], [2, 2, 2], [1, 2, 2], [2, 1, 2]];
     * const y = [0, 0, 0, 1, 1, 1];
     * knn.fit(X ,y);
     * console.log(knn.predict([1, 2])); // predicts 1
     */
    var KNeighborsClassifier = /** @class */ (function () {
        /**
         * @param {string} distance - Choice of distance function, should choose between euclidean | manhattan
         * @param {number} k - Number of neighbors to classify
         * @param {string} type - Type of algorithm to use, choose between kdtree(default) | balltree | simple
         */
        function KNeighborsClassifier(_a) {
            var _b = _a === void 0 ? {
                // Default value on empty constructor
                distance: DIST_EUC,
                k: 0,
                type: TYPE_KD
            } : _a, 
            // Each object param default value
            _c = _b.distance, 
            // Each object param default value
            distance = _c === void 0 ? DIST_EUC : _c, _d = _b.k, k = _d === void 0 ? 0 : _d, _e = _b.type, type = _e === void 0 ? TYPE_KD : _e;
            this.type = null;
            this.tree = null;
            this.k = null;
            this.classes = null;
            this.distance = null;
            var options = {
                distance: distance,
                k: k,
                type: type
            };
            // Handling distance
            if (options.distance === DIST_EUC) {
                this.distance = euclideanDistance;
            }
            else if (options.distance === DIST_MAN) {
                this.distance = manhattanDistance;
            }
            else {
                throw new Error("Unrecognised type of distance " + options.distance + " was received");
            }
            this.k = options.k;
            this.type = options.type;
        }
        /**
         * Train the classifier with input and output data
         * @param {any} X - Training data.
         * @param {any} y - Target data.
         */
        KNeighborsClassifier.prototype.fit = function (X, y) {
            ops_14.validateFitInputs(X, y);
            // Getting the classes from y
            var classes = lodash_10.uniqBy(y, function (c) { return c; });
            // Setting k; if it's null, use the class length
            var k = this.k ? this.k : classes.length + 1;
            //  Constructing the points placeholder
            var points = new Array(X.length);
            for (var i = 0; i < points.length; ++i) {
                points[i] = X[i].slice();
            }
            for (var i = 0; i < y.length; ++i) {
                points[i].push(y[i]);
            }
            // Building a tree or algo according to this.type
            if (this.type === TYPE_KD) {
                this.tree = new KDTree_1.default(points, this.distance);
            }
            this.k = k;
            this.classes = classes;
        };
        /**
         * Return the model's state as a JSON object
         * @return {object} JSON KNN model.
         */
        KNeighborsClassifier.prototype.toJSON = function () {
            return {
                classes: this.classes,
                distance: this.distance,
                k: this.k,
                tree: this.tree,
                type: this.type
            };
        };
        /**
         * Restores the model from a JSON checkpoint
         * @param {any} classes
         * @param {any} distance
         * @param {any} k
         * @param {any} tree
         * @param {any} type
         */
        KNeighborsClassifier.prototype.fromJSON = function (_a) {
            var _b = _a.classes, classes = _b === void 0 ? null : _b, _c = _a.distance, distance = _c === void 0 ? null : _c, _d = _a.k, k = _d === void 0 ? null : _d, _e = _a.tree, tree = _e === void 0 ? null : _e, _f = _a.type, type = _f === void 0 ? null : _f;
            if (!classes || !distance || !k || !tree || !type) {
                throw new Error('You must provide classes, distance, k, tree and type to restore the KNearestNeighbor');
            }
            this.classes = classes;
            this.distance = distance;
            this.k = k;
            this.tree = tree;
            this.type = type;
        };
        /**
         * Predict single value from a list of data
         * @param {Array} X - Prediction data.
         * @returns number
         */
        KNeighborsClassifier.prototype.predict = function (X) {
            var _this = this;
            var shape = ops_14.inferShape(X);
            if (shape.length === 1) {
                return this.getSinglePred(X);
            }
            else if (shape.length === 2) {
                return lodash_10.map(X, function (currentItem) { return _this.getSinglePred(currentItem); });
            }
            else {
                throw new TypeError('The dataset is neither an array or a matrix');
            }
        };
        /**
         * Runs a single prediction against an array based on kdTree or balltree or
         * simple algo
         * @param array
         * @returns {{}}
         */
        KNeighborsClassifier.prototype.getSinglePred = function (array) {
            if (this.tree) {
                return this.getTreeBasedPrediction(array);
            }
            else {
                // Run the simple KNN algorithm
                return 0;
            }
        };
        /**
         * Get the class with the max point
         * @param current
         * @returns {{}}
         * @ignore
         */
        KNeighborsClassifier.prototype.getTreeBasedPrediction = function (current) {
            var nearestPoints = this.tree.nearest(current, this.k);
            var pointsPerClass = {};
            var predictedClass = -1;
            var maxPoints = -1;
            var lastElement = nearestPoints[0][0].length - 1;
            // Initialising the points placeholder per class
            for (var j = 0; j < this.classes.length; j++) {
                pointsPerClass[this.classes[j]] = 0;
            }
            // Voting the max value
            for (var i = 0; i < nearestPoints.length; ++i) {
                var currentClass = nearestPoints[i][0][lastElement];
                var currentPoints = ++pointsPerClass[currentClass];
                if (currentPoints > maxPoints) {
                    predictedClass = currentClass;
                    maxPoints = currentPoints;
                }
            }
            return predictedClass;
        };
        return KNeighborsClassifier;
    }());
    exports.KNeighborsClassifier = KNeighborsClassifier;
});
define("lib/neighbors/index", ["require", "exports", "lib/neighbors/classification"], function (require, exports, classification_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.KNeighborsClassifier = classification_2.KNeighborsClassifier;
});
define("lib/svm/classes", ["require", "exports", "libsvm-js", "lodash", "lib/ops/index"], function (require, exports, libsvm_js_1, _, ops_15) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    libsvm_js_1 = __importDefault(libsvm_js_1);
    _ = __importStar(_);
    /**
     * BaseSVM class used by all parent SVM classes that are based on libsvm
     */
    var BaseSVM = /** @class */ (function () {
        function BaseSVM(options) {
            this.options = {
                cacheSize: _.get(options, 'cacheSize', 100),
                coef0: _.get(options, 'coef0', 0),
                cost: _.get(options, 'cost', 1),
                degree: _.get(options, 'degree', 3),
                epsilon: _.get(options, 'epsilon', 0.1),
                gamma: _.get(options, 'gamma', null),
                kernel: _.get(options, 'kernel', 'RBF'),
                nu: _.get(options, 'nu', 0.5),
                probabilityEstimates: _.get(options, 'probabilityEstimates', false),
                quiet: _.get(options, 'quiet', true),
                shrinking: _.get(options, 'shrinking', true),
                tolerance: _.get(options, 'tolerance', 0.001),
                weight: _.get(options, 'weight', null)
            };
        }
        /**
         * Fit the model according to the given training data.
         * @param {number[][]} X
         * @param {number[]} y
         * @returns {Promise<void>}
         */
        BaseSVM.prototype.fit = function (X, y) {
            return __awaiter(this, void 0, void 0, function () {
                var SVM, options;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            ops_15.validateFitInputs(X, y);
                            if (!this.type) {
                                throw new Error("SVM type is unspecified " + this.type);
                            }
                            return [4 /*yield*/, this.loadSVM()];
                        case 1:
                            SVM = _a.sent();
                            options = this.processOptions(SVM, this.options, this.type, this.options.kernel);
                            this.svm = new SVM(options);
                            this.svm.train(X, y);
                            return [2 /*return*/];
                    }
                });
            });
        };
        /**
         * Predict using the linear model
         * @param {number[][]} X
         * @returns {number[]}
         */
        BaseSVM.prototype.predict = function (X) {
            ops_15.validateMatrix2D(X);
            return this.svm.predict(X);
        };
        /**
         * Predict the label of one sample.
         * @param {number[]} X
         * @returns {number}
         */
        BaseSVM.prototype.predictOne = function (X) {
            ops_15.validateMatrix1D(X);
            return this.svm.predictOne(X);
        };
        /**
         * Saves the current SVM as a JSON object
         * @returns {{svm: any; type: Type; options: SVMOptions}}
         */
        BaseSVM.prototype.toJSON = function () {
            return {
                svm: this.svm,
                type: this.type,
                options: this.options
            };
        };
        /**
         * Restores the model from a JSON checkpoint
         * @param {any} svm
         * @param {any} type
         * @param {any} options
         */
        BaseSVM.prototype.fromJSON = function (_a) {
            var _b = _a.svm, svm = _b === void 0 ? null : _b, _c = _a.type, type = _c === void 0 ? null : _c, _d = _a.options, options = _d === void 0 ? null : _d;
            if (!svm || !type || !options) {
                throw new Error('You must provide svm, type and options to restore the model');
            }
            this.svm = svm;
            this.type = type;
            this.options = options;
        };
        /**
         * Load SVM object by resolving the default promise
         * @returns {Promise<any>}
         */
        BaseSVM.prototype.loadSVM = function () {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    return [2 /*return*/, libsvm_js_1.default];
                });
            });
        };
        /**
         * Get Kernel name type using string Kernel name
         * @param SVM
         * @param {string} name
         * @returns {number}
         */
        BaseSVM.prototype.getKernel = function (SVM, name) {
            return _.get(SVM.KERNEL_TYPES, name);
        };
        /**
         * Get Kernel type using string type name
         * @param SVM
         * @param {string} name
         * @returns {number}
         */
        BaseSVM.prototype.getType = function (SVM, name) {
            return _.get(SVM.SVM_TYPES, name);
        };
        /**
         * Get a consolidated options including type and Kernel
         * @param SVM
         * @param {Options} options
         * @param {Type} type
         * @param {Kernel} kernel
         * @returns {Object}
         */
        BaseSVM.prototype.processOptions = function (SVM, options, type, kernel) {
            var _this = this;
            return _.flowRight(function (opts) {
                var foundType = _this.getType(SVM, type);
                return _.set(opts, 'type', foundType);
            }, function (opts) {
                var foundKernal = _this.getKernel(SVM, kernel);
                return _.set(opts, 'kernel', foundKernal);
            })(options);
        };
        return BaseSVM;
    }());
    exports.BaseSVM = BaseSVM;
    /**
     * C-Support Vector Classification.
     *
     * The implementation is based on libsvm. The fit time complexity is more than
     * quadratic with the number of samples which makes it hard to scale to dataset
     * with more than a couple of 10000 samples.
     *
     * The multiclass support is handled according to a one-vs-one scheme.
     *
     * For details on the precise mathematical formulation of the provided kernel
     * functions and how gamma, coef0 and degree affect each other, see the corresponding
     * section in the narrative documentation: Kernel functions.
     */
    var SVC = /** @class */ (function (_super) {
        __extends(SVC, _super);
        function SVC(options) {
            var _this = _super.call(this, options) || this;
            _this.type = 'C_SVC';
            return _this;
        }
        return SVC;
    }(BaseSVM));
    exports.SVC = SVC;
    /**
     * Linear Support Vector Regression.
     *
     * Similar to SVR with parameter kernel=linear, but implemented in terms of
     * liblinear rather than libsvm, so it has more flexibility in the choice of
     * penalties and loss functions and should scale better to large numbers of samples.
     *
     * This class supports both dense and sparse input.
     */
    var SVR = /** @class */ (function (_super) {
        __extends(SVR, _super);
        function SVR(options) {
            var _this = _super.call(this, options) || this;
            _this.type = 'EPSILON_SVR';
            return _this;
        }
        return SVR;
    }(BaseSVM));
    exports.SVR = SVR;
    /**
     * Unsupervised Outlier Detection.
     *
     * Estimate the support of a high-dimensional distribution.
     *
     * The implementation is based on libsvm.
     */
    var OneClassSVM = /** @class */ (function (_super) {
        __extends(OneClassSVM, _super);
        function OneClassSVM(options) {
            var _this = _super.call(this, options) || this;
            _this.type = 'ONE_CLASS';
            return _this;
        }
        return OneClassSVM;
    }(BaseSVM));
    exports.OneClassSVM = OneClassSVM;
    /**
     * Nu-Support Vector Classification.
     *
     * Similar to SVC but uses a parameter to control the number of support vectors.
     *
     * The implementation is based on libsvm.
     */
    var NuSVC = /** @class */ (function (_super) {
        __extends(NuSVC, _super);
        function NuSVC(options) {
            var _this = _super.call(this, options) || this;
            _this.type = 'NU_SVC';
            return _this;
        }
        return NuSVC;
    }(BaseSVM));
    exports.NuSVC = NuSVC;
    /**
     * Nu Support Vector Regression.
     *
     * Similar to NuSVC, for regression, uses a parameter nu to control the number
     * of support vectors. However, unlike NuSVC, where nu replaces C, here nu
     * replaces the parameter epsilon of epsilon-SVR.
     *
     * The implementation is based on libsvm.
     */
    var NuSVR = /** @class */ (function (_super) {
        __extends(NuSVR, _super);
        function NuSVR(options) {
            var _this = _super.call(this, options) || this;
            _this.type = 'NU_SVR';
            return _this;
        }
        return NuSVR;
    }(BaseSVM));
    exports.NuSVR = NuSVR;
});
define("lib/svm/index", ["require", "exports", "lib/svm/classes"], function (require, exports, classes_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BaseSVM = classes_1.BaseSVM;
    exports.NuSVC = classes_1.NuSVC;
    exports.NuSVR = classes_1.NuSVR;
    exports.OneClassSVM = classes_1.OneClassSVM;
    exports.SVC = classes_1.SVC;
    exports.SVR = classes_1.SVR;
});
define("lib/index", ["require", "exports", "lib/cluster/index", "lib/datasets/index", "lib/decomposition/index", "lib/ensemble/index", "lib/feature_extraction/index", "lib/linear_model/index", "lib/metrics/index", "lib/model_selection/index", "lib/neighbors/index", "lib/preprocessing/index", "lib/svm/index", "lib/tree/index"], function (require, exports, cluster, datasets, decomposition, ensemble, feature_extraction, linear_model, metrics, model_selection, neighbors, preprocessing, svm, tree) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    cluster = __importStar(cluster);
    datasets = __importStar(datasets);
    decomposition = __importStar(decomposition);
    ensemble = __importStar(ensemble);
    feature_extraction = __importStar(feature_extraction);
    linear_model = __importStar(linear_model);
    metrics = __importStar(metrics);
    model_selection = __importStar(model_selection);
    neighbors = __importStar(neighbors);
    preprocessing = __importStar(preprocessing);
    svm = __importStar(svm);
    tree = __importStar(tree);
    exports.cluster = cluster;
    exports.datasets = datasets;
    exports.decomposition = decomposition;
    exports.ensemble = ensemble;
    exports.feature_extraction = feature_extraction;
    exports.linear_model = linear_model;
    exports.metrics = metrics;
    exports.model_selection = model_selection;
    exports.neighbors = neighbors;
    exports.preprocessing = preprocessing;
    exports.svm = svm;
    exports.tree = tree;
});
define("lib/cluster/index.repl", ["require", "exports", "lib/cluster/k_means"], function (require, exports, k_means_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var kmean = new k_means_2.KMeans({ k: 2 });
    var clusters = kmean.fit([[1, 2], [1, 4], [1, 0], [4, 2], [4, 4], [4, 0]]);
    console.log('checking clusters', clusters);
    var predResult = kmean.predict([[0, 0], [4, 4]]);
    console.log(predResult);
});
/* tslint:disable */
define("lib/datasets/index.repl", ["require", "exports", "lib/datasets/Iris", "lib/datasets/Boston"], function (require, exports, Iris_2, Boston_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var irisData = new Iris_2.Iris();
    irisData.load().then(function (data) {
        var description = data.description;
        console.log('checking desc', description);
    });
    var bostonData = new Boston_2.Boston();
    bostonData.load().then(function (data) {
        console.log(data);
    });
});
define("lib/decomposition/index.repl", ["require", "exports", "lib/decomposition/pca"], function (require, exports, pca_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var pca = new pca_2.PCA();
    var X = [[1, 2], [3, 4], [5, 6]];
    pca.fit(X);
    console.log('components', pca.components);
    console.log('explained var', pca.explained_variance);
});
define("lib/ensemble/index.repl", ["require", "exports", "lib/ensemble/forest", "lib/datasets/Iris"], function (require, exports, forest_2, Iris_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    (function () {
        return __awaiter(this, void 0, void 0, function () {
            var irisDataset, _a, data, targets, X, y, randomForest, rf2;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        irisDataset = new Iris_3.Iris();
                        return [4 /*yield*/, irisDataset.load()];
                    case 1:
                        _a = _b.sent(), data = _a.data, targets = _a.targets;
                        X = [[0, 0], [1, 1], [2, 1], [1, 5], [3, 2]];
                        y = [0, 1, 2, 3, 7];
                        randomForest = new forest_2.RandomForestClassifier();
                        randomForest.fit(X, y);
                        console.log(randomForest.predict([[0, 3], [2, 1]]));
                        rf2 = new forest_2.RandomForestClassifier();
                        rf2.fit(data, targets);
                        console.log('pred', rf2.predict([[6.7, 3, 5.2, 2.3]]));
                        return [2 /*return*/];
                }
            });
        });
    })();
});
define("lib/feature_extraction/index.repl", ["require", "exports", "lib/feature_extraction/text"], function (require, exports, text_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var cv = new text_2.CountVectorizer();
    var text1 = ['deep learning ian good fellow learning jason shin shin', 'yoshua bengio'];
    var vocabCounts = cv.fit_transform(text1);
    console.log(vocabCounts);
    console.log(cv.vocabulary);
    console.log(cv.getFeatureNames());
    var newVocabCounts = cv.transform(['ian good fellow jason duuog']);
    console.log(newVocabCounts);
});
/* tslint:disable */
define("lib/linear_model/index.repl", ["require", "exports", "lib/linear_model/index", "lib/linear_model/index", "lib/linear_model/index", "lib/linear_model/index"], function (require, exports, _1, _2, _3, _4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var lr = new _1.LinearRegression();
    var X = [1, 2, 4, 3, 5];
    var y = [1, 3, 3, 2, 5];
    lr.fit(X, y);
    console.log(lr.predict([1, 2]));
    var lr2 = new _1.LinearRegression();
    lr2.fit([[1, 1], [1, 2], [2, 2], [2, 3]], [1, 1, 2, 2]);
    console.log(lr2.predict([[1, 1]]));
    var sgd = new _2.SGDClassifier();
    var X1 = [
        [7, 0.27, 0.36, 20.7, 0.045, 45, 170, 1.001, 3, 0.45, 8.8],
        [6.3, 0.3, 0.34, 1.6, 0.049, 14, 132, 0.994, 3.3, 0.49, 9.5],
        [8.1, 0.28, 0.4, 6.9, 0.05, 30, 97, 0.9951, 3.26, 0.44, 10.1],
        [7.2, 0.23, 0.32, 8.5, 0.058, 47, 186, 0.9956, 3.19, 0.4, 9.9],
        [7.2, 0.23, 0.32, 8.5, 0.058, 47, 186, 0.9956, 3.19, 0.4, 9.9]
    ];
    var y1 = [1, 2, 3, 4, 5];
    sgd.fit(X1, y1);
    var result = sgd.predict([
        [7, 0.27, 0.36, 20.7, 0.045, 45, 170, 1.001, 3, 0.45, 8.8],
        [8.1, 0.28, 0.4, 6.9, 0.05, 30, 97, 0.9951, 3.26, 0.44, 10.1],
        [7.2, 0.23, 0.32, 8.5, 0.058, 47, 186, 0.9956, 3.19, 0.4, 9.9],
        [7.2, 0.23, 0.32, 8.5, 0.058, 47, 186, 0.9956, 3.19, 0.4, 9.9]
    ]);
    console.log('checking res', result);
    var reg = new _2.SGDRegressor();
    var X2 = [[0, 0], [1, 1]];
    var y2 = [0, 1];
    reg.fit(X2, y2);
    console.log(reg.predict([[2, 2]]));
    console.log('checking res', result);
    var clf = new _2.SGDClassifier();
    var X3 = [[0, 0], [1, 1]];
    var y3 = [0, 1];
    clf.fit(X3, y3);
    console.log(clf.predict([[2, 2]]));
    var rr = new _3.Ridge({
        l2: 10
    });
    rr.fit(X1, y1);
    var result2 = rr.predict([
        [7, 0.27, 0.36, 20.7, 0.045, 45, 170, 1.001, 3, 0.45, 8.8],
        [8.1, 0.28, 0.4, 6.9, 0.05, 30, 97, 0.9951, 3.26, 0.44, 10.1],
        [7.2, 0.23, 0.32, 8.5, 0.058, 47, 186, 0.9956, 3.19, 0.4, 9.9],
        [7.2, 0.23, 0.32, 8.5, 0.058, 47, 186, 0.9956, 3.19, 0.4, 9.9]
    ]);
    console.log('checking res', result2);
    var reg1 = new _4.Lasso({ degree: 2, l1: 1 });
    reg1.fit([[0, 0], [1, 1]], [0, 1]);
    console.log('lasso', reg1.predict([[1, 1], [2, 3]]));
});
/* tslint:disable */
define("lib/metrics/index.repl", ["require", "exports", "lib/metrics/classification", "lib/metrics/regression"], function (require, exports, classification_3, regression_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var accResult = classification_3.accuracyScore([0, 1, 2, 3], [0, 2, 1, 3]);
    console.log('accuracy result ', accResult);
    var accResultNorm = classification_3.accuracyScore([0, 1, 2, 3], [0, 2, 1, 3], {
        normalize: false
    });
    console.log('accuracy result with norm false ', accResultNorm);
    var loss_zero_one_result = classification_3.zeroOneLoss([1, 2, 3, 4], [2, 2, 3, 5]);
    console.log('loss zero one ', loss_zero_one_result);
    var matrix1 = classification_3.confusion_matrix([1, 2, 3], [1, 2, 3]);
    console.log(matrix1);
    var matrix2 = classification_3.confusion_matrix([2, 0, 2, 2, 0, 1], [0, 0, 2, 2, 0, 2]);
    console.log(matrix2);
    var matrix3 = classification_3.confusion_matrix(['cat', 'ant', 'cat', 'cat', 'ant', 'bird'], ['ant', 'ant', 'cat', 'cat', 'ant', 'cat']);
    console.log(matrix3);
    var y_true = [3, -0.5, 2, 7];
    var y_pred = [2.5, 0.0, 2, 8];
    console.log(regression_2.mean_squared_error(y_true, y_pred));
    var y_true1 = [[0.5, 1], [-1, 1], [7, -6]];
    var y_pred1 = [[0, 2], [-1, 2], [8, -5]];
    console.log(regression_2.mean_squared_error(y_true1, y_pred1));
    console.log(regression_2.mean_absolute_error([3, -0.5, 2, 7], [2.5, 0.0, 2, 8]));
    console.log(regression_2.mean_absolute_error([[0.5, 1], [-1, 1], [7, -6]], [[0, 2], [-1, 2], [8, -5]], { sample_weight: [1, 2] }));
});
define("lib/model_selection/index.repl", ["require", "exports", "lib/model_selection/_split"], function (require, exports, _split_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var X = [[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]];
    var y = [0, 1, 2, 3, 4];
    console.log('original X', X);
    console.log('original y', y);
    console.log('train test split');
    console.log(_split_2.train_test_split(X, y, {
        test_size: 0.33,
        train_size: 0.67,
        random_state: 42
    }));
    var kf = new _split_2.KFold({ k: 5 });
    var X2 = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
    console.log(kf.split(X2, X2));
    var kf2 = new _split_2.KFold({ k: 10, shuffle: true });
    var X3 = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
    console.log(kf2.split(X3, X2));
});
define("lib/naive_bayes/gaussian", ["require", "exports", "@tensorflow/tfjs", "lodash", "lib/ops/index"], function (require, exports, tf, lodash_11, ops_16) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    tf = __importStar(tf);
    var SQRT_2PI = Math.sqrt(Math.PI * 2);
    /**
     * The Naive is an intuitive method that uses probabilistic of each attribute
     * being in each class to make a prediction. It uses Gaussian function to estimate
     * probability of a given class.
     *
     * @example
     * import { GaussianNB } from 'machinelearn/naive_bayes';
     *
     * const nb = new GaussianNB();
     * const X = [[1, 20], [2, 21], [3, 22], [4, 22]];
     * const y = [1, 0, 1, 0];
     * nb.fit({ X, y });
     * nb.predict({ X: [[1, 20]] }); // returns [ 1 ]
     *
     */
    var GaussianNB = /** @class */ (function () {
        function GaussianNB() {
        }
        /**
         * @param X - array-like or sparse matrix of shape = [n_samples, n_features]
         * @param y - array-like, shape = [n_samples] or [n_samples, n_outputs]
         */
        GaussianNB.prototype.fit = function (X, y) {
            if (X === void 0) { X = null; }
            if (y === void 0) { y = null; }
            ops_16.validateFitInputs(X, y);
            var _a = this.fitModel(X, y), classCategories = _a.classCategories, mean = _a.mean, variance = _a.variance;
            this.classCategories = classCategories;
            this.mean = mean;
            this.variance = variance;
        };
        /**
         * @param X - array-like, shape = [n_samples, n_features]
         */
        GaussianNB.prototype.predict = function (X) {
            var _this = this;
            if (X === void 0) { X = null; }
            ops_16.validateMatrix2D(X);
            return X.map(function (x) { return _this.singlePredict(x); });
        };
        /**
         * Restore the model from saved states
         * @param modelState
         */
        GaussianNB.prototype.fromJSON = function (_a) {
            var _b = _a.classCategories, classCategories = _b === void 0 ? null : _b, _c = _a.mean, mean = _c === void 0 ? null : _c, _d = _a.variance, variance = _d === void 0 ? null : _d;
            this.classCategories = classCategories;
            this.mean = tf.tensor2d(mean);
            this.variance = tf.tensor2d(variance);
        };
        /**
         * Save the model's states
         */
        GaussianNB.prototype.toJSON = function () {
            return {
                classCategories: this.classCategories,
                mean: ops_16.reshape(__spread(this.mean.dataSync()), this.mean.shape),
                variance: ops_16.reshape(__spread(this.variance.dataSync()), this.variance.shape)
            };
        };
        /**
         * Make a single prediction
         *
         * @param  {ReadonlyArray<number>} X- values to predict in Matrix format
         * @returns T
         */
        GaussianNB.prototype.singlePredict = function (X) {
            var matrixX = tf.tensor1d(X, 'float32');
            var numFeatures = matrixX.shape[0];
            // Comparing input and summary shapes
            var summaryLength = this.mean.shape[1];
            if (numFeatures !== summaryLength) {
                throw new Error("Prediction input " + matrixX.shape[0] + " length must be equal or less than summary length " + summaryLength);
            }
            var meanValPow = matrixX
                .sub(this.mean)
                .pow(tf.scalar(2))
                .mul(tf.scalar(-1));
            var exponent = meanValPow
                .div(this.variance.mul(tf.scalar(2)))
                .exp();
            var innerDiv = tf.scalar(SQRT_2PI).mul(this.variance.sqrt());
            var probabilityArray = tf
                .scalar(1)
                .div(innerDiv)
                .mul(exponent);
            var selectionIndex = probabilityArray
                .prod(1)
                .argMax()
                .dataSync()[0];
            return this.classCategories[selectionIndex];
        };
        /**
         * Summarise the dataset per class using "probability density function"
         *
         * @param  {Type2DMatrix<number>} X
         * @param  {ReadonlyArray<T>} y
         * @returns InterfaceFitModel
         */
        GaussianNB.prototype.fitModel = function (X, y) {
            var classCategories = __spread(new Set(y)).sort();
            // Separates X by classes specified by y argument
            var separatedByCategory = lodash_11.zip(X, y).reduce(function (groups, _a) {
                var _b = __read(_a, 2), row = _b[0], category = _b[1];
                groups[category.toString()] = groups[category.toString()] || [];
                groups[category.toString()].push(row);
                return groups;
            }, {});
            var momentStack = classCategories.map(function (category) {
                var classFeatures = tf.tensor2d(separatedByCategory[category.toString()], null, 'float32');
                return tf.moments(classFeatures, [0]);
            });
            // For every class we have a mean and variance for each feature
            var mean = tf.stack(momentStack.map(function (m) { return m.mean; }));
            var variance = tf.stack(momentStack.map(function (m) { return m.variance; }));
            // TODO check for NaN or 0 variance
            // setTimeout(() => {
            //   if ([...variance.dataSync()].some(i => i === 0)) {
            //     console.error('No variance on one of the features. Errors may result.');
            //   }
            // }, 100);
            return {
                classCategories: classCategories,
                mean: mean,
                variance: variance
            };
        };
        return GaussianNB;
    }());
    exports.GaussianNB = GaussianNB;
});
define("lib/naive_bayes/multinomial", ["require", "exports", "@tensorflow/tfjs", "lodash", "lib/ops/index"], function (require, exports, tf, lodash_12, ops_17) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    tf = __importStar(tf);
    /**
     * Multinomial naive bayes machine learning algorithm
     *
     * The Naive is an intuitive method that uses probabilistic of each attribute
     * being in each class to make a prediction. It uses multinomial function to estimate
     * probability of a given class.
     *
     * @example
     * import { MultinomialNB } from 'machinelearn/naive_bayes';
     *
     * const nb = new MultinomialNB();
     * const X = [[1, 20], [2, 21], [3, 22], [4, 22]];
     * const y = [1, 0, 1, 0];
     * nb.fit({ X, y });
     * nb.predict({ X: [[1, 20]] }); // returns [ 1 ]
     *
     */
    var MultinomialNB = /** @class */ (function () {
        function MultinomialNB() {
            this.alpha = 1;
        }
        // constructor(private readonly alpha: number = 1) {}
        /**
         * Fit date to build Gaussian Distribution summary
         *
         * @param  {Type2DMatrix<number>} X - training values
         * @param  {ReadonlyArray<T>} y - target values
         * @returns void
         */
        MultinomialNB.prototype.fit = function (X, y) {
            if (X === void 0) { X = null; }
            if (y === void 0) { y = null; }
            ops_17.validateFitInputs(X, y);
            var _a = this.fitModel(X, y), classCategories = _a.classCategories, multinomialDist = _a.multinomialDist, priorProbability = _a.priorProbability;
            this.classCategories = classCategories;
            this.multinomialDist = multinomialDist;
            this.priorProbability = priorProbability;
        };
        /**
         * Predict multiple rows
         *
         * @param  {Type2DMatrix<number>} X - values to predict in Matrix format
         * @returns T
         */
        MultinomialNB.prototype.predict = function (X) {
            var _this = this;
            if (X === void 0) { X = null; }
            ops_17.validateMatrix2D(X);
            if (lodash_12.isEmpty(this.classCategories) ||
                lodash_12.isEmpty(this.multinomialDist) ||
                lodash_12.isEmpty(this.priorProbability)) {
                throw new TypeError('You should fit the model first before running the predict!');
            }
            return X.map(function (x) { return _this.singlePredict(x); });
        };
        /**
         * Returns a model checkpoint
         *
         * @returns InterfaceFitModelAsArray
         */
        MultinomialNB.prototype.toJSON = function () {
            return {
                classCategories: Array.from(this.classCategories),
                priorProbability: Array.from(this.priorProbability.dataSync()),
                multinomialDist: ops_17.reshape(Array.from(this.multinomialDist.dataSync()), this.multinomialDist.shape)
            };
        };
        /**
         * Restore the model from states
         * @param multinomialDist - Multinomial distribution values over classes
         * @param priorProbability - Learned prior class probabilities
         * @param classCategories - List of unique class categories
         */
        MultinomialNB.prototype.fromJSON = function (_a) {
            var _b = _a === void 0 ? {
                multinomialDist: null,
                priorProbability: null,
                classCategories: null
            } : _a, _c = _b.multinomialDist, multinomialDist = _c === void 0 ? null : _c, _d = _b.priorProbability, priorProbability = _d === void 0 ? null : _d, _e = _b.classCategories, classCategories = _e === void 0 ? null : _e;
            this.classCategories = classCategories;
            this.priorProbability = tf.tensor1d(priorProbability);
            this.multinomialDist = tf.tensor2d(multinomialDist);
        };
        /**
         * Make a prediction
         *
         * @param  {ReadonlyArray<number>} predictRow
         * @returns T
         */
        MultinomialNB.prototype.singlePredict = function (predictRow) {
            var matrixX = tf.tensor1d(predictRow, 'float32');
            var numFeatures = matrixX.shape[0];
            var summaryLength = this.multinomialDist.shape[1];
            // Comparing input and summary shapes
            if (numFeatures !== summaryLength) {
                throw new Error("Prediction input " + matrixX.shape[0] + " length must be equal or less than summary length " + summaryLength);
            }
            // log is important to use different multinomial formula instead of the factorial formula
            // The multinomial naive Bayes classifier becomes a linear
            // classifier when expressed in log-space
            // const priorProbability = Math.log(1 / classCount);
            var fitProbabilites = this.multinomialDist
                .clone()
                .mul(matrixX);
            // sum(1) is summing columns
            var allProbabilities = fitProbabilites
                .sum(1)
                .add(this.priorProbability);
            var selectionIndex = allProbabilities.argMax().dataSync()[0];
            allProbabilities.dispose();
            return this.classCategories[selectionIndex];
        };
        /**
         * Summarise the dataset per class
         *
         * @param  {Type2DMatrix<number>} X - input distribution
         * @param  {ReadonlyArray<T>} y - classes to train
         */
        MultinomialNB.prototype.fitModel = function (X, y) {
            var classCounts = lodash_12.countBy(y);
            var classCategories = Array.from(new Set(y));
            var numFeatures = X[0].length;
            var separatedByCategory = lodash_12.zip(X, y).reduce(function (groups, _a) {
                var _b = __read(_a, 2), row = _b[0], category = _b[1];
                if (!(category.toString() in groups)) {
                    groups[category.toString()] = [];
                }
                groups[category.toString()].push(tf.tensor1d(row, 'float32'));
                return groups;
            }, {});
            var frequencySumByClass = tf.stack(classCategories.map(function (category) {
                return tf.addN(separatedByCategory[category.toString()]);
            }));
            var productReducedRow = Array.from(frequencySumByClass.sum(1).dataSync());
            // A class's prior may be calculated by assuming equiprobable classes
            // (i.e., priors = (number of samples in the class) / (total number of samples))
            var priorProbability = tf
                .tensor1d(classCategories.map(function (c) { return classCounts[c.toString()] / y.length; }), 'float32')
                .log();
            // log transform to use linear multinomial forumla
            var multinomialDist = frequencySumByClass
                .add(tf.scalar(this.alpha))
                .div(tf
                .tensor2d(productReducedRow, [frequencySumByClass.shape[0], 1], 'float32')
                .add(tf.scalar(numFeatures * this.alpha)))
                .log();
            return {
                classCategories: classCategories,
                multinomialDist: multinomialDist,
                priorProbability: priorProbability
            };
        };
        return MultinomialNB;
    }());
    exports.MultinomialNB = MultinomialNB;
});
define("lib/naive_bayes/index", ["require", "exports", "lib/naive_bayes/gaussian", "lib/naive_bayes/multinomial"], function (require, exports, gaussian_1, multinomial_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GaussianNB = gaussian_1.GaussianNB;
    exports.MultinomialNB = multinomial_1.MultinomialNB;
});
define("lib/naive_bayes/index.repl", ["require", "exports", "lib/naive_bayes/index"], function (require, exports, _5) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var nb = new _5.GaussianNB();
    var X = [[1, 20], [2, 21], [3, 22], [4, 22]];
    var y = [1, 0, 1, 0];
    nb.fit(X, y);
    var pred = nb.predict([[1, 20]]);
    console.log(pred);
});
define("lib/neighbors/index.repl", ["require", "exports", "lib/neighbors/classification"], function (require, exports, classification_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var knn = new classification_4.KNeighborsClassifier();
    var X = [[0, 0, 0], [0, 1, 1], [1, 1, 0], [2, 2, 2], [1, 2, 2], [2, 1, 2]];
    var y = [0, 0, 0, 1, 1, 1];
    knn.fit(X, y);
    console.log('predict', knn.predict([1, 2]));
});
define("lib/ops/index.repl", ["require", "exports", "lib/ops/tensor_ops"], function (require, exports, tensor_ops_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var result = tensor_ops_2.inferShape([[1, 2]]);
    console.log(result);
    console.log(tensor_ops_2.validateMatrixType([['z', 'z']], ['string']));
});
define("lib/preprocessing/index.repl", ["require", "exports", "lib/preprocessing/data", "lib/preprocessing/Imputer", "lib/preprocessing/data", "lib/preprocessing/label", "lib/preprocessing/data"], function (require, exports, data_2, Imputer_2, data_3, label_2, data_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // Playing around with onehotencoder
    var enc = new data_2.OneHotEncoder();
    var planetList = [
        { planet: 'mars', isGasGiant: false, value: 10 },
        { planet: 'saturn', isGasGiant: true, value: 20 },
        { planet: 'jupiter', isGasGiant: true, value: 30 }
    ];
    var encodeInfo = enc.encode(planetList, {
        dataKeys: ['value', 'isGasGiant'],
        labelKeys: ['planet']
    });
    console.log(encodeInfo.data);
    var decodedInfo = enc.decode(encodeInfo.data, encodeInfo.decoders);
    console.log(decodedInfo);
    // MinMaxScaler
    var minmaxScaler = new data_2.MinMaxScaler({ featureRange: [0, 1] });
    minmaxScaler.fit([4, 5, 6]);
    var result = minmaxScaler.fit_transform([4, 5, 6]);
    console.log('minmax result', result);
    var minmaxScaler2 = new data_2.MinMaxScaler({ featureRange: [0, 1] });
    minmaxScaler2.fit([[1, 2, 3], [4, 5, 6]]);
    var result2 = minmaxScaler2.transform([[1, 2, 3]]);
    console.log('minmax result 2', result2);
    var testX = [[1, 2], [null, 3], [7, 6]];
    var imp = new Imputer_2.Imputer({ missingValues: null, axis: 0 });
    imp.fit(testX);
    var impResult = imp.fit_transform([[null, 2], [6, null], [7, 6]]);
    console.log('checking result', impResult);
    var binX = [[1, -1, 2], [2, 0, 0], [0, 1, -1]];
    var newBin = new data_3.Binarizer({ threshold: 0 });
    var binResult = newBin.transform(binX);
    console.log('binresult: ', binResult);
    var le = new label_2.LabelEncoder();
    var labelX = ['amsterdam', 'paris', 'tokyo'];
    le.fit(labelX);
    var transformX = ['tokyo', 'tokyo', 'paris'];
    var leResult = le.transform(transformX);
    console.log(leResult);
    var dummy = data_4.add_dummy_feature([[0, 1, 2], [1, 0, 3]]);
    console.log(dummy);
});
define("lib/svm/index.repl", ["require", "exports", "lib/svm/classes"], function (require, exports, classes_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    console.log('running xor example');
    function svcTest() {
        return __awaiter(this, void 0, void 0, function () {
            var svc2, X, y, err;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        console.log('inside svctest');
                        svc2 = new classes_2.SVC();
                        X = [[-1, -1], [-2, -1], [1, 1], [2, 1]];
                        y = [-1, 1, 2, 2];
                        return [4 /*yield*/, svc2.fit(X, y)];
                    case 1:
                        err = _a.sent();
                        console.log('result ', err);
                        try {
                            console.log('svc2 pred ', svc2.predict([[-0.8, -1]]));
                        }
                        catch (e) {
                            console.log('err', e);
                        }
                        return [2 /*return*/];
                }
            });
        });
    }
    svcTest().then(function () { return console.log('svc2 test finished'); });
    function xor() {
        return __awaiter(this, void 0, void 0, function () {
            var svc, features, labels;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        svc = new classes_2.SVC();
                        features = [[0, 0], [1, 1]];
                        labels = [0, 1];
                        return [4 /*yield*/, svc.fit(features, labels)];
                    case 1:
                        _a.sent();
                        console.log('SVC predict result', svc.predictOne([2, 2]));
                        return [2 /*return*/];
                }
            });
        });
    }
    xor().then(function () { return console.log('finished SVC'); });
    function xor2() {
        return __awaiter(this, void 0, void 0, function () {
            var svr, features, labels;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        svr = new classes_2.SVR();
                        features = [[0, 0], [2, 2]];
                        labels = [0.5, 2.5];
                        return [4 /*yield*/, svr.fit(features, labels)];
                    case 1:
                        _a.sent();
                        console.log('SVR predict result', svr.predict([[1, 1]]));
                        return [2 /*return*/];
                }
            });
        });
    }
    xor2().then(function () { return console.log('finished SVR'); });
});
/* tslint:disable */
define("lib/tree/index.repl", ["require", "exports", "lib/tree/tree", "lib/datasets/index"], function (require, exports, tree_3, datasets_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    (function () {
        return __awaiter(this, void 0, void 0, function () {
            var features, decision, X, y, predictResult, predictResults, decision2, X2, y2, predictResult2, iris, _a, data, targets, decision3;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        features = ['color', 'diameter', 'label'];
                        decision = new tree_3.DecisionTreeClassifier({ featureLabels: features });
                        X = [
                            ['Green', 3],
                            ['Yellow', 3],
                            ['Red', 1],
                            ['Red', 1],
                            ['Yellow', 3]
                        ];
                        y = ['Apple', 'Apple', 'Grape', 'Grape', 'Lemon'];
                        decision.fit(X, y);
                        decision.printTree();
                        predictResult = decision.predict([['Green', 3]]);
                        console.log('predict result', predictResult);
                        predictResults = decision.predict(X);
                        console.log('predicted all results', predictResults);
                        decision2 = new tree_3.DecisionTreeClassifier({ featureLabels: null });
                        X2 = [[0, 0], [1, 1]];
                        y2 = [0, 1];
                        decision2.fit(X2, y2);
                        predictResult2 = decision2.predict([[0, 1]]);
                        console.log('checking predict 2', predictResult2);
                        iris = new datasets_1.Iris();
                        return [4 /*yield*/, iris.load()];
                    case 1:
                        _a = _b.sent(), data = _a.data, targets = _a.targets;
                        decision3 = new tree_3.DecisionTreeClassifier();
                        decision3.fit(data, targets);
                        console.log('checking the result');
                        console.log(decision3.predict([[5.9, 3, 5.1, 1.8]]));
                        return [2 /*return*/];
                }
            });
        });
    })();
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFjaGluZWxlYXJuLndlYi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvdHlwZXMvbWF0cml4LnR5cGVzLnRzIiwiLi4vLi4vc3JjL2xpYi90eXBlcy9tb2RlbC50eXBlcy50cyIsIi4uLy4uL3NyYy9saWIvdHlwZXMvaW5kZXgudHMiLCIuLi8uLi9zcmMvbGliL29wcy90ZW5zb3Jfb3BzLnRzIiwiLi4vLi4vc3JjL2xpYi9vcHMvaW5kZXgudHMiLCIuLi8uLi9zcmMvbGliL3V0aWxzL01hdGhFeHRyYS50cyIsIi4uLy4uL3NyYy9saWIvY2x1c3Rlci9rX21lYW5zLnRzIiwiLi4vLi4vc3JjL2xpYi9jbHVzdGVyL2luZGV4LnRzIiwiLi4vLi4vc3JjL2xpYi9wcmVwcm9jZXNzaW5nL2xhYmVsLnRzIiwiLi4vLi4vc3JjL2xpYi9kYXRhc2V0cy9CYXNlRGF0YXNldC50cyIsIi4uLy4uL3NyYy9saWIvZGF0YXNldHMvQm9zdG9uLnRzIiwiLi4vLi4vc3JjL2xpYi9kYXRhc2V0cy9JcmlzLnRzIiwiLi4vLi4vc3JjL2xpYi9kYXRhc2V0cy9pbmRleC50cyIsIi4uLy4uL3NyYy9saWIvZGVjb21wb3NpdGlvbi9wY2EudHMiLCIuLi8uLi9zcmMvbGliL2RlY29tcG9zaXRpb24vaW5kZXgudHMiLCIuLi8uLi9zcmMvbGliL3RyZWUvdHJlZS50cyIsIi4uLy4uL3NyYy9saWIvdHJlZS9pbmRleC50cyIsIi4uLy4uL3NyYy9saWIvZW5zZW1ibGUvZm9yZXN0LnRzIiwiLi4vLi4vc3JjL2xpYi9lbnNlbWJsZS9pbmRleC50cyIsIi4uLy4uL3NyYy9saWIvdXRpbHMvbmxwLnRzIiwiLi4vLi4vc3JjL2xpYi9mZWF0dXJlX2V4dHJhY3Rpb24vc3RvcF93b3Jkcy50cyIsIi4uLy4uL3NyYy9saWIvZmVhdHVyZV9leHRyYWN0aW9uL3RleHQudHMiLCIuLi8uLi9zcmMvbGliL2ZlYXR1cmVfZXh0cmFjdGlvbi9pbmRleC50cyIsIi4uLy4uL3NyYy9saWIvdXRpbHMvcGVybXV0YXRpb25zLnRzIiwiLi4vLi4vc3JjL2xpYi9wcmVwcm9jZXNzaW5nL2RhdGEudHMiLCIuLi8uLi9zcmMvbGliL3ByZXByb2Nlc3NpbmcvSW1wdXRlci50cyIsIi4uLy4uL3NyYy9saWIvcHJlcHJvY2Vzc2luZy9pbmRleC50cyIsIi4uLy4uL3NyYy9saWIvbGluZWFyX21vZGVsL3N0b2NoYXN0aWNfZ3JhZGllbnQudHMiLCIuLi8uLi9zcmMvbGliL2xpbmVhcl9tb2RlbC9jb29yZGluYXRlX2Rlc2NlbnQudHMiLCIuLi8uLi9zcmMvbGliL2xpbmVhcl9tb2RlbC9saW5lYXJfcmVncmVzc2lvbi50cyIsIi4uLy4uL3NyYy9saWIvbGluZWFyX21vZGVsL2luZGV4LnRzIiwiLi4vLi4vc3JjL2xpYi91dGlscy92YWxpZGF0aW9uLnRzIiwiLi4vLi4vc3JjL2xpYi9tZXRyaWNzL2NsYXNzaWZpY2F0aW9uLnRzIiwiLi4vLi4vc3JjL2xpYi9tZXRyaWNzL3JlZ3Jlc3Npb24udHMiLCIuLi8uLi9zcmMvbGliL21ldHJpY3MvaW5kZXgudHMiLCIuLi8uLi9zcmMvbGliL21vZGVsX3NlbGVjdGlvbi9fc3BsaXQudHMiLCIuLi8uLi9zcmMvbGliL21vZGVsX3NlbGVjdGlvbi9pbmRleC50cyIsIi4uLy4uL3NyYy9saWIvbmVpZ2hib3JzL0tEVHJlZS50cyIsIi4uLy4uL3NyYy9saWIvbmVpZ2hib3JzL2NsYXNzaWZpY2F0aW9uLnRzIiwiLi4vLi4vc3JjL2xpYi9uZWlnaGJvcnMvaW5kZXgudHMiLCIuLi8uLi9zcmMvbGliL3N2bS9jbGFzc2VzLnRzIiwiLi4vLi4vc3JjL2xpYi9zdm0vaW5kZXgudHMiLCIuLi8uLi9zcmMvbGliL2luZGV4LnRzIiwiLi4vLi4vc3JjL2xpYi9jbHVzdGVyL2luZGV4LnJlcGwudHMiLCIuLi8uLi9zcmMvbGliL2RhdGFzZXRzL2luZGV4LnJlcGwudHMiLCIuLi8uLi9zcmMvbGliL2RlY29tcG9zaXRpb24vaW5kZXgucmVwbC50cyIsIi4uLy4uL3NyYy9saWIvZW5zZW1ibGUvaW5kZXgucmVwbC50cyIsIi4uLy4uL3NyYy9saWIvZmVhdHVyZV9leHRyYWN0aW9uL2luZGV4LnJlcGwudHMiLCIuLi8uLi9zcmMvbGliL2xpbmVhcl9tb2RlbC9pbmRleC5yZXBsLnRzIiwiLi4vLi4vc3JjL2xpYi9tZXRyaWNzL2luZGV4LnJlcGwudHMiLCIuLi8uLi9zcmMvbGliL21vZGVsX3NlbGVjdGlvbi9pbmRleC5yZXBsLnRzIiwiLi4vLi4vc3JjL2xpYi9uYWl2ZV9iYXllcy9nYXVzc2lhbi50cyIsIi4uLy4uL3NyYy9saWIvbmFpdmVfYmF5ZXMvbXVsdGlub21pYWwudHMiLCIuLi8uLi9zcmMvbGliL25haXZlX2JheWVzL2luZGV4LnRzIiwiLi4vLi4vc3JjL2xpYi9uYWl2ZV9iYXllcy9pbmRleC5yZXBsLnRzIiwiLi4vLi4vc3JjL2xpYi9uZWlnaGJvcnMvaW5kZXgucmVwbC50cyIsIi4uLy4uL3NyYy9saWIvb3BzL2luZGV4LnJlcGwudHMiLCIuLi8uLi9zcmMvbGliL3ByZXByb2Nlc3NpbmcvaW5kZXgucmVwbC50cyIsIi4uLy4uL3NyYy9saWIvc3ZtL2luZGV4LnJlcGwudHMiLCIuLi8uLi9zcmMvbGliL3RyZWUvaW5kZXgucmVwbC50cyIsIi4uLy4uL3NyYy9saWIvdXRpbHMvZGVwcy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lDVUE7OztPQUdHO0lBQ0g7UUFBQTtRQW9CQSxDQUFDO1FBQUQsZUFBQztJQUFELENBQUMsQUFwQkQsSUFvQkM7SUFwQnFCLDRCQUFROzs7OztJQ0U1QixtQkFUTyxzQkFBUSxDQVNQOzs7Ozs7SUNaVjs7Ozs7Ozs7Ozs7T0FXRztJQUNILG9CQUEyQixDQUFrQjtRQUMzQyxPQUFPLEVBQUUsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDO0lBQzVC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QU8sQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBSW5DLElBQU0sR0FBRyxHQUFHLElBQUksZ0JBQWEsRUFBRSxDQUFDO0lBQ2hDLElBQU0sRUFBRSxHQUFHO1FBQ1QsQ0FBQyxDQUFDLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFFLEVBQUUsRUFBRSxHQUFHLEVBQUUsS0FBSyxFQUFFLENBQUMsRUFBRSxJQUFJLEVBQUUsR0FBRyxDQUFDO1FBQzFELENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxJQUFJLEVBQUUsR0FBRyxFQUFFLEtBQUssRUFBRSxFQUFFLEVBQUUsR0FBRyxFQUFFLEtBQUssRUFBRSxHQUFHLEVBQUUsSUFBSSxFQUFFLEdBQUcsQ0FBQztRQUM1RCxDQUFDLEdBQUcsRUFBRSxJQUFJLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxJQUFJLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLENBQUM7UUFDN0QsQ0FBQyxHQUFHLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxHQUFHLEVBQUUsS0FBSyxFQUFFLEVBQUUsRUFBRSxHQUFHLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxHQUFHLEVBQUUsR0FBRyxDQUFDO1FBQzlELENBQUMsR0FBRyxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsR0FBRyxFQUFFLEtBQUssRUFBRSxFQUFFLEVBQUUsR0FBRyxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsR0FBRyxFQUFFLEdBQUcsQ0FBQztLQUMvRCxDQUFDO0lBRUYsSUFBTSxFQUFFLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFFM0IsR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUM7SUFD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