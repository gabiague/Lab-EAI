"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var _ = __importStar(require("lodash"));
var Random = __importStar(require("random-js"));
var ops_1 = require("../ops");
var MathExtra_1 = __importDefault(require("../utils/MathExtra"));
/**
 * K-Means clustering
 *
 * @example
 * import { KMeans } from 'machinelearn/cluster';
 *
 * const kmean = new KMeans({ k: 2 });
 * const clusters = kmean.fit([[1, 2], [1, 4], [1, 0], [4, 2], [4, 4], [4, 0]]);
 *
 * const result = kmean.predict([[0, 0], [4, 4]]);
 * // results in: [0, 1]
 */
var KMeans = /** @class */ (function () {
    /**
     *
     * @param distance - Choice of distance method. Defaulting to euclidean
     * @param k - Number of clusters
     * @param maxIteration - Relative tolerance with regards to inertia to declare convergence
     * @param randomState - Random state value for sorting centroids during the getInitialCentroid phase
     */
    function KMeans(_a) {
        var _b = _a === void 0 ? {
            distance: 'euclidean',
            k: 3,
            maxIteration: 300,
            randomState: 0
        } : _a, _c = _b.distance, distance = _c === void 0 ? 'euclidean' : _c, _d = _b.k, k = _d === void 0 ? 3 : _d, _e = _b.maxIteration, maxIteration = _e === void 0 ? 300 : _e, _f = _b.randomState, randomState = _f === void 0 ? 0 : _f;
        this.k = k;
        // Assigning a distance method
        var distanceType = distance;
        switch (distanceType) {
            case 'euclidean':
                this.distance = MathExtra_1.default.euclideanDistance;
                break;
            case 'manhattan':
                this.distance = MathExtra_1.default.manhattanDistance;
                break;
            default:
                throw new Error("Unknown distance type " + distanceType);
        }
        this.randomState = randomState;
        this.maxIteration = maxIteration;
        this.centroids = [];
    }
    /**
     * Compute k-means clustering.
     * @param {any} X - array-like or sparse matrix of shape = [n_samples, n_features]
     * @returns {{centroids: number[]; clusters: number[]}}
     */
    KMeans.prototype.fit = function (X) {
        var _this = this;
        if (X === void 0) { X = null; }
        ops_1.validateMatrix2D(X);
        this.assignment = new Array(_.size(X));
        this.centroids = this.getInitialCentroids(X, this.k);
        this.clusters = new Array(this.k);
        // Flag to check the convergence
        var movement = true;
        // Looping only within the maxIteration boundary
        for (var iter = 0; iter < this.maxIteration && movement; iter++) {
            // find the distance between the point and cluster; choose the nearest centroid
            _.forEach(X, function (data, i) {
                _this.assignment[i] = _this.getClosestCentroids(data, _this.centroids, _this.distance);
            });
            // Flag set to false; giving opportunity to stop the loop upon the covergence
            movement = false;
            // Updating the location of each centroid
            for (var j = 0; j < this.k; j++) {
                var assigned = [];
                for (var i = 0; i < this.assignment.length; i++) {
                    if (this.assignment[i] === j) {
                        assigned.push(X[i]);
                    }
                }
                if (!assigned.length) {
                    continue;
                }
                // Getting the original data point
                // TODO: Fix any type
                var centroid = this.centroids[j];
                var newCentroid = new Array(centroid.length);
                for (var g = 0; g < centroid.length; g++) {
                    var sum = 0;
                    for (var i = 0; i < assigned.length; i++) {
                        sum += assigned[i][g];
                    }
                    newCentroid[g] = sum / assigned.length;
                    // Does not converge yet
                    if (newCentroid[g] !== centroid[g]) {
                        movement = true;
                    }
                }
                this.centroids[j] = newCentroid;
                this.clusters[j] = assigned;
            }
        }
    };
    /**
     * Predicts the cluster index with the given X
     * @param {any} X - array-like or sparse matrix of shape = [n_samples, n_features]
     * @returns {number[]}
     */
    KMeans.prototype.predict = function (X) {
        var _this = this;
        if (X === void 0) { X = null; }
        ops_1.validateMatrix2D(X);
        return _.map(X, function (data) {
            return _this.getClosestCentroids(data, _this.centroids, _this.distance);
        });
    };
    /**
     * Get the model details in JSON format
     * @returns {{k: number; clusters: number[]; centroids: number[]}}
     */
    KMeans.prototype.toJSON = function () {
        return {
            centroids: this.centroids,
            clusters: this.clusters,
            k: this.k
        };
    };
    /**
     * Restores the model from checkpoints
     * @param {number} k
     * @param {number[]} clusters
     * @param {number[]} centroids
     */
    KMeans.prototype.fromJSON = function (_a) {
        var _b = _a.k, k = _b === void 0 ? null : _b, _c = _a.clusters, clusters = _c === void 0 ? null : _c, _d = _a.centroids, centroids = _d === void 0 ? null : _d;
        if (!k || !clusters || !centroids) {
            throw new Error('You must provide all the parameters include k, clusters and centroids');
        }
        this.k = k;
        this.clusters = clusters;
        this.centroids = centroids;
    };
    /**
     * Get initial centroids from X of k
     * @param {number[]} X
     * @param {number} k
     * @returns {number[]}
     */
    KMeans.prototype.getInitialCentroids = function (X, k) {
        // Create an initial copy
        var centroids = _.clone(X);
        // Sort the centroid randomly if the randomState is greater than 0
        if (this.randomState > 0) {
            var randomEngine_1 = Random.engines.mt19937();
            randomEngine_1.seed(this.randomState);
            centroids.sort(function () {
                var randomInt = Random.integer(0, 1)(randomEngine_1);
                return Math.round(randomInt) - 0.5;
            });
        }
        return centroids.slice(0, k);
    };
    /**
     * Get closest centroids based on the passed in distance method
     * @param {number[]} data
     * @param {number[]} centroids
     * @param distance
     * @returns {number}
     */
    KMeans.prototype.getClosestCentroids = function (data, centroids, distance) {
        var min = Infinity;
        var index = 0;
        _.forEach(centroids, function (centroid, i) {
            var dist = distance(data, centroid);
            if (dist < min) {
                min = dist;
                index = i;
            }
        });
        return index;
    };
    return KMeans;
}());
exports.KMeans = KMeans;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoia19tZWFucy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9saWIvY2x1c3Rlci9rX21lYW5zLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBLHdDQUE0QjtBQUM1QixnREFBb0M7QUFDcEMsOEJBQTBDO0FBRTFDLGlFQUFzQztBQVN0Qzs7Ozs7Ozs7Ozs7R0FXRztBQUNIO0lBU0U7Ozs7OztPQU1HO0lBQ0gsZ0JBQ0UsRUFVQztZQVZEOzs7OztjQVVDLEVBVEMsZ0JBQXNCLEVBQXRCLDJDQUFzQixFQUN0QixTQUFLLEVBQUwsMEJBQUssRUFDTCxvQkFBa0IsRUFBbEIsdUNBQWtCLEVBQ2xCLG1CQUFlLEVBQWYsb0NBQWU7UUFRakIsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDWCw4QkFBOEI7UUFDOUIsSUFBTSxZQUFZLEdBQUcsUUFBUSxDQUFDO1FBQzlCLFFBQVEsWUFBWSxFQUFFO1lBQ3BCLEtBQUssV0FBVztnQkFDZCxJQUFJLENBQUMsUUFBUSxHQUFHLG1CQUFJLENBQUMsaUJBQWlCLENBQUM7Z0JBQ3ZDLE1BQU07WUFDUixLQUFLLFdBQVc7Z0JBQ2QsSUFBSSxDQUFDLFFBQVEsR0FBRyxtQkFBSSxDQUFDLGlCQUFpQixDQUFDO2dCQUN2QyxNQUFNO1lBQ1I7Z0JBQ0UsTUFBTSxJQUFJLEtBQUssQ0FBQywyQkFBeUIsWUFBYyxDQUFDLENBQUM7U0FDNUQ7UUFDRCxJQUFJLENBQUMsV0FBVyxHQUFHLFdBQVcsQ0FBQztRQUMvQixJQUFJLENBQUMsWUFBWSxHQUFHLFlBQVksQ0FBQztRQUNqQyxJQUFJLENBQUMsU0FBUyxHQUFHLEVBQUUsQ0FBQztJQUN0QixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNJLG9CQUFHLEdBQVYsVUFBVyxDQUE4QjtRQUF6QyxpQkF3REM7UUF4RFUsa0JBQUEsRUFBQSxRQUE4QjtRQUN2QyxzQkFBZ0IsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNwQixJQUFJ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