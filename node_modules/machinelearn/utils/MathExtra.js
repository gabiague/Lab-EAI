"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var _ = __importStar(require("lodash"));
/**
 * Return the number of elements along a given axis.
 * @param {any} X: Array like input data
 * @param {any} axis
 * @ignore
 */
var size = function (X, axis) {
    if (axis === void 0) { axis = 0; }
    var rows = _.size(X);
    if (rows === 0) {
        throw new Error('Invalid input array of size 0!');
    }
    if (axis === 0) {
        return rows;
    }
    else if (axis === 1) {
        return _.flowRight(_.size, function (a) { return _.get(a, '[0]'); })(X);
    }
    throw new Error("Invalid axis value " + axis + " was given");
};
/**
 * Just a dumb version of subset, which is sufficient enough for now.
 * It can only handle range of rows with a single column.
 *
 * TODO: Improve.
 * @param X
 * @param rowsRange
 * @param colsRange
 * @ignore
 */
var subset = function (X, rowsRange, colsRange, replacement) {
    if (replacement === void 0) { replacement = null; }
    // console.log('checking subset', X, rowsRange, colsRange, replacement);
    if (replacement) {
        var _X_1 = _.cloneDeep(X);
        var _loop_1 = function (i) {
            var rowIndex = rowsRange[i];
            colsRange.forEach(function (col) {
                _X_1[rowIndex][col] = replacement[i];
            });
        };
        for (var i = 0; i < rowsRange.length; i++) {
            _loop_1(i);
        }
        return _X_1;
    }
    else {
        var result = [];
        var _loop_2 = function (i) {
            var rowIndex = rowsRange[i];
            var subSection = [];
            colsRange.forEach(function (col) {
                subSection.push(X[rowIndex][col]);
            });
            // result.push([X[rowIndex][col]]);
            result.push(subSection);
        };
        // TODO: Replace it with a proper matrix subset method. e.g. http://mathjs.org/docs/reference/functions/subset.html
        for (var i = 0; i < rowsRange.length; i++) {
            _loop_2(i);
        }
        return result;
    }
};
/**
 * Get range of values
 * @param start
 * @param stop
 * @ignore
 */
var range = function (start, stop) {
    if (!_.isNumber(start) || !_.isNumber(stop)) {
        throw new Error('start and stop arguments need to be numbers');
    }
    return _.range(start, stop);
};
/**
 * Checking the maxtrix is a matrix of a certain data type (e.g. number)
 * The function also performs isMatrix against the passed in dataset
 * @param matrix
 * @param {string} _type
 * @ignore
 */
var isMatrixOf = function (matrix, _type) {
    if (_type === void 0) { _type = 'number'; }
    if (!isMatrix(matrix)) {
        throw Error("Cannot perform isMatrixOf " + _type + " unless the data is matrix");
    }
    // Checking each elements inside the matrix is not number
    // Returns an array of result per row
    var vectorChecks = matrix.map(function (arr) {
        return arr.some(function (x) {
            // Checking type of each element
            if (_type === 'number') {
                return !_.isNumber(x);
            }
            else {
                throw Error('Cannot check matrix of an unknown type');
            }
        });
    });
    // All should be false
    return vectorChecks.indexOf(true) === -1;
};
/**
 * Checking the matrix is a data of multiple rows
 * @param matrix
 * @returns {boolean}
 * @ignore
 */
var isMatrix = function (matrix) {
    if (!Array.isArray(matrix)) {
        return false;
    }
    if (_.size(matrix) === 0) {
        return false;
    }
    var isAllArray = matrix.map(function (arr) { return _.isArray(arr); });
    return isAllArray.indexOf(false) === -1;
};
/**
 * Checking the array is a type of X
 * @param arr
 * @param {string} _type
 * @returns {boolean}
 * @ignore
 */
var isArrayOf = function (arr, _type) {
    if (_type === void 0) { _type = 'number'; }
    if (_type === 'number') {
        return !arr.some(isNaN);
    }
    else if (_type === 'string') {
        return !arr.some(function (x) { return !_.isString(x); });
    }
    throw Error("Failed to check the array content of type " + _type);
};
/**
 *
 * @param {number[]} v1
 * @param {number[]} v2
 * @returns {number}
 * @ignore
 */
var euclideanDistance = function (v1, v2) {
    var v1Range = _.range(0, v1.length);
    var initialTotal = 0;
    var total = _.reduce(v1Range, function (sum, i) {
        return sum + Math.pow(v2[i] - v1[i], 2);
    }, initialTotal);
    return Math.sqrt(total);
};
/**
 *
 * @param {number[]} v1
 * @param {number[]} v2
 * @returns {number}
 * @ignore
 */
var manhattanDistance = function (v1, v2) {
    var v1Range = _.range(0, v1.length);
    var initialTotal = 0;
    return _.reduce(v1Range, function (total, i) {
        return total + Math.abs(v2[i] - v1[i]);
    }, initialTotal);
};
/**
 * Subtracts two matrices
 * @param X
 * @param y
 * @ignore
 */
var subtract = function (X, y) {
    var _X = _.clone(X);
    for (var rowIndex = 0; rowIndex < _X.length; rowIndex++) {
        var row = X[rowIndex];
        for (var colIndex = 0; colIndex < row.length; colIndex++) {
            var column = row[colIndex];
            // Supports y.length === 1 or y.length === row.length
            if (y.length === 1) {
                var subs = y[0];
                _X[rowIndex][colIndex] = column - subs;
            }
            else if (y.length === row.length) {
                var subs = y[colIndex];
                _X[rowIndex][colIndex] = column - subs;
            }
            else {
                throw Error("Dimension of y " + y.length + " and row " + row.length + " are not compatible");
            }
        }
    }
    return _X;
};
/**
 * Calculates covariance
 * @param X
 * @param xMean
 * @param y
 * @param yMean
 * @returns {number}
 * @ignore
 */
var covariance = function (X, xMean, y, yMean) {
    if (_.size(X) !== _.size(y)) {
        throw new Error('X and y should match in size');
    }
    var covar = 0.0;
    for (var i = 0; i < _.size(X); i++) {
        covar += (X[i] - xMean) * (y[i] - yMean);
    }
    return covar;
};
/**
 * Calculates the variance
 * needed for linear regression
 * @param X
 * @param mean
 * @returns {number}
 * @ignore
 */
var variance = function (X, mean) {
    if (!Array.isArray(X)) {
        throw new Error('X must be an array');
    }
    var result = 0.0;
    for (var i = 0; i < _.size(X); i++) {
        result += Math.pow(X[i] - mean, 2);
    }
    return result;
};
/**
 * Stack arrays in sequence horizontally (column wise).
 * This is equivalent to concatenation along the second axis, except for 1-D
 * arrays where it concatenates along the first axis. Rebuilds arrays divided by hsplit.
 *
 * @example
 * hstack([[1], [1]], [[ 0, 1, 2 ], [ 1, 0, 3 ]])
 * returns [ [ 1, 0, 1, 2 ], [ 1, 1, 0, 3 ] ]
 * @param X
 * @param y
 * @ignore
 */
var hstack = function (X, y) {
    var stack = [];
    if (isMatrix(X) && isMatrix(y)) {
        for (var i = 0; i < X.length; i++) {
            var xEntity = X[i];
            var yEntity = y[i];
            stack.push(hstack(xEntity, yEntity));
        }
    }
    else if (Array.isArray(X) && Array.isArray(y)) {
        stack = _.concat(X, y);
        stack = _.flatten(stack);
    }
    else {
        throw Error('Input should be either matrix or Arrays');
    }
    return stack;
};
/**
 * Validating the left input is an array, and the right input is a pure number.
 * @param a
 * @param b
 * @ignore
 */
var isArrayNumPair = function (a, b) { return Array.isArray(a) && _.isNumber(b); };
/**
 * Inner product of two arrays.
 * Ordinary inner product of vectors for 1-D arrays (without complex conjugation),
 * in higher dimensions a sum product over the last axes.
 * @param a
 * @param b
 * @ignore
 */
var inner = function (a, b) {
    /**
     * Internal methods to process the inner product
     * @param a - First vector
     * @param b - Second vector or a number
     */
    // 1. If a and b are both pure numbers
    if (_.isNumber(a) && _.isNumber(b)) {
        return a * b;
    }
    // If a is a vector and b is a pure number
    if (isArrayNumPair(a, b)) {
        return a.map(function (x) { return x * b; });
    }
    // If b is a vector and a is a pure number
    if (isArrayNumPair(b, a)) {
        return b.map(function (x) { return x * a; });
    }
    // If a and b are both vectors with an identical size
    if (Array.isArray(a) && Array.isArray(b) && a.length === b.length) {
        var result = 0;
        for (var i = 0; i < a.length; i++) {
            result += a[i] * b[i];
        }
        return result;
    }
    else if (Array.isArray(a) && Array.isArray(b) && a.length !== b.length) {
        throw new Error("Dimensions (" + a.length + ",) and (" + b.length + ",) are not aligned");
    }
    throw new Error("Cannot process with the invalid inputs " + a + " and " + b);
};
var math = {
    covariance: covariance,
    euclideanDistance: euclideanDistance,
    hstack: hstack,
    isArrayOf: isArrayOf,
    inner: inner,
    isMatrix: isMatrix,
    isMatrixOf: isMatrixOf,
    manhattanDistance: manhattanDistance,
    range: range,
    subset: subset,
    size: size,
    subtract: subtract,
    variance: variance
};
exports.default = math;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTWF0aEV4dHJhLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2xpYi91dGlscy9NYXRoRXh0cmEudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUEsd0NBQTRCO0FBRTVCOzs7OztHQUtHO0FBQ0gsSUFBTSxJQUFJLEdBQUcsVUFBQyxDQUFDLEVBQUUsSUFBUTtJQUFSLHFCQUFBLEVBQUEsUUFBUTtJQUN2QixJQUFNLElBQUksR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3ZCLElBQUksSUFBSSxLQUFLLENBQUMsRUFBRTtRQUNkLE1BQU0sSUFBSSxLQUFLLENBQUMsZ0NBQWdDLENBQUMsQ0FBQztLQUNuRDtJQUNELElBQUksSUFBSSxLQUFLLENBQUMsRUFBRTtRQUNkLE9BQU8sSUFBSSxDQUFDO0tBQ2I7U0FBTSxJQUFJLElBQUksS0FBSyxDQUFDLEVBQUU7UUFDckIsT0FBTyxDQUFDLENBQUMsU0FBUyxDQUNoQixDQUFDLENBQUMsSUFBSSxFQUNOLFVBQUEsQ0FBQyxJQUFJLE9BQUEsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFDLEVBQWYsQ0FBZSxDQUNyQixDQUFDLENBQUMsQ0FBQyxDQUFDO0tBQ047SUFDRCxNQUFNLElBQUksS0FBSyxDQUFDLHdCQUFzQixJQUFJLGVBQVksQ0FBQyxDQUFDO0FBQzFELENBQUMsQ0FBQztBQUVGOzs7Ozs7Ozs7R0FTRztBQUNILElBQU0sTUFBTSxHQUFHLFVBQ2IsQ0FBQyxFQUNELFNBQW1CLEVBQ25CLFNBQW1CLEVBQ25CLFdBQWtCO0lBQWxCLDRCQUFBLEVBQUEsa0JBQWtCO0lBRWxCLHdFQUF3RTtJQUN4RSxJQUFJLFdBQVcsRUFBRTtRQUNmLElBQU0sSUFBRSxHQUFHLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0NBQ2pCLENBQUM7WUFDUixJQUFNLFFBQVEsR0FBRyxTQUFTLENBQUMs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