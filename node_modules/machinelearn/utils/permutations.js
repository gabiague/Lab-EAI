"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
/* Original code from:
 * https://gist.github.com/wassname/a882ac3981c8e18d2556
 * Minor updates has been made to pass TSLint and TSDoc checks
 */
var _ = __importStar(require("lodash"));
/**
 * Generate all combination of arguments from objects
 * @param optObj - An object or arrays with keys describing options  {firstName:['Ben','Jade','Darren'],lastName:['Smith','Miller']}
 * @private
 * @return - An array of objects e.g. [{firstName:'Ben',LastName:'Smith'},{..]
 * @ignore
 */
function _cartesianProductObj(optObj) {
    var keys = _.keys(optObj);
    var opts = _.values(optObj);
    var combs = _cartesianProductOf(opts);
    return _.map(combs, function (comb) {
        return _.zipObject(keys, comb);
    });
}
/**
 * Generate all combination of arguments when given arrays or strings
 * e.g. [['Ben','Jade','Darren'],['Smith','Miller']] to [['Ben','Smith'],[..]]
 * e.g. 'the','cat' to [['t', 'c'],['t', 'a'], ...]
 * @param args
 * @private
 * @ignore
 */
function _cartesianProductOf(args) {
    var _args = args;
    if (arguments.length > 1) {
        _args = _.toArray(arguments);
    }
    // strings to arrays of letters
    _args = _.map(_args, function (opt) { return (typeof opt === 'string' ? _.toArray(opt) : opt); });
    return _.reduce(_args, function (a, b) {
        return _.flatten(_.map(a, function (x) {
            return _.map(b, function (y) {
                return _.concat(x, [y]);
            });
        }));
    }, [[]]);
}
/**
 * Generate the cartesian product of input objects, arrays, or strings
 *
 *
 * product('me','hi')
 * // => [["m","h"],["m","i"],["e","h"],["e","i"]]
 *
 * product([1,2,3],['a','b','c']
 * // => [[1,"a"],[1,"b"],[1,"c"],[2,"a"],[2,"b"],[2,"c"],[3,"a"],[3,"b"],[3,"c"]]
 *
 * product({who:['me','you'],say:['hi','by']})
 * // => [{"who":"me","say":"hi"},{"who":"me","say":"by"},{"who":"you","say":"hi"},{"who":"you","say":"by"}]
 *
 * // It also takes in a single array of args
 * product(['me','hi'])
 * // => [["m","h"],["m","i"],["e","h"],["e","i"]]
 * @ignore
 */
function product(opts) {
    if (arguments.length === 1 && !_.isArray(opts)) {
        return _cartesianProductObj(opts);
    }
    else if (arguments.length === 1) {
        return _cartesianProductOf(opts);
    }
    else {
        return _cartesianProductOf(arguments);
    }
}
/**
 * Generate n combinations with repeat values.
 * @param X - Matrix input
 * @param n - number of repeats
 * @ignore
 */
function combinationsWithReplacement(X, n) {
    var _n = n;
    var _X = X;
    if (typeof _X === 'string') {
        _X = _.toArray(_X);
    }
    // If repeat is 1, simply return the original value
    if (_n === 0) {
        return null;
    }
    if (_n === 1) {
        return X;
    }
    // Falls back to X.length as default value is _n is undefined
    _n = _n ? _n : X.length;
    // make n copies of keys/indices
    var nInds = [];
    for (var j = 0; j < _n; j++) {
        nInds.push(_.keys(_X));
    }
    // get product of the indices, then filter to keep elements in order
    var arrangements = product(nInds).filter(function (pair) { return pair[0] <= pair[1]; });
    return _.map(arrangements, function (indices) { return _.map(indices, function (i) { return _X[i]; }); });
}
exports.combinationsWithReplacement = combinationsWithReplacement;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGVybXV0YXRpb25zLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2xpYi91dGlscy9wZXJtdXRhdGlvbnMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7OztHQUdHO0FBQ0gsd0NBQTRCO0FBRTVCOzs7Ozs7R0FNRztBQUNILDhCQUE4QixNQUFNO0lBQ2xDLElBQU0sSUFBSSxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDNUIsSUFBTSxJQUFJLEdBQUcsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUM5QixJQUFNLEtBQUssR0FBRyxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUN4QyxPQUFPLENBQUMsQ0FBQyxHQUFHLENBQUMsS0FBSyxFQUFFLFVBQUEsSUFBSTtRQUN0QixPQUFPLENBQUMsQ0FBQyxTQUFTLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQ2pDLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQztBQUVEOzs7Ozs7O0dBT0c7QUFDSCw2QkFBNkIsSUFBSTtJQUMvQixJQUFJLEtBQUssR0FBRyxJQUFJLENBQUM7SUFDakIsSUFBSSxTQUFTLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtRQUN4QixLQUFLLEdBQUcsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQztLQUM5QjtJQUVELCtCQUErQjtJQUMvQixLQUFLLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEVBQUUsVUFBQSxHQUFHLElBQUksT0FBQSxDQUFDLE9BQU8sR0FBRyxLQUFLLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQWhELENBQWdELENBQUMsQ0FBQztJQUM5RSxPQUFPLENBQUMsQ0FBQyxNQUFNLENBQ2IsS0FBSyxFQUNMLFVBQUMsQ0FB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