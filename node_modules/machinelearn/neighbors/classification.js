"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var lodash_1 = require("lodash");
var ops_1 = require("../ops");
var MathExtra_1 = __importDefault(require("../utils/MathExtra"));
var KDTree_1 = __importDefault(require("./KDTree"));
var euclideanDistance = MathExtra_1.default.euclideanDistance, manhattanDistance = MathExtra_1.default.manhattanDistance;
var DIST_EUC = 'euclidean';
var DIST_MAN = 'manhattan';
var TYPE_KD = 'kdtree';
/**
 * Classifier implementing the k-nearest neighbors vote.
 *
 * @example
 * const knn = new KNeighborsClassifier();
 * const X = [[0, 0, 0], [0, 1, 1], [1, 1, 0], [2, 2, 2], [1, 2, 2], [2, 1, 2]];
 * const y = [0, 0, 0, 1, 1, 1];
 * knn.fit(X ,y);
 * console.log(knn.predict([1, 2])); // predicts 1
 */
var KNeighborsClassifier = /** @class */ (function () {
    /**
     * @param {string} distance - Choice of distance function, should choose between euclidean | manhattan
     * @param {number} k - Number of neighbors to classify
     * @param {string} type - Type of algorithm to use, choose between kdtree(default) | balltree | simple
     */
    function KNeighborsClassifier(_a) {
        var _b = _a === void 0 ? {
            // Default value on empty constructor
            distance: DIST_EUC,
            k: 0,
            type: TYPE_KD
        } : _a, 
        // Each object param default value
        _c = _b.distance, 
        // Each object param default value
        distance = _c === void 0 ? DIST_EUC : _c, _d = _b.k, k = _d === void 0 ? 0 : _d, _e = _b.type, type = _e === void 0 ? TYPE_KD : _e;
        this.type = null;
        this.tree = null;
        this.k = null;
        this.classes = null;
        this.distance = null;
        var options = {
            distance: distance,
            k: k,
            type: type
        };
        // Handling distance
        if (options.distance === DIST_EUC) {
            this.distance = euclideanDistance;
        }
        else if (options.distance === DIST_MAN) {
            this.distance = manhattanDistance;
        }
        else {
            throw new Error("Unrecognised type of distance " + options.distance + " was received");
        }
        this.k = options.k;
        this.type = options.type;
    }
    /**
     * Train the classifier with input and output data
     * @param {any} X - Training data.
     * @param {any} y - Target data.
     */
    KNeighborsClassifier.prototype.fit = function (X, y) {
        ops_1.validateFitInputs(X, y);
        // Getting the classes from y
        var classes = lodash_1.uniqBy(y, function (c) { return c; });
        // Setting k; if it's null, use the class length
        var k = this.k ? this.k : classes.length + 1;
        //  Constructing the points placeholder
        var points = new Array(X.length);
        for (var i = 0; i < points.length; ++i) {
            points[i] = X[i].slice();
        }
        for (var i = 0; i < y.length; ++i) {
            points[i].push(y[i]);
        }
        // Building a tree or algo according to this.type
        if (this.type === TYPE_KD) {
            this.tree = new KDTree_1.default(points, this.distance);
        }
        this.k = k;
        this.classes = classes;
    };
    /**
     * Return the model's state as a JSON object
     * @return {object} JSON KNN model.
     */
    KNeighborsClassifier.prototype.toJSON = function () {
        return {
            classes: this.classes,
            distance: this.distance,
            k: this.k,
            tree: this.tree,
            type: this.type
        };
    };
    /**
     * Restores the model from a JSON checkpoint
     * @param {any} classes
     * @param {any} distance
     * @param {any} k
     * @param {any} tree
     * @param {any} type
     */
    KNeighborsClassifier.prototype.fromJSON = function (_a) {
        var _b = _a.classes, classes = _b === void 0 ? null : _b, _c = _a.distance, distance = _c === void 0 ? null : _c, _d = _a.k, k = _d === void 0 ? null : _d, _e = _a.tree, tree = _e === void 0 ? null : _e, _f = _a.type, type = _f === void 0 ? null : _f;
        if (!classes || !distance || !k || !tree || !type) {
            throw new Error('You must provide classes, distance, k, tree and type to restore the KNearestNeighbor');
        }
        this.classes = classes;
        this.distance = distance;
        this.k = k;
        this.tree = tree;
        this.type = type;
    };
    /**
     * Predict single value from a list of data
     * @param {Array} X - Prediction data.
     * @returns number
     */
    KNeighborsClassifier.prototype.predict = function (X) {
        var _this = this;
        var shape = ops_1.inferShape(X);
        if (shape.length === 1) {
            return this.getSinglePred(X);
        }
        else if (shape.length === 2) {
            return lodash_1.map(X, function (currentItem) { return _this.getSinglePred(currentItem); });
        }
        else {
            throw new TypeError('The dataset is neither an array or a matrix');
        }
    };
    /**
     * Runs a single prediction against an array based on kdTree or balltree or
     * simple algo
     * @param array
     * @returns {{}}
     */
    KNeighborsClassifier.prototype.getSinglePred = function (array) {
        if (this.tree) {
            return this.getTreeBasedPrediction(array);
        }
        else {
            // Run the simple KNN algorithm
            return 0;
        }
    };
    /**
     * Get the class with the max point
     * @param current
     * @returns {{}}
     * @ignore
     */
    KNeighborsClassifier.prototype.getTreeBasedPrediction = function (current) {
        var nearestPoints = this.tree.nearest(current, this.k);
        var pointsPerClass = {};
        var predictedClass = -1;
        var maxPoints = -1;
        var lastElement = nearestPoints[0][0].length - 1;
        // Initialising the points placeholder per class
        for (var j = 0; j < this.classes.length; j++) {
            pointsPerClass[this.classes[j]] = 0;
        }
        // Voting the max value
        for (var i = 0; i < nearestPoints.length; ++i) {
            var currentClass = nearestPoints[i][0][lastElement];
            var currentPoints = ++pointsPerClass[currentClass];
            if (currentPoints > maxPoints) {
                predictedClass = currentClass;
                maxPoints = currentPoints;
            }
        }
        return predictedClass;
    };
    return KNeighborsClassifier;
}());
exports.KNeighborsClassifier = KNeighborsClassifier;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2xhc3NpZmljYXRpb24uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvbGliL25laWdoYm9ycy9jbGFzc2lmaWNhdGlvbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLGlDQUFxQztBQUNyQyw4QkFBdUQ7QUFFdkQsaUVBQXNDO0FBQ3RDLG9EQUE4QjtBQUN0QixJQUFBLHlEQUFpQixFQUFFLHlEQUFpQixDQUFVO0FBQ3RELElBQU0sUUFBUSxHQUFHLFdBQVcsQ0FBQztBQUM3QixJQUFNLFFBQVEsR0FBRyxXQUFXLENBQUM7QUFDN0IsSUFBTSxPQUFPLEdBQUcsUUFBUSxDQUFDO0FBRXpCOzs7Ozs7Ozs7R0FTRztBQUNIO0lBUUU7Ozs7T0FJRztJQUNILDhCQUNFLEVBZUM7WUFmRDs7Ozs7Y0FlQztRQWRDLGtDQUFrQztRQUNsQyxnQkFBbUI7UUFEbkIsa0NBQWtDO1FBQ2xDLHdDQUFtQixFQUNuQixTQUFLLEVBQUwsMEJBQUssRUFDTCxZQUFjLEVBQWQsbUNBQWM7UUFoQlYsU0FBSSxHQUFHLElBQUksQ0FBQztRQUNaLFNBQUksR0FBRyxJQUFJLENBQUM7UUFDWixNQUFDLEdBQUcsSUFBSSxDQUFDO1FBQ1QsWUFBTyxHQUFHLElBQUksQ0FBQztRQUNmLGFBQVEsR0FBRyxJQUFJLENBQUM7UUF5QnRCLElBQU0sT0FBTyxHQUFHO1lBQ2QsUUFBUSxVQUFBO1lBQ1IsQ0FBQyxHQUFBO1lBQ0QsSUFBSSxNQUFBO1NBQ0wsQ0FBQztRQUNGLG9CQUFvQjtRQUNwQixJQUFJLE9BQU8sQ0FBQyxRQUFRLEtBQUssUUFBUSxFQUFFO1lBQ2pDLElBQUksQ0FBQyxRQUFRLEdBQUcsaUJBQWlCLENBQUM7U0FDbkM7YUFBTSxJQUFJLE9BQU8sQ0FBQyxRQUFRLEtBQUssUUFBUSxFQUFFO1lBQ3hDLElBQUksQ0FBQyxRQUFRLEdBQUcsaUJBQWlCLENBQUM7U0FDbkM7YUFBTTtZQUNMLE1BQU0sSUFBSSxLQUFLLENBQ2IsbUNB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