"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var _ = __importStar(require("lodash"));
var ops_1 = require("../ops");
var MathExtra_1 = __importDefault(require("../utils/MathExtra"));
/**
 * Imputation transformer for completing missing values.
 *
 * @example
 * import { Imputer } from 'preprocessing/Imputer';
 *
 * const testX = [[1, 2], [null, 3], [7, 6]];
 * const imp = new Imputer({ missingValues: null, axis: 0 });
 * imp.fit(testX);
 * const impResult = imp.fit_transform([[null, 2], [6, null], [7, 6]]);
 * // [ [ 4, 2 ], [ 6, 3.6666666666666665 ], [ 7, 6 ] ]
 */
var Imputer = /** @class */ (function () {
    /**
     *
     * @param {any} missingValues - Target missing value to impute
     * @param {any} strategy - Missing value replacement strategy
     * @param {any} axis - Direction to impute
     * @param {any} copy - To clone the input value
     */
    function Imputer(_a) {
        var _b = _a.missingValues, missingValues = _b === void 0 ? null : _b, _c = _a.strategy, strategy = _c === void 0 ? 'mean' : _c, _d = _a.axis, axis = _d === void 0 ? 0 : _d, 
        // verbose = 0,
        _e = _a.copy, 
        // verbose = 0,
        copy = _e === void 0 ? false : _e;
        var _this = this;
        /**
         * Calculate array of numbers as array of mean values
         * Examples:
         * [ [ 1, 2 ], [ null, 3 ], [ 123, 3 ] ]
         * => [ 1.5, 3, 63 ]
         *
         * [ [ 1, 123 ], [ 2, 3, 3 ] ]
         * => [ 62, 2.6666666666666665 ]
         *
         * @param matrix
         * @param {string[]} steps
         */
        this.calcArrayMean = function (matrix, steps) {
            // TODO: Fix any return type
            // TODO: Fix matrix type any
            return _.reduce(steps, function (result, step) {
                switch (step) {
                    case 'flatten':
                        return _.map(result, _.flatten);
                    case 'filter':
                        return _.map(result, 
                        // Expecting any type of matrics array
                        // TODO: implement a correct type
                        function (arr) {
                            return _.filter(arr, function (z) { return z !== _this.missingValues; });
                        });
                    case 'mean':
                        return _.map(result, _.mean);
                    default:
                        return result;
                }
            }, matrix);
        };
        this.missingValues = missingValues;
        this.strategy = strategy;
        this.axis = axis;
        // this.verbose = verbose;
        this.copy = copy;
        this.means = [];
    }
    /**
     * Fit the imputer on X.
     * @param {any[]} X - Input data in array or sparse matrix format
     */
    Imputer.prototype.fit = function (X) {
        if (X === void 0) { X = null; }
        ops_1.validateMatrix2D(X);
        var _X = this.copy ? _.clone(X) : X;
        var rowLen = MathExtra_1.default.size(_X, 0);
        var colLen = MathExtra_1.default.size(_X, 1);
        var rowRange = MathExtra_1.default.range(0, rowLen);
        var colRange = MathExtra_1.default.range(0, colLen);
        if (this.strategy === 'mean') {
            if (this.axis === 0) {
                var colNumbers = _.map(colRange, function (col) {
                    return MathExtra_1.default.subset(_X, rowRange, [col]);
                });
                this.means = this.calcArrayMean(colNumbers, [
                    'flatten',
                    'filter',
                    'mean'
                ]);
            }
            else if (this.axis === 1) {
                var rowNumbers = _.map(rowRange, function (row) { return _.get(_X, "[" + row + "]"); });
                this.means = this.calcArrayMean(rowNumbers, ['filter', 'mean']);
            }
        }
        else {
            throw new Error("Unsupported strategy " + this.strategy + " was given");
        }
    };
    /**
     * Fit to data, then transform it.
     * @param {any[]} X - Input data in array or sparse matrix format
     * @returns {any[]}
     */
    Imputer.prototype.fit_transform = function (X) {
        if (X === void 0) { X = null; }
        ops_1.validateMatrix2D(X);
        var _X = _.clone(X);
        if (this.strategy === 'mean' && this.axis === 0) {
            // Mean column direction transform
            for (var row = 0; row < _.size(_X); row++) {
                for (var col = 0; col < _.size(_X[row]); col++) {
                    var value = _X[row][col];
                    _X[row][col] = value === this.missingValues ? this.means[row] : value;
                }
            }
        }
        else if (this.strategy === 'mean' && this.axis === 1) {
            // Mean row direction transform
            for (var row = 0; row < _.size(_X); row++) {
                for (var col = 0; col < _.size(_X[row]); col++) {
                    var value = _X[row][col];
                    _X[row][col] = value === this.missingValues ? this.means[col] : value;
                }
            }
        }
        else {
            throw new Error("Unknown transformation with strategy " + this.strategy + " and axis " + this.axis);
        }
        return _X;
    };
    return Imputer;
}());
exports.Imputer = Imputer;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSW1wdXRlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9saWIvcHJlcHJvY2Vzc2luZy9JbXB1dGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBLHdDQUE0QjtBQUM1Qiw4QkFBMEM7QUFFMUMsaUVBQXNDO0FBRXRDOzs7Ozs7Ozs7OztHQVdHO0FBQ0g7SUFRRTs7Ozs7O09BTUc7SUFDSCxpQkFBWSxFQU1YO1lBTEMscUJBQW9CLEVBQXBCLHlDQUFvQixFQUNwQixnQkFBaUIsRUFBakIsc0NBQWlCLEVBQ2pCLFlBQVEsRUFBUiw2QkFBUTtRQUNSLGVBQWU7UUFDZixZQUFZO1FBRFosZUFBZTtRQUNmLGlDQUFZO1FBTGQsaUJBYUM7UUFvRUQ7Ozs7Ozs7Ozs7O1dBV0c7UUFDSyxrQkFBYSxHQUFHLFVBQUMsTUFBVyxFQUFFLEtBQWU7WUFDbkQsNEJBQTRCO1lBQzVCLDRCQUE0QjtZQUM1QixPQUFBLENBQUMsQ0FBQyxNQUFNLENBQ04sS0FBSyxFQUNMLFVBQUMsTUFBTSxFQUFFLElBQVk7Z0JBQ25CLFFBQVEsSUFBSSxFQUFFO29CQUNaLEtBQUssU0FBUzt3QkFDWixPQUFPLENBQUMsQ0FBQyxHQUFHLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQztvQkFDbEMsS0FBSyxRQUFRO3dCQUNYLE9BQU8sQ0FBQyxDQUFDLEdBQUcsQ0FDVixNQUFNO3dCQUNOLHNDQUFzQzt3QkFDdEMsaUNBQWlDO3dCQUNqQyxVQUFDLEdBQVU7NEJBQ1QsT0FBTyxDQUFDLENBQUMsTUFBTSxDQUFDLEdBQUcsRUFBRSxVQUFBLENBQUMsSUFBSSxPQUFBLENBQUMsS0FBSyxLQUFJLENBQUMsYUFBYSxFQUF4QixDQUF3QixDQUFDLENBQUM7d0JBQ3RELENBQUMsQ0FDRixDQUFDO29CQUNKLEtBQUssTUFBTTt3QkFDVCxPQUFPLENBQUMsQ0FBQyxHQUFHLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FB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