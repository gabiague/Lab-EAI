"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var tf = __importStar(require("@tensorflow/tfjs"));
var lodash_1 = require("lodash");
var ops_1 = require("../ops");
var SQRT_2PI = Math.sqrt(Math.PI * 2);
/**
 * The Naive is an intuitive method that uses probabilistic of each attribute
 * being in each class to make a prediction. It uses Gaussian function to estimate
 * probability of a given class.
 *
 * @example
 * import { GaussianNB } from 'machinelearn/naive_bayes';
 *
 * const nb = new GaussianNB();
 * const X = [[1, 20], [2, 21], [3, 22], [4, 22]];
 * const y = [1, 0, 1, 0];
 * nb.fit({ X, y });
 * nb.predict({ X: [[1, 20]] }); // returns [ 1 ]
 *
 */
var GaussianNB = /** @class */ (function () {
    function GaussianNB() {
    }
    /**
     * @param X - array-like or sparse matrix of shape = [n_samples, n_features]
     * @param y - array-like, shape = [n_samples] or [n_samples, n_outputs]
     */
    GaussianNB.prototype.fit = function (X, y) {
        if (X === void 0) { X = null; }
        if (y === void 0) { y = null; }
        ops_1.validateFitInputs(X, y);
        var _a = this.fitModel(X, y), classCategories = _a.classCategories, mean = _a.mean, variance = _a.variance;
        this.classCategories = classCategories;
        this.mean = mean;
        this.variance = variance;
    };
    /**
     * @param X - array-like, shape = [n_samples, n_features]
     */
    GaussianNB.prototype.predict = function (X) {
        var _this = this;
        if (X === void 0) { X = null; }
        ops_1.validateMatrix2D(X);
        return X.map(function (x) { return _this.singlePredict(x); });
    };
    /**
     * Restore the model from saved states
     * @param modelState
     */
    GaussianNB.prototype.fromJSON = function (_a) {
        var _b = _a.classCategories, classCategories = _b === void 0 ? null : _b, _c = _a.mean, mean = _c === void 0 ? null : _c, _d = _a.variance, variance = _d === void 0 ? null : _d;
        this.classCategories = classCategories;
        this.mean = tf.tensor2d(mean);
        this.variance = tf.tensor2d(variance);
    };
    /**
     * Save the model's states
     */
    GaussianNB.prototype.toJSON = function () {
        return {
            classCategories: this.classCategories,
            mean: ops_1.reshape(__spread(this.mean.dataSync()), this.mean.shape),
            variance: ops_1.reshape(__spread(this.variance.dataSync()), this.variance.shape)
        };
    };
    /**
     * Make a single prediction
     *
     * @param  {ReadonlyArray<number>} X- values to predict in Matrix format
     * @returns T
     */
    GaussianNB.prototype.singlePredict = function (X) {
        var matrixX = tf.tensor1d(X, 'float32');
        var numFeatures = matrixX.shape[0];
        // Comparing input and summary shapes
        var summaryLength = this.mean.shape[1];
        if (numFeatures !== summaryLength) {
            throw new Error("Prediction input " + matrixX.shape[0] + " length must be equal or less than summary length " + summaryLength);
        }
        var meanValPow = matrixX
            .sub(this.mean)
            .pow(tf.scalar(2))
            .mul(tf.scalar(-1));
        var exponent = meanValPow
            .div(this.variance.mul(tf.scalar(2)))
            .exp();
        var innerDiv = tf.scalar(SQRT_2PI).mul(this.variance.sqrt());
        var probabilityArray = tf
            .scalar(1)
            .div(innerDiv)
            .mul(exponent);
        var selectionIndex = probabilityArray
            .prod(1)
            .argMax()
            .dataSync()[0];
        return this.classCategories[selectionIndex];
    };
    /**
     * Summarise the dataset per class using "probability density function"
     *
     * @param  {Type2DMatrix<number>} X
     * @param  {ReadonlyArray<T>} y
     * @returns InterfaceFitModel
     */
    GaussianNB.prototype.fitModel = function (X, y) {
        var classCategories = __spread(new Set(y)).sort();
        // Separates X by classes specified by y argument
        var separatedByCategory = lodash_1.zip(X, y).reduce(function (groups, _a) {
            var _b = __read(_a, 2), row = _b[0], category = _b[1];
            groups[category.toString()] = groups[category.toString()] || [];
            groups[category.toString()].push(row);
            return groups;
        }, {});
        var momentStack = classCategories.map(function (category) {
            var classFeatures = tf.tensor2d(separatedByCategory[category.toString()], null, 'float32');
            return tf.moments(classFeatures, [0]);
        });
        // For every class we have a mean and variance for each feature
        var mean = tf.stack(momentStack.map(function (m) { return m.mean; }));
        var variance = tf.stack(momentStack.map(function (m) { return m.variance; }));
        // TODO check for NaN or 0 variance
        // setTimeout(() => {
        //   if ([...variance.dataSync()].some(i => i === 0)) {
        //     console.error('No variance on one of the features. Errors may result.');
        //   }
        // }, 100);
        return {
            classCategories: classCategories,
            mean: mean,
            variance: variance
        };
    };
    return GaussianNB;
}());
exports.GaussianNB = GaussianNB;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2F1c3NpYW4uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvbGliL25haXZlX2JheWVzL2dhdXNzaWFuLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsbURBQXVDO0FBQ3ZDLGlDQUE2QjtBQUM3Qiw4QkFBc0U7QUFHdEUsSUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDO0FBRXhDOzs7Ozs7Ozs7Ozs7OztHQWNHO0FBQ0g7SUFBQTtJQXVMQSxDQUFDO0lBakxDOzs7T0FHRztJQUNJLHdCQUFHLEdBQVYsVUFBVyxDQUE4QixFQUFFLENBQXlCO1FBQXpELGtCQUFBLEVBQUEsUUFBOEI7UUFBRSxrQkFBQSxFQUFBLFFBQXlCO1FBQ2xFLHVCQUFpQixDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUNsQixJQUFBLHdCQUF5RCxFQUF2RCxvQ0FBZSxFQUFFLGNBQUksRUFBRSxzQkFBUSxDQUF5QjtRQUNoRSxJQUFJLENBQUMsZUFBZSxHQUFHLGVBQWUsQ0FBQztRQUN2QyxJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztRQUNqQixJQUFJLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQztJQUMzQixDQUFDO0lBRUQ7O09BRUc7SUFDSSw0QkFBTyxHQUFkLFVBQWUsQ0FBOEI7UUFBN0MsaUJBR0M7UUFIYyxrQkFBQSxFQUFBLFFBQThCO1FBQzNDLHNCQUFnQixDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3BCLE9BQU8sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxVQUFDLENBQUMsSUFBUSxPQUFBLEtBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLEVBQXJCLENBQXFCLENBQUMsQ0FBQztJQUNoRCxDQUFDO0lBRUQ7OztPQUdHO0lBQ0ksNkJBQVEsR0FBZixVQUFnQixFQWlCZjtZQWhCQyx1QkFB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