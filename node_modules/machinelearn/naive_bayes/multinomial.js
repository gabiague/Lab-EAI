"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var tf = __importStar(require("@tensorflow/tfjs"));
var lodash_1 = require("lodash");
var ops_1 = require("../ops");
/**
 * Multinomial naive bayes machine learning algorithm
 *
 * The Naive is an intuitive method that uses probabilistic of each attribute
 * being in each class to make a prediction. It uses multinomial function to estimate
 * probability of a given class.
 *
 * @example
 * import { MultinomialNB } from 'machinelearn/naive_bayes';
 *
 * const nb = new MultinomialNB();
 * const X = [[1, 20], [2, 21], [3, 22], [4, 22]];
 * const y = [1, 0, 1, 0];
 * nb.fit({ X, y });
 * nb.predict({ X: [[1, 20]] }); // returns [ 1 ]
 *
 */
var MultinomialNB = /** @class */ (function () {
    function MultinomialNB() {
        this.alpha = 1;
    }
    // constructor(private readonly alpha: number = 1) {}
    /**
     * Fit date to build Gaussian Distribution summary
     *
     * @param  {Type2DMatrix<number>} X - training values
     * @param  {ReadonlyArray<T>} y - target values
     * @returns void
     */
    MultinomialNB.prototype.fit = function (X, y) {
        if (X === void 0) { X = null; }
        if (y === void 0) { y = null; }
        ops_1.validateFitInputs(X, y);
        var _a = this.fitModel(X, y), classCategories = _a.classCategories, multinomialDist = _a.multinomialDist, priorProbability = _a.priorProbability;
        this.classCategories = classCategories;
        this.multinomialDist = multinomialDist;
        this.priorProbability = priorProbability;
    };
    /**
     * Predict multiple rows
     *
     * @param  {Type2DMatrix<number>} X - values to predict in Matrix format
     * @returns T
     */
    MultinomialNB.prototype.predict = function (X) {
        var _this = this;
        if (X === void 0) { X = null; }
        ops_1.validateMatrix2D(X);
        if (lodash_1.isEmpty(this.classCategories) ||
            lodash_1.isEmpty(this.multinomialDist) ||
            lodash_1.isEmpty(this.priorProbability)) {
            throw new TypeError('You should fit the model first before running the predict!');
        }
        return X.map(function (x) { return _this.singlePredict(x); });
    };
    /**
     * Returns a model checkpoint
     *
     * @returns InterfaceFitModelAsArray
     */
    MultinomialNB.prototype.toJSON = function () {
        return {
            classCategories: Array.from(this.classCategories),
            priorProbability: Array.from(this.priorProbability.dataSync()),
            multinomialDist: ops_1.reshape(Array.from(this.multinomialDist.dataSync()), this.multinomialDist.shape)
        };
    };
    /**
     * Restore the model from states
     * @param multinomialDist - Multinomial distribution values over classes
     * @param priorProbability - Learned prior class probabilities
     * @param classCategories - List of unique class categories
     */
    MultinomialNB.prototype.fromJSON = function (_a) {
        var _b = _a === void 0 ? {
            multinomialDist: null,
            priorProbability: null,
            classCategories: null
        } : _a, _c = _b.multinomialDist, multinomialDist = _c === void 0 ? null : _c, _d = _b.priorProbability, priorProbability = _d === void 0 ? null : _d, _e = _b.classCategories, classCategories = _e === void 0 ? null : _e;
        this.classCategories = classCategories;
        this.priorProbability = tf.tensor1d(priorProbability);
        this.multinomialDist = tf.tensor2d(multinomialDist);
    };
    /**
     * Make a prediction
     *
     * @param  {ReadonlyArray<number>} predictRow
     * @returns T
     */
    MultinomialNB.prototype.singlePredict = function (predictRow) {
        var matrixX = tf.tensor1d(predictRow, 'float32');
        var numFeatures = matrixX.shape[0];
        var summaryLength = this.multinomialDist.shape[1];
        // Comparing input and summary shapes
        if (numFeatures !== summaryLength) {
            throw new Error("Prediction input " + matrixX.shape[0] + " length must be equal or less than summary length " + summaryLength);
        }
        // log is important to use different multinomial formula instead of the factorial formula
        // The multinomial naive Bayes classifier becomes a linear
        // classifier when expressed in log-space
        // const priorProbability = Math.log(1 / classCount);
        var fitProbabilites = this.multinomialDist
            .clone()
            .mul(matrixX);
        // sum(1) is summing columns
        var allProbabilities = fitProbabilites
            .sum(1)
            .add(this.priorProbability);
        var selectionIndex = allProbabilities.argMax().dataSync()[0];
        allProbabilities.dispose();
        return this.classCategories[selectionIndex];
    };
    /**
     * Summarise the dataset per class
     *
     * @param  {Type2DMatrix<number>} X - input distribution
     * @param  {ReadonlyArray<T>} y - classes to train
     */
    MultinomialNB.prototype.fitModel = function (X, y) {
        var classCounts = lodash_1.countBy(y);
        var classCategories = Array.from(new Set(y));
        var numFeatures = X[0].length;
        var separatedByCategory = lodash_1.zip(X, y).reduce(function (groups, _a) {
            var _b = __read(_a, 2), row = _b[0], category = _b[1];
            if (!(category.toString() in groups)) {
                groups[category.toString()] = [];
            }
            groups[category.toString()].push(tf.tensor1d(row, 'float32'));
            return groups;
        }, {});
        var frequencySumByClass = tf.stack(classCategories.map(function (category) {
            return tf.addN(separatedByCategory[category.toString()]);
        }));
        var productReducedRow = Array.from(frequencySumByClass.sum(1).dataSync());
        // A class's prior may be calculated by assuming equiprobable classes
        // (i.e., priors = (number of samples in the class) / (total number of samples))
        var priorProbability = tf
            .tensor1d(classCategories.map(function (c) { return classCounts[c.toString()] / y.length; }), 'float32')
            .log();
        // log transform to use linear multinomial forumla
        var multinomialDist = frequencySumByClass
            .add(tf.scalar(this.alpha))
            .div(tf
            .tensor2d(productReducedRow, [frequencySumByClass.shape[0], 1], 'float32')
            .add(tf.scalar(numFeatures * this.alpha)))
            .log();
        return {
            classCategories: classCategories,
            multinomialDist: multinomialDist,
            priorProbability: priorProbability
        };
    };
    return MultinomialNB;
}());
exports.MultinomialNB = MultinomialNB;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibXVsdGlub21pYWwuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvbGliL25haXZlX2JheWVzL211bHRpbm9taWFsLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxtREFBdUM7QUFDdkMsaUNBQStDO0FBQy9DLDhCQUFzRTtBQUd0RTs7Ozs7Ozs7Ozs7Ozs7OztHQWdCRztBQUNIO0lBQUE7UUFjVSxVQUFLLEdBQVcsQ0FBQyxDQUFDO0lBd001QixDQUFDO0lBdE1DLHFEQUFxRDtJQUVyRDs7Ozs7O09BTUc7SUFDSSwyQkFBRyxHQUFWLFVBQVcsQ0FBOEIsRUFBRSxDQUF5QjtRQUF6RCxrQkFBQSxFQUFBLFFBQThCO1FBQUUsa0JBQUEsRUFBQSxRQUF5QjtRQUNsRSx1QkFBaUIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDbEIsSUFBQSx3QkFJaUIsRUFIckIsb0NBQWUsRUFDZixvQ0FBZSxFQUNmLHNDQUFnQixDQUNNO1FBQ3hCLElBQUksQ0FBQyxlQUFlLEdBQUcsZUFBc0IsQ0FBQztRQUM5QyxJQUFJLENBQUMsZUFBZSxHQUFHLGVBQWUsQ0FBQztRQUN2QyxJQUFJLENBQUMsZ0JBQWdCLEdBQUcsZ0JBQWdCLENBQUM7SUFDM0MsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0ksK0JBQU8sR0FBZCxVQUFlLENBQThCO1FBQTdDLGlCQVlDO1FBWmMsa0JBQUEsRUFBQSxRQUE4QjtRQUMzQyxzQkFBZ0IsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNwQixJQUNFLGdCQUFPLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQztZQUM3QixnQkFBTyxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUM7WUFDN0IsZ0JBQU8sQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsRUFDOUI7WUFDQSxNQUFNLElBQUksU0FBUyxDQUNqQiw0REFBNEQsQ0FDN0QsQ0FBQztTQUNIO1FBQ0QsT0FBTyxD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