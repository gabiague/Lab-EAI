"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var tf = __importStar(require("@tensorflow/tfjs"));
var lodash_1 = require("lodash");
var ops_1 = require("../ops");
/**
 * Mean absolute error regression loss
 *
 * @example
 * import { mean_absolute_error } from 'machinelearn/metrics';
 * const y_true = [3, -0.5, 2, 7]
 * const y_pred = [2.5, 0.0, 2, 8]
 * mean_absolute_error(y_true, y_pred); // 0.5
 *
 * @param y_true - Ground truth (correct) target values.
 * @param y_pred - Estimated target values.
 * @param sample_weight - Sample weights.
 */
function mean_absolute_error(y_true, y_pred, 
// Options
_a) {
    if (y_true === void 0) { y_true = null; }
    if (y_pred === void 0) { y_pred = null; }
    var _b = (_a === void 0 ? {
        sample_weight: null
    } : _a).sample_weight, sample_weight = _b === void 0 ? null : _b;
    var yTrueShape = ops_1.inferShape(y_true);
    var yPredShape = ops_1.inferShape(y_pred);
    // Validation 1: empty array check
    if (yTrueShape[0] === 0 || yPredShape[0] === 0) {
        throw new TypeError("y_true " + JSON.stringify(y_true) + " and y_pred " + JSON.stringify(y_pred) + " cannot be empty");
    }
    if (sample_weight !== null) {
        var weightShape = ops_1.inferShape(sample_weight);
        if (!lodash_1.isEqual(yTrueShape, weightShape)) {
            throw new TypeError("The shape of " + JSON.stringify(weightShape) + "\n       does not match with the sample size " + JSON.stringify(yTrueShape));
        }
    }
    // Validation 2: Same shape
    if (!lodash_1.isEqual(yTrueShape, yPredShape)) {
        throw new TypeError("The shapes of y_true " + JSON.stringify(yTrueShape) + " and y_pred " + JSON.stringify(yPredShape) + " should be equal");
    }
    /**
     * Compute the weighted average along the specified axis.
     *
     * @example
     * average(tf.tensor1d([1, 2, 3, 4])).dataSync(); // [2.5]
     *
     * @param X - Array containing data to be averaged. If a is not an array, a conversion is attempted.
     * @param axis - Axis along which to average a. If None, averaging is done over the flattened array.
     * @param w - An array of weights associated with the values in a. Each value in a contributes to the average according to its associated weight. The weights array can either be 1-D (in which case its length must be the size of a along the given axis) or of the same shape as a. If weights=None, then all data in a are assumed to have a weight equal to one.
     * @ignore
     */
    var average = function (X, axis, w) {
        if (axis === void 0) { axis = 0; }
        if (w === void 0) { w = null; }
        if (w !== null) {
            var wgt = tf.tensor1d(w);
            var scl = wgt.sum(axis);
            return tf
                .mul(X, wgt)
                .sum(axis)
                .div(scl);
        }
        else {
            var sample_size = X.size;
            return tf.div(tf.sum(X), tf.scalar(sample_size));
        }
    };
    var output_errors = tf.abs(tf.sub(y_true, y_pred));
    var avg_errors = average(output_errors, 0, sample_weight);
    return average(avg_errors).dataSync()[0];
}
exports.mean_absolute_error = mean_absolute_error;
/**
 * Mean squared error regression loss
 *
 * @example
 * import { mean_squared_error } from 'machinelearn/metrics';
 *
 * const y_true = [3, -0.5, 2, 7];
 * const y_pred = [2.5, 0.0, 2, 8];
 *
 * console.log(mean_squared_error(y_true, y_pred));
 * // result: 0.375
 *
 * const y_true1 = [[0.5, 1], [-1, 1], [7, -6]];
 * const y_pred1 = [[0, 2], [-1, 2], [8, -5]];
 *
 * console.log(mean_squared_error(y_true1, y_pred1));
 * // result: 0.7083333134651184
 *
 * @param y_true - Ground truth (correct) target values.
 * @param y_pred - Estimated target values.
 */
function mean_squared_error(y_true, y_pred, 
// Options
_a) {
    if (y_true === void 0) { y_true = null; }
    if (y_pred === void 0) { y_pred = null; }
    var 
    /**
     * Sample weights.
     */
    _b = (_a === void 0 ? {
        sample_weight: null
    } : _a).sample_weight, 
    /**
     * Sample weights.
     */
    sample_weight = _b === void 0 ? null : _b;
    var yTrueShape = ops_1.inferShape(y_true);
    var yPredShape = ops_1.inferShape(y_pred);
    // Validation 1: empty array check
    if (yTrueShape[0] === 0 || yPredShape[0] === 0) {
        throw new TypeError("y_true " + JSON.stringify(y_true) + " and y_pred " + JSON.stringify(y_pred) + " cannot be empty");
    }
    // Validation 2: Same shape
    if (!lodash_1.isEqual(yTrueShape, yPredShape)) {
        throw new TypeError("Shapes of y_true " + JSON.stringify(yTrueShape) + " and y_pred " + JSON.stringify(yPredShape) + " should be equal");
    }
    return tf.losses
        .meanSquaredError(y_true, y_pred, sample_weight)
        .dataSync()[0];
}
exports.mean_squared_error = mean_squared_error;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVncmVzc2lvbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9saWIvbWV0cmljcy9yZWdyZXNzaW9uLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBLG1EQUF1QztBQUN2QyxpQ0FBaUM7QUFDakMsOEJBQW9DO0FBR3BDOzs7Ozs7Ozs7Ozs7R0FZRztBQUNILDZCQUNFLE1BQTBELEVBQzFELE1BQTBEO0FBQzFELFVBQVU7QUFDVixFQU1DO0lBVEQsdUJBQUEsRUFBQSxhQUEwRDtJQUMxRCx1QkFBQSxFQUFBLGFBQTBEO1FBR3hEOzt5QkFBb0IsRUFBcEIseUNBQW9CO0lBT3RCLElBQU0sVUFBVSxHQUFHLGdCQUFVLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDdEMsSUFBTSxVQUFVLEdBQUcsZ0JBQVUsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUV0QyxrQ0FBa0M7SUFDbEMsSUFBSSxVQUFVLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxJQUFJLFVBQVUsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLEVBQUU7UUFDOUMsTUFBTSxJQUFJLFNBQVMsQ0FDakIsWUFBVSxJQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxvQkFBZSxJQUFJLENBQUMsU0FBUyxDQUMzRCxNQUFNLENBQ1AscUJBQWtCLENBQ3BCLENBQUM7S0FDSDtJQUVELElBQUksYUFBYSxLQUFLLElBQUksRUFBRTtRQUMxQixJQUFNLFdBQVcsR0FBRyxnQkFBVSxDQUFDLGFBQWEsQ0FBQyxDQUFDO1FBQzlDLElBQUksQ0FBQyxnQkFBTyxDQUFDLFVBQVUsRUFBRSxXQUFXLENBQUMsRUFBRTtZQUNyQyxNQUFNLElBQUksU0FBUyxDQUFDLGtCQUFnQixJQUFJLENBQUMsU0FBUyxDQUFDLFdBQVcsQ0FBQyxxREFDeEIsSUFBSSxDQUFDLFNBQVMsQ0FBQyxVQUFVLENBQUcsQ0FBQyxDQUFDO1NBQ3RFO0tBQ0Y7SUFFRCwyQkFBMkI7SUFDM0IsSUFB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