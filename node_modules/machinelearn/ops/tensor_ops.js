"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var tf = __importStar(require("@tensorflow/tfjs"));
var lodash_1 = require("lodash");
/**
 * Infers shape of a tensor using TF
 *
 * @example
 * inferShape(1) // exception
 * inferShape(true) // exception
 * inferShape([1, 2]) // [2]
 * inferShape([[1, 2], [3, 4]]) // [2, 2]
 *
 * @param X
 * @ignore
 */
function inferShape(X) {
    return tf.tensor(X).shape;
}
exports.inferShape = inferShape;
/**
 * Validates the input matrix's types with the targetted types.
 * Specified target types must be one of https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof#Description
 *
 * @example
 * validateMatrixType([['z', 'z']],['string']); // no errors
 * validateMatrixType([['z', 'z']],['test']); // error: Input matrix type of ["string"] does not match with the target types ["test"]
 *
 * @param X - The input matrix
 * @param targetTypes - Target matrix types
 * @ignore
 */
function validateMatrixType(X, targetTypes) {
    var flatX = lodash_1.flattenDeep(X);
    var xTypes = lodash_1.uniq(flatX.map(function (x) { return typeof x; }));
    var sortedXTypes = lodash_1.sortBy(xTypes, function (x) { return x; });
    var sortedTargetTypes = lodash_1.sortBy(targetTypes, function (x) { return x; });
    if (!lodash_1.isEqual(sortedXTypes, sortedTargetTypes)) {
        throw new TypeError("Input matrix type of " + JSON.stringify(sortedXTypes) + " does not match with the target types " + JSON.stringify(sortedTargetTypes));
    }
}
exports.validateMatrixType = validateMatrixType;
/**
 * Validate typical X and y train data and check they are 2D and 1D shaped respectively
 *
 * @example
 * validateTrainInputs([ [1, 2], [3, 4] ], [ 1, 2 ]) // No errors
 * validateTrainInputs([ [[1, 2], [3, 3]], [[1, 2], [3, 3]] ], [ 1, 2 ]) // Error: The matrix is not 1D shaped: [ [[1, 2], [3, 3]], [[1, 2], [3, 3]] ] of [2, 2, 2]
 *
 * @param X
 * @param y
 * @ignore
 */
function validateFitInputs(X, y) {
    if ((Array.isArray(X) && X.length === 0) ||
        (Array.isArray(y) && y.length === 0)) {
        throw new Error('Input cannot be an empty array');
    }
    // Check X is always a matrix
    var sampleShape = validateMatrix2D(X);
    // Check y is always a vector
    var targetShape = validateMatrix1D(y);
    if (sampleShape[0] !== targetShape[0]) {
        throw new TypeError("Number of labels=" + targetShape[0] + " does not math number of samples=" + sampleShape[0]);
    }
}
exports.validateFitInputs = validateFitInputs;
/**
 * Validate the matrix is 1D shaped by checking the shape's length is exactly  1
 * @param X
 * @ignore
 */
function validateMatrix1D(X) {
    var shape = inferShape(X);
    if (shape.length !== 1 || shape[0] === 0) {
        throw new TypeError("The matrix is not 1D shaped: " + JSON.stringify(X) + " of " + JSON.stringify(shape));
    }
    return shape;
}
exports.validateMatrix1D = validateMatrix1D;
/**
 * Validate the matrix is 2D shaped by checking the shape's length is exactly 2
 * @param X - An input array
 * @ignore
 */
function validateMatrix2D(X) {
    var shape = inferShape(X);
    if (shape.length !== 2) {
        throw new TypeError("The matrix is not 2D shaped: " + JSON.stringify(X) + " of " + JSON.stringify(shape));
    }
    return shape;
}
exports.validateMatrix2D = validateMatrix2D;
/**
 * Reshapes any size of array into a new shape.
 *
 * The code was borrowed from math.js (https://github.com/josdejong/mathjs/blob/5750a1845442946d236822505c607a522be23474/src/utils/array.js#L258),
 * which enables us to use a specific method from Math.js instead of installing an entire library.
 *
 * TF.js has implemented an efficient way to return raw values from its Tensor implementation that always returns a 1D array,
 * which is not ideal in situations where we need a return value with correct shapes.
 *
 * Please check out https://github.com/tensorflow/tfjs/issues/939 for more information
 *
 * @example
 * reshape([1, 2, 3, 4, 5, 6], [2, 3]); // [[1, 2, 3], [4, 5, 6]]
 * reshape([1, 2, 3, 4, 5, 6], [2, 3, 1]); // [[[1], [2], [3]], [[4], [5], [6]]]
 *
 * @param array - Target array
 * @param sizes - New array shape to resize into
 * @ignore
 */
function reshape(array, sizes) {
    // Initial validations
    if (!Array.isArray(array)) {
        throw new TypeError('The input array must be an array!');
    }
    if (!Array.isArray(sizes)) {
        throw new TypeError('The sizes must be an array!');
    }
    var deepFlatArray = lodash_1.flattenDeep(array);
    // If the reshaping is to single dimensional
    if (sizes.length === 1 && deepFlatArray.length === sizes[0]) {
        return deepFlatArray;
    }
    else if (sizes.length === 1 && deepFlatArray.length !== sizes[0]) {
        throw new TypeError("Target array shape [" + deepFlatArray.length + "] cannot be reshaped into " + sizes);
    }
    // testing if there are enough elements for the requested shape
    var tmpArray = deepFlatArray;
    var tmpArray2;
    // for each dimensions starting by the last one and ignoring the first one
    for (var sizeIndex = sizes.length - 1; sizeIndex > 0; sizeIndex--) {
        var size = sizes[sizeIndex];
        tmpArray2 = [];
        // aggregate the elements of the current tmpArray in elements of the requested size
        var length_1 = tmpArray.length / size;
        for (var i = 0; i < length_1; i++) {
            tmpArray2.push(tmpArray.slice(i * size, (i + 1) * size));
        }
        // set it as the new tmpArray for the next loop turn or for return
        tmpArray = tmpArray2;
    }
    return tmpArray;
}
exports.reshape = reshape;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGVuc29yX29wcy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9saWIvb3BzL3RlbnNvcl9vcHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUEsbURBQXVDO0FBQ3ZDLGlDQUE0RDtBQUc1RDs7Ozs7Ozs7Ozs7R0FXRztBQUNILG9CQUEyQixDQUFrQjtJQUMzQyxPQUFPLEVBQUUsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDO0FBQzVCLENBQUM7QUFGRCxnQ0FFQztBQUVEOzs7Ozs7Ozs7OztHQVdHO0FBQ0gsNEJBQ0UsQ0FBa0IsRUFDbEIsV0FBcUI7SUFFckIsSUFBTSxLQUFLLEdBQUcsb0JBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUM3QixJQUFNLE1BQU0sR0FBRyxhQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxVQUFBLENBQUMsSUFBSSxPQUFBLE9BQU8sQ0FBQyxFQUFSLENBQVEsQ0FBQyxDQUFDLENBQUM7SUFDOUMsSUFBTSxZQUFZLEdBQUcsZUFBTSxDQUFDLE1BQU0sRUFBRSxVQUFBLENBQUMsSUFBSSxPQUFBLENBQUMsRUFBRCxDQUFDLENBQUMsQ0FBQztJQUM1QyxJQUFNLGlCQUFpQixHQUFHLGVBQU0sQ0FBQyxXQUFXLEVBQUUsVUFBQSxDQUFDLElBQUksT0FBQSxDQUFDLEVBQUQsQ0FBQyxDQUFDLENBQUM7SUFDdEQsSUFBSSxDQUFDLGdCQUFPLENBQUMsWUFBWSxFQUFFLGlCQUFpQixDQUFDLEVBQUU7UUFDN0MsTUFBTSxJQUFJLFNBQVMsQ0FDakIsMEJBQXdCLElBQUksQ0FBQyxTQUFTLENBQ3BDLFlBQVksQ0FDYiw4Q0FBeUMsSUFBSSxDQUFDLFNBQVMsQ0FDdEQsaUJBQWlCLENBQ2hCLENBQ0osQ0FBQztLQUNIO0FBQ0gsQ0FBQztBQWpCRCxnREFpQkM7QUFFRDs7Ozs7Ozs7OztHQVVHO0FBQ0gsMkJBQ0UsQ0FBb0IsRUFDcEIsQ0FBb0I7SUFF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