"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var _ = __importStar(require("lodash"));
var sw = __importStar(require("stopword"));
var ops_1 = require("../ops");
var nlp_1 = require("../utils/nlp");
var stop_words_1 = require("./stop_words");
/**
 * The CountVectorizer provides a simple way to both tokenize a collection
 * of text documents and build a vocabulary of known words, but also
 * to encode new documents using that vocabulary.
 *
 * @example
 * import { CountVectorizer } from 'machinelearn/feature_extraction';
 *
 * const corpus = ['deep learning ian good fellow learning jason shin shin', 'yoshua bengio'];
 * const vocabCounts = cv.fit_transform(corpus);
 * console.log(vocabCounts); // [ [ 0, 1, 1, 1, 1, 1, 2, 2, 0 ], [ 1, 0, 0, 0, 0, 0, 0, 0, 1 ] ]
 * console.log(cv.vocabulary); // { bengio: 0, deep: 1, fellow: 2, good: 3, ian: 4, jason: 5, learning: 6, shin: 7, yoshua: 8 }
 * console.log(cv.getFeatureNames()); // [ 'bengio', 'deep', 'fellow', 'good', 'ian', 'jason', 'learning', 'shin', 'yoshua' ]
 *
 * const newVocabCounts = cv.transform(['ian good fellow jason duuog']);
 * console.log(newVocabCounts); // [ [ 0, 0, 1, 1, 1, 1, 0, 0, 0 ] ]
 */
var CountVectorizer = /** @class */ (function () {
    function CountVectorizer() {
        this.vocabulary = {};
    }
    /**
     * Learn a vocabulary dictionary of all tokens in the raw documents.
     * @param {string[]} doc - An array of strings
     * @returns {CountVectorizer}
     */
    CountVectorizer.prototype.fit = function (doc) {
        if (doc === void 0) { doc = null; }
        ops_1.validateMatrix1D(doc);
        this.fit_transform(doc);
        return this;
    };
    /**
     * fit transform applies
     * @param {string[]} doc - An array of strings
     * @returns {number[][]}
     */
    CountVectorizer.prototype.fit_transform = function (doc) {
        if (doc === void 0) { doc = null; }
        ops_1.validateMatrix1D(doc);
        var _a = this.buildVocabulary(doc), internalVocabulary = _a.internalVocabulary, pubVocabulary = _a.pubVocabulary;
        this.vocabulary = pubVocabulary;
        this.internalVocabulary = internalVocabulary;
        return this.countVocab(doc);
    };
    /**
     * Transform documents to document-term matrix.
     * Extract token counts out of raw text documents using the vocabulary
     * fitted with fit or the one provided to the constructor.
     * @param {string[]} doc - An array of strings
     * @returns {number[][]}
     */
    CountVectorizer.prototype.transform = function (doc) {
        if (doc === void 0) { doc = null; }
        ops_1.validateMatrix1D(doc);
        return this.countVocab(doc);
    };
    /**
     * Array mapping from feature integer indices to feature name
     * @returns {Object}
     */
    CountVectorizer.prototype.getFeatureNames = function () {
        if (!this.internalVocabulary) {
            throw new Error('You must fit a document first before you can retrieve the feature names!');
        }
        return this.internalVocabulary;
    };
    /**
     * Build a tokenizer/vectorizer
     * @returns {(x: string) => string[]}
     */
    CountVectorizer.prototype.buildAnalyzer = function () {
        var _this = this;
        return function (x) { return _this.preprocess(x, { removeSW: true }); };
    };
    /**
     * Calculates list of vocabularies in the entire document and come up with
     * vocab: index pairs
     * @param doc
     */
    CountVectorizer.prototype.buildVocabulary = function (doc) {
        var analyze = this.buildAnalyzer();
        var processedDoc = _.flowRight(function (d) { return _.uniq(d); }, function (d) { return _.sortBy(d, function (z) { return z; }); }, function (d) { return _.flatten(d); }, function (d) { return _.map(d, function (text) { return analyze(text); }); })(doc);
        var pubVocabulary = _.reduce(processedDoc, function (sum, val, index) {
            return _.set(sum, val, index);
        }, {});
        return {
            internalVocabulary: processedDoc,
            pubVocabulary: pubVocabulary
        };
    };
    /**
     * @ignore
     * Counting number of vocab occurences in the current token of a sentence
     * ['yoshua', 'bengio', 'deep', 'learning'] = vocabulary
     * ['yohua', 'bengio'] => tokens
     * results in
     * [1, 1, 0, 0]
     * @param doc
     */
    CountVectorizer.prototype.countVocab = function (doc) {
        var _this = this;
        var analyze = this.buildAnalyzer();
        // 1. Reducing the doc
        return _.reduce(doc, function (sum, text) {
            var tokens = analyze(text);
            // 2. Looping each vocab for counting
            var sentenceCounted = _.reduce(_this.internalVocabulary, function (sentenceCounts, vocab) {
                // 3. Getting number of occurences of vocab in each tokens (tokens of a sentence)
                var vocabCount = _.reduce(tokens, function (tokenCounts, t) {
                    if (_.isEqual(t, vocab)) {
                        return tokenCounts + 1;
                    }
                    else {
                        return tokenCounts;
                    }
                }, 0);
                return _.concat(sentenceCounts, [vocabCount]);
            }, []);
            return _.concat(sum, [sentenceCounted]);
        }, []);
    };
    /**
     * @ignore
     * preprocess a line of text by applying
     * 1) tokenization
     * 2) removing stopwords
     * @param text
     * @param {any} removeSW
     * @returns {any}
     */
    CountVectorizer.prototype.preprocess = function (text, _a) {
        var _b = _a.removeSW, removeSW = _b === void 0 ? false : _b;
        var tokenizer = new nlp_1.WordTokenizer();
        return _.flowRight(function (x) { return tokenizer.tokenize(x); }, function (x) { return x.join(' '); }, 
        // TODO: Somehow it's removing too many words??!!
        function (x) {
            return removeSW ? sw.removeStopwords(x, stop_words_1.ENGLISH_STOP_WORDS) : x;
        }, function (x) { return x.split(' '); })(text);
    };
    return CountVectorizer;
}());
exports.CountVectorizer = CountVectorizer;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGV4dC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9saWIvZmVhdHVyZV9leHRyYWN0aW9uL3RleHQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUEsd0NBQTRCO0FBQzVCLDJDQUErQjtBQUMvQiw4QkFBMEM7QUFFMUMsb0NBQTZDO0FBQzdDLDJDQUFrRDtBQUVsRDs7Ozs7Ozs7Ozs7Ozs7OztHQWdCRztBQUNIO0lBQUE7UUFDUyxlQUFVLEdBQVcsRUFBRSxDQUFDO0lBMkpqQyxDQUFDO0lBdkpDOzs7O09BSUc7SUFDSSw2QkFBRyxHQUFWLFVBQVcsR0FBZ0M7UUFBaEMsb0JBQUEsRUFBQSxVQUFnQztRQUN6QyxzQkFBZ0IsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUN0QixJQUFJLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ3hCLE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQztJQUVEOzs7O09BSUc7SUFDSSx1Q0FBYSxHQUFwQixVQUFxQixHQUFnQztRQUFoQyxvQkFBQSxFQUFBLFVBQWdDO1FBQ25ELHNCQUFnQixDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ2hCLElBQUEsOEJBQWlFLEVBQS9ELDBDQUFrQixFQUFFLGdDQUFhLENBQStCO1FBQ3hFLElBQUksQ0FBQyxVQUFVLEdBQUcsYUFBYSxDQUFDO1FBQ2hDLElBQUksQ0FBQyxrQkFBa0IsR0FBRyxrQkFBa0IsQ0FBQztRQUM3QyxPQUFPLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDOUIsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNJLG1DQUFTLEdBQWhCLFVBQWlCLEdBQWdDO1FBQWhDLG9CQUFBLEVBQUEsVUFBZ0M7UUFDL0Msc0JBQWdCLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDdEIsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQzlCLENBQUM7SUFFRDs7O09BR0c7SUFDSSx5Q0FB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