import * as _ from 'lodash';
import * as Random from 'random-js';
import { validateMatrix2D } from '../ops';
import math from '../utils/MathExtra';
/**
 * K-Means clustering
 *
 * @example
 * import { KMeans } from 'machinelearn/cluster';
 *
 * const kmean = new KMeans({ k: 2 });
 * const clusters = kmean.fit([[1, 2], [1, 4], [1, 0], [4, 2], [4, 4], [4, 0]]);
 *
 * const result = kmean.predict([[0, 0], [4, 4]]);
 * // results in: [0, 1]
 */
export class KMeans {
    /**
     *
     * @param distance - Choice of distance method. Defaulting to euclidean
     * @param k - Number of clusters
     * @param maxIteration - Relative tolerance with regards to inertia to declare convergence
     * @param randomState - Random state value for sorting centroids during the getInitialCentroid phase
     */
    constructor({ distance = 'euclidean', k = 3, maxIteration = 300, randomState = 0 } = {
        distance: 'euclidean',
        k: 3,
        maxIteration: 300,
        randomState: 0
    }) {
        this.k = k;
        // Assigning a distance method
        const distanceType = distance;
        switch (distanceType) {
            case 'euclidean':
                this.distance = math.euclideanDistance;
                break;
            case 'manhattan':
                this.distance = math.manhattanDistance;
                break;
            default:
                throw new Error(`Unknown distance type ${distanceType}`);
        }
        this.randomState = randomState;
        this.maxIteration = maxIteration;
        this.centroids = [];
    }
    /**
     * Compute k-means clustering.
     * @param {any} X - array-like or sparse matrix of shape = [n_samples, n_features]
     * @returns {{centroids: number[]; clusters: number[]}}
     */
    fit(X = null) {
        validateMatrix2D(X);
        this.assignment = new Array(_.size(X));
        this.centroids = this.getInitialCentroids(X, this.k);
        this.clusters = new Array(this.k);
        // Flag to check the convergence
        let movement = true;
        // Looping only within the maxIteration boundary
        for (let iter = 0; iter < this.maxIteration && movement; iter++) {
            // find the distance between the point and cluster; choose the nearest centroid
            _.forEach(X, (data, i) => {
                this.assignment[i] = this.getClosestCentroids(data, this.centroids, this.distance);
            });
            // Flag set to false; giving opportunity to stop the loop upon the covergence
            movement = false;
            // Updating the location of each centroid
            for (let j = 0; j < this.k; j++) {
                const assigned = [];
                for (let i = 0; i < this.assignment.length; i++) {
                    if (this.assignment[i] === j) {
                        assigned.push(X[i]);
                    }
                }
                if (!assigned.length) {
                    continue;
                }
                // Getting the original data point
                // TODO: Fix any type
                const centroid = this.centroids[j];
                const newCentroid = new Array(centroid.length);
                for (let g = 0; g < centroid.length; g++) {
                    let sum = 0;
                    for (let i = 0; i < assigned.length; i++) {
                        sum += assigned[i][g];
                    }
                    newCentroid[g] = sum / assigned.length;
                    // Does not converge yet
                    if (newCentroid[g] !== centroid[g]) {
                        movement = true;
                    }
                }
                this.centroids[j] = newCentroid;
                this.clusters[j] = assigned;
            }
        }
    }
    /**
     * Predicts the cluster index with the given X
     * @param {any} X - array-like or sparse matrix of shape = [n_samples, n_features]
     * @returns {number[]}
     */
    predict(X = null) {
        validateMatrix2D(X);
        return _.map(X, data => {
            return this.getClosestCentroids(data, this.centroids, this.distance);
        });
    }
    /**
     * Get the model details in JSON format
     * @returns {{k: number; clusters: number[]; centroids: number[]}}
     */
    toJSON() {
        return {
            centroids: this.centroids,
            clusters: this.clusters,
            k: this.k
        };
    }
    /**
     * Restores the model from checkpoints
     * @param {number} k
     * @param {number[]} clusters
     * @param {number[]} centroids
     */
    fromJSON({ k = null, clusters = null, centroids = null }) {
        if (!k || !clusters || !centroids) {
            throw new Error('You must provide all the parameters include k, clusters and centroids');
        }
        this.k = k;
        this.clusters = clusters;
        this.centroids = centroids;
    }
    /**
     * Get initial centroids from X of k
     * @param {number[]} X
     * @param {number} k
     * @returns {number[]}
     */
    getInitialCentroids(X, k) {
        // Create an initial copy
        const centroids = _.clone(X);
        // Sort the centroid randomly if the randomState is greater than 0
        if (this.randomState > 0) {
            const randomEngine = Random.engines.mt19937();
            randomEngine.seed(this.randomState);
            centroids.sort(() => {
                const randomInt = Random.integer(0, 1)(randomEngine);
                return Math.round(randomInt) - 0.5;
            });
        }
        return centroids.slice(0, k);
    }
    /**
     * Get closest centroids based on the passed in distance method
     * @param {number[]} data
     * @param {number[]} centroids
     * @param distance
     * @returns {number}
     */
    getClosestCentroids(data, centroids, distance) {
        let min = Infinity;
        let index = 0;
        _.forEach(centroids, (centroid, i) => {
            const dist = distance(data, centroid);
            if (dist < min) {
                min = dist;
                index = i;
            }
        });
        return index;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoia19tZWFucy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9saWIvY2x1c3Rlci9rX21lYW5zLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sS0FBSyxDQUFDLE1BQU0sUUFBUSxDQUFDO0FBQzVCLE9BQU8sS0FBSyxNQUFNLE1BQU0sV0FBVyxDQUFDO0FBQ3BDLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLFFBQVEsQ0FBQztBQUUxQyxPQUFPLElBQUksTUFBTSxvQkFBb0IsQ0FBQztBQVN0Qzs7Ozs7Ozs7Ozs7R0FXRztBQUNILE1BQU07SUFTSjs7Ozs7O09BTUc7SUFDSCxZQUNFLEVBQ0UsUUFBUSxHQUFHLFdBQVcsRUFDdEIsQ0FBQyxHQUFHLENBQUMsRUFDTCxZQUFZLEdBQUcsR0FBRyxFQUNsQixXQUFXLEdBQUcsQ0FBQyxLQUNFO1FBQ2pCLFFBQVEsRUFBRSxXQUFXO1FBQ3JCLENBQUMsRUFBRSxDQUFDO1FBQ0osWUFBWSxFQUFFLEdBQUc7UUFDakIsV0FBVyxFQUFFLENBQUM7S0FDZjtRQUVELElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ1gsOEJBQThCO1FBQzlCLE1BQU0sWUFBWSxHQUFHLFFBQVEsQ0FBQztRQUM5QixRQUFRLFlBQVksRUFBRTtZQUNwQixLQUFLLFdBQVc7Z0JBQ2QsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUMsaUJBQWlCLENBQUM7Z0JBQ3ZDLE1BQU07WUFDUixLQUFLLFdBQVc7Z0JBQ2QsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUMsaUJBQWlCLENBQUM7Z0JBQ3ZDLE1BQU07WUFDUjtnQkFDRSxNQUFNLElBQUksS0FBSyxDQUFDLHlCQUF5QixZQUFZLEVBQUUsQ0FBQyxDQUFDO1NBQzVEO1FBQ0QsSUFBSSxDQUFDLFdBQVcsR0FBRyxXQUFXLENBQUM7UUFDL0IsSUFBSSxDQUFDLFlBQVksR0FBRyxZQUFZLENBQUM7UUFDakMsSUFB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