import { map, uniqBy } from 'lodash';
import { inferShape, validateFitInputs } from '../ops';
import math from '../utils/MathExtra';
import KDTree from './KDTree';
const { euclideanDistance, manhattanDistance } = math;
const DIST_EUC = 'euclidean';
const DIST_MAN = 'manhattan';
const TYPE_KD = 'kdtree';
/**
 * Classifier implementing the k-nearest neighbors vote.
 *
 * @example
 * const knn = new KNeighborsClassifier();
 * const X = [[0, 0, 0], [0, 1, 1], [1, 1, 0], [2, 2, 2], [1, 2, 2], [2, 1, 2]];
 * const y = [0, 0, 0, 1, 1, 1];
 * knn.fit(X ,y);
 * console.log(knn.predict([1, 2])); // predicts 1
 */
export class KNeighborsClassifier {
    /**
     * @param {string} distance - Choice of distance function, should choose between euclidean | manhattan
     * @param {number} k - Number of neighbors to classify
     * @param {string} type - Type of algorithm to use, choose between kdtree(default) | balltree | simple
     */
    constructor({ 
    // Each object param default value
    distance = DIST_EUC, k = 0, type = TYPE_KD } = {
        // Default value on empty constructor
        distance: DIST_EUC,
        k: 0,
        type: TYPE_KD
    }) {
        this.type = null;
        this.tree = null;
        this.k = null;
        this.classes = null;
        this.distance = null;
        const options = {
            distance,
            k,
            type
        };
        // Handling distance
        if (options.distance === DIST_EUC) {
            this.distance = euclideanDistance;
        }
        else if (options.distance === DIST_MAN) {
            this.distance = manhattanDistance;
        }
        else {
            throw new Error(`Unrecognised type of distance ${options.distance} was received`);
        }
        this.k = options.k;
        this.type = options.type;
    }
    /**
     * Train the classifier with input and output data
     * @param {any} X - Training data.
     * @param {any} y - Target data.
     */
    fit(X, y) {
        validateFitInputs(X, y);
        // Getting the classes from y
        const classes = uniqBy(y, c => c);
        // Setting k; if it's null, use the class length
        const k = this.k ? this.k : classes.length + 1;
        //  Constructing the points placeholder
        const points = new Array(X.length);
        for (let i = 0; i < points.length; ++i) {
            points[i] = X[i].slice();
        }
        for (let i = 0; i < y.length; ++i) {
            points[i].push(y[i]);
        }
        // Building a tree or algo according to this.type
        if (this.type === TYPE_KD) {
            this.tree = new KDTree(points, this.distance);
        }
        this.k = k;
        this.classes = classes;
    }
    /**
     * Return the model's state as a JSON object
     * @return {object} JSON KNN model.
     */
    toJSON() {
        return {
            classes: this.classes,
            distance: this.distance,
            k: this.k,
            tree: this.tree,
            type: this.type
        };
    }
    /**
     * Restores the model from a JSON checkpoint
     * @param {any} classes
     * @param {any} distance
     * @param {any} k
     * @param {any} tree
     * @param {any} type
     */
    fromJSON({ classes = null, distance = null, k = null, tree = null, type = null }) {
        if (!classes || !distance || !k || !tree || !type) {
            throw new Error('You must provide classes, distance, k, tree and type to restore the KNearestNeighbor');
        }
        this.classes = classes;
        this.distance = distance;
        this.k = k;
        this.tree = tree;
        this.type = type;
    }
    /**
     * Predict single value from a list of data
     * @param {Array} X - Prediction data.
     * @returns number
     */
    predict(X) {
        const shape = inferShape(X);
        if (shape.length === 1) {
            return this.getSinglePred(X);
        }
        else if (shape.length === 2) {
            return map(X, currentItem => this.getSinglePred(currentItem));
        }
        else {
            throw new TypeError('The dataset is neither an array or a matrix');
        }
    }
    /**
     * Runs a single prediction against an array based on kdTree or balltree or
     * simple algo
     * @param array
     * @returns {{}}
     */
    getSinglePred(array) {
        if (this.tree) {
            return this.getTreeBasedPrediction(array);
        }
        else {
            // Run the simple KNN algorithm
            return 0;
        }
    }
    /**
     * Get the class with the max point
     * @param current
     * @returns {{}}
     * @ignore
     */
    getTreeBasedPrediction(current) {
        const nearestPoints = this.tree.nearest(current, this.k);
        const pointsPerClass = {};
        let predictedClass = -1;
        let maxPoints = -1;
        const lastElement = nearestPoints[0][0].length - 1;
        // Initialising the points placeholder per class
        for (let j = 0; j < this.classes.length; j++) {
            pointsPerClass[this.classes[j]] = 0;
        }
        // Voting the max value
        for (let i = 0; i < nearestPoints.length; ++i) {
            const currentClass = nearestPoints[i][0][lastElement];
            const currentPoints = ++pointsPerClass[currentClass];
            if (currentPoints > maxPoints) {
                predictedClass = currentClass;
                maxPoints = currentPoints;
            }
        }
        return predictedClass;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2xhc3NpZmljYXRpb24uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9zcmMvbGliL25laWdoYm9ycy9jbGFzc2lmaWNhdGlvbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsR0FBRyxFQUFFLE1BQU0sRUFBRSxNQUFNLFFBQVEsQ0FBQztBQUNyQyxPQUFPLEVBQUUsVUFBVSxFQUFFLGlCQUFpQixFQUFFLE1BQU0sUUFBUSxDQUFDO0FBRXZELE9BQU8sSUFBSSxNQUFNLG9CQUFvQixDQUFDO0FBQ3RDLE9BQU8sTUFBTSxNQUFNLFVBQVUsQ0FBQztBQUM5QixNQUFNLEVBQUUsaUJBQWlCLEVBQUUsaUJBQWlCLEVBQUUsR0FBRyxJQUFJLENBQUM7QUFDdEQsTUFBTSxRQUFRLEdBQUcsV0FBVyxDQUFDO0FBQzdCLE1BQU0sUUFBUSxHQUFHLFdBQVcsQ0FBQztBQUM3QixNQUFNLE9BQU8sR0FBRyxRQUFRLENBQUM7QUFFekI7Ozs7Ozs7OztHQVNHO0FBQ0gsTUFBTTtJQVFKOzs7O09BSUc7SUFDSCxZQUNFO0lBQ0Usa0NBQWtDO0lBQ2xDLFFBQVEsR0FBRyxRQUFRLEVBQ25CLENBQUMsR0FBRyxDQUFDLEVBQ0wsSUFBSSxHQUFHLE9BQU8sS0FNWjtRQUNGLHFDQUFxQztRQUNyQyxRQUFRLEVBQUUsUUFBUTtRQUNsQixDQUFDLEVBQUUsQ0FBQztRQUNKLElBQUksRUFBRSxPQUFPO0tBQ2Q7UUEzQkssU0FBSSxHQUFHLElBQUksQ0FBQztRQUNaLFNBQUksR0FBRyxJQUFJLENBQUM7UUFDWixNQUFDLEdBQUcsSUFBSSxDQUFDO1FBQ1QsWUFBTyxHQUFHLElBQUksQ0FBQztRQUNmLGFBQVEsR0FBRyxJQUFJLENBQUM7UUF5QnRCLE1BQU0sT0FBTyxHQUFHO1lBQ2QsUUFBUTtZQUNSLENBQUM7WUFDRCxJQUFJO1NBQ0wsQ0FBQztRQUNGLG9CQUFvQjtRQUNwQixJQUFJLE9BQU8sQ0FBQyxRQUFRLEtBQUss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