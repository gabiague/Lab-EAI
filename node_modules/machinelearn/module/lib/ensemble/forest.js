import { concat, countBy, find, head, isEqual, keys, map, maxBy, range, reduce, values } from 'lodash';
import { validateFitInputs, validateMatrix2D } from '../ops';
import { DecisionTreeClassifier } from '../tree';
/**
 * Base RandomForest implementation used by both classifier and regressor
 * @ignore
 */
export class BaseRandomForest {
    /**
     *
     * @param {number} nEstimator - Number of trees.
     * @param random_state - Random seed value for DecisionTrees
     */
    constructor({ 
    // Each object param default value
    nEstimator = 10, random_state = null } = {
        // Default value on empty constructor
        nEstimator: 10,
        random_state: null
    }) {
        this.trees = [];
        this.randomState = null;
        this.nEstimator = nEstimator;
        this.randomState = random_state;
    }
    /**
     * Build a forest of trees from the training set (X, y).
     * @param {Array} X - array-like or sparse matrix of shape = [n_samples, n_features]
     * @param {Array} y - array-like, shape = [n_samples] or [n_samples, n_outputs]
     * @returns void
     */
    fit(X = null, y = null) {
        validateFitInputs(X, y);
        this.trees = reduce(range(0, this.nEstimator), sum => {
            const tree = new DecisionTreeClassifier({
                featureLabels: null,
                random_state: this.randomState
            });
            tree.fit(X, y);
            return concat(sum, [tree]);
        }, []);
    }
    /**
     * Returning the current model's checkpoint
     * @returns {{trees: any[]}}
     */
    toJSON() {
        return {
            trees: this.trees
        };
    }
    /**
     * Restore the model from a checkpoint
     * @param {any[]} trees - Decision trees
     */
    fromJSON({ trees = null }) {
        if (!trees) {
            throw new Error('You must provide both tree to restore the model');
        }
        this.trees = trees;
    }
    /**
     * Internal predict function used by either RandomForestClassifier or Regressor
     * @param X
     * @private
     */
    predict(X = null) {
        validateMatrix2D(X);
        return map(this.trees, (tree) => {
            // TODO: Check if it's a matrix or an array
            return tree.predict(X);
        });
    }
}
/**
 * Random forest classifier creates a set of decision trees from randomly selected subset of training set.
 * It then aggregates the votes from different decision trees to decide the final class of the test object.
 *
 * @example
 * import { RandomForestClassifier } from 'machinelearn/ensemble';
 *
 * const X = [[0, 0], [1, 1], [2, 1], [1, 5], [3, 2]];
 * const y = [0, 1, 2, 3, 7];
 *
 * const randomForest = new RandomForestClassifier();
 * randomForest.fit(X, y);
 *
 * // Results in a value such as [ '0', '2' ].
 * // Predictions will change as we have not set a seed value.
 */
export class RandomForestClassifier extends BaseRandomForest {
    /**
     * Predict class for X.
     *
     * The predicted class of an input sample is a vote by the trees in the forest, weighted by their probability estimates.
     * That is, the predicted class is the one with highest mean probability estimate across the trees.
     * @param {Array} X - array-like or sparse matrix of shape = [n_samples]
     * @returns {string[]}
     */
    predict(X = null) {
        const predictions = super.predict(X);
        return this.votePredictions(predictions);
    }
    /**
     * @hidden
     * Bagging prediction helper method
     * According to the predictions returns by the trees, it will select the
     * class with the maximum number (votes)
     * @param {Array<any>} predictions - List of initial predictions that may look like [ [1, 2], [1, 1] ... ]
     * @returns {string[]}
     */
    votePredictions(predictions) {
        const counts = countBy(predictions, x => x);
        const countsArray = reduce(keys(counts), (sum, k) => {
            const returning = {};
            returning[k] = counts[k];
            return concat(sum, returning);
        }, []);
        const max = maxBy(countsArray, x => head(values(x)));
        const key = head(keys(max));
        // Find the actual class values from the predictions
        return find(predictions, pred => {
            return isEqual(pred.join(','), key);
        });
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZm9yZXN0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vc3JjL2xpYi9lbnNlbWJsZS9mb3Jlc3QudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUNMLE1BQU0sRUFDTixPQUFPLEVBQ1AsSUFBSSxFQUNKLElBQUksRUFDSixPQUFPLEVBQ1AsSUFBSSxFQUNKLEdBQUcsRUFDSCxLQUFLLEVBQ0wsS0FBSyxFQUNMLE1BQU0sRUFDTixNQUFNLEVBQ1AsTUFBTSxRQUFRLENBQUM7QUFDaEIsT0FBTyxFQUFFLGlCQUFpQixFQUFFLGdCQUFnQixFQUFFLE1BQU0sUUFBUSxDQUFDO0FBQzdELE9BQU8sRUFBRSxzQkFBc0IsRUFBRSxNQUFNLFNBQVMsQ0FBQztBQUdqRDs7O0dBR0c7QUFDSCxNQUFNO0lBS0o7Ozs7T0FJRztJQUNILFlBQ0U7SUFDRSxrQ0FBa0M7SUFDbEMsVUFBVSxHQUFHLEVBQUUsRUFDZixZQUFZLEdBQUcsSUFBSSxLQUtqQjtRQUNGLHFDQUFxQztRQUNyQyxVQUFVLEVBQUUsRUFBRTtRQUNkLFlBQVksRUFBRSxJQUFJO0tBQ25CO1FBdEJPLFVBQUssR0FBRyxFQUFFLENBQUM7UUFFWCxnQkFBVyxHQUFHLElBQUksQ0FBQztRQXNCM0IsSUFBSSxDQUFDLFVBQVUsR0FBRyxVQUFVLENBQUM7UUFDN0IsSUFBSSxDQUFDLFdBQVcsR0FBRyxZQUFZLENBQUM7SUFDbEMsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0ksR0FBRyxDQUNSLElBQTBCLElBQUksRUFDOUIsSUFBMEIsSUFBSTtRQUU5QixpQkFBaUIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDeEIsSUFBSSxDQUFDLEtBQUssR0FBRyxNQUFNLENBQ2pCLEtBQUssQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLFVBQVUsQ0FBQyxFQUN6QixHQUFHLENBQUMsRUFBRTtZQUNKLE1BQU0sSUFBSSxHQUFHLElBQUksc0JBQXNCLENBQUM7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