import * as tf from '@tensorflow/tfjs';
import { isEqual } from 'lodash';
import { inferShape } from '../ops';
/**
 * Mean absolute error regression loss
 *
 * @example
 * import { mean_absolute_error } from 'machinelearn/metrics';
 * const y_true = [3, -0.5, 2, 7]
 * const y_pred = [2.5, 0.0, 2, 8]
 * mean_absolute_error(y_true, y_pred); // 0.5
 *
 * @param y_true - Ground truth (correct) target values.
 * @param y_pred - Estimated target values.
 * @param sample_weight - Sample weights.
 */
export function mean_absolute_error(y_true = null, y_pred = null, 
// Options
{ sample_weight = null } = {
    sample_weight: null
}) {
    const yTrueShape = inferShape(y_true);
    const yPredShape = inferShape(y_pred);
    // Validation 1: empty array check
    if (yTrueShape[0] === 0 || yPredShape[0] === 0) {
        throw new TypeError(`y_true ${JSON.stringify(y_true)} and y_pred ${JSON.stringify(y_pred)} cannot be empty`);
    }
    if (sample_weight !== null) {
        const weightShape = inferShape(sample_weight);
        if (!isEqual(yTrueShape, weightShape)) {
            throw new TypeError(`The shape of ${JSON.stringify(weightShape)}
       does not match with the sample size ${JSON.stringify(yTrueShape)}`);
        }
    }
    // Validation 2: Same shape
    if (!isEqual(yTrueShape, yPredShape)) {
        throw new TypeError(`The shapes of y_true ${JSON.stringify(yTrueShape)} and y_pred ${JSON.stringify(yPredShape)} should be equal`);
    }
    /**
     * Compute the weighted average along the specified axis.
     *
     * @example
     * average(tf.tensor1d([1, 2, 3, 4])).dataSync(); // [2.5]
     *
     * @param X - Array containing data to be averaged. If a is not an array, a conversion is attempted.
     * @param axis - Axis along which to average a. If None, averaging is done over the flattened array.
     * @param w - An array of weights associated with the values in a. Each value in a contributes to the average according to its associated weight. The weights array can either be 1-D (in which case its length must be the size of a along the given axis) or of the same shape as a. If weights=None, then all data in a are assumed to have a weight equal to one.
     * @ignore
     */
    const average = (X, axis = 0, w = null) => {
        if (w !== null) {
            const wgt = tf.tensor1d(w);
            const scl = wgt.sum(axis);
            return tf
                .mul(X, wgt)
                .sum(axis)
                .div(scl);
        }
        else {
            const sample_size = X.size;
            return tf.div(tf.sum(X), tf.scalar(sample_size));
        }
    };
    const output_errors = tf.abs(tf.sub(y_true, y_pred));
    const avg_errors = average(output_errors, 0, sample_weight);
    return average(avg_errors).dataSync()[0];
}
/**
 * Mean squared error regression loss
 *
 * @example
 * import { mean_squared_error } from 'machinelearn/metrics';
 *
 * const y_true = [3, -0.5, 2, 7];
 * const y_pred = [2.5, 0.0, 2, 8];
 *
 * console.log(mean_squared_error(y_true, y_pred));
 * // result: 0.375
 *
 * const y_true1 = [[0.5, 1], [-1, 1], [7, -6]];
 * const y_pred1 = [[0, 2], [-1, 2], [8, -5]];
 *
 * console.log(mean_squared_error(y_true1, y_pred1));
 * // result: 0.7083333134651184
 *
 * @param y_true - Ground truth (correct) target values.
 * @param y_pred - Estimated target values.
 */
export function mean_squared_error(y_true = null, y_pred = null, 
// Options
{ 
/**
 * Sample weights.
 */
sample_weight = null } = {
    sample_weight: null
}) {
    const yTrueShape = inferShape(y_true);
    const yPredShape = inferShape(y_pred);
    // Validation 1: empty array check
    if (yTrueShape[0] === 0 || yPredShape[0] === 0) {
        throw new TypeError(`y_true ${JSON.stringify(y_true)} and y_pred ${JSON.stringify(y_pred)} cannot be empty`);
    }
    // Validation 2: Same shape
    if (!isEqual(yTrueShape, yPredShape)) {
        throw new TypeError(`Shapes of y_true ${JSON.stringify(yTrueShape)} and y_pred ${JSON.stringify(yPredShape)} should be equal`);
    }
    return tf.losses
        .meanSquaredError(y_true, y_pred, sample_weight)
        .dataSync()[0];
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVncmVzc2lvbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9saWIvbWV0cmljcy9yZWdyZXNzaW9uLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sS0FBSyxFQUFFLE1BQU0sa0JBQWtCLENBQUM7QUFDdkMsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLFFBQVEsQ0FBQztBQUNqQyxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sUUFBUSxDQUFDO0FBR3BDOzs7Ozs7Ozs7Ozs7R0FZRztBQUNILE1BQU0sOEJBQ0osU0FBc0QsSUFBSSxFQUMxRCxTQUFzRCxJQUFJO0FBQzFELFVBQVU7QUFDVixFQUNFLGFBQWEsR0FBRyxJQUFJLEtBR2xCO0lBQ0YsYUFBYSxFQUFFLElBQUk7Q0FDcEI7SUFFRCxNQUFNLFVBQVUsR0FBRyxVQUFVLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDdEMsTUFBTSxVQUFVLEdBQUcsVUFBVSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBRXRDLGtDQUFrQztJQUNsQyxJQUFJLFVBQVUsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLElBQUksVUFBVSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsRUFBRTtRQUM5QyxNQUFNLElBQUksU0FBUyxDQUNqQixVQUFVLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLGVBQWUsSUFBSSxDQUFDLFNBQVMsQ0FDM0QsTUFBTSxDQUNQLGtCQUFrQixDQUNwQixDQUFDO0tBQ0g7SUFFRCxJQUFJLGFBQWEsS0FBSyxJQUFJLEVBQUU7UUFDMUIsTUFBTSxXQUFXLEdBQUcsVUFBVSxDQUFDLGFBQWEsQ0FBQyxDQUFDO1FBQzlDLElBQUksQ0FBQyxPQUFPLENBQUMsVUFBVSxFQUFFLFdBQVcsQ0FBQyxFQUFFO1lBQ3JDLE1BQU0sSUFBSSxTQUFTLENBQUMsZ0JBQWdCLElBQUksQ0FBQyxTQUFTLENBQUMsV0FBVyxDQUFDOzZDQUN4QixJQUFJLENBQUMsU0FBUyxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUMsQ0FBQztTQUN0RTtLQUNGO0lBRUQsMkJBQTJCO0lBQzNCLElBQUksQ0FBQyxPQUFPLENBQUMsVUFBVSxFQUFFLFVBQVUsQ0FBQyxFQUFFO1FBQ3BDLE1BQU0sSUFBSSxTQUFTLENBQ2pCLHdCQUF3QixJQUFJLENBQUMsU0FBUyxDQUNwQyxVQUFVLENBQ1gsZUFBZSxJQUFJLENBQUMsU0FBUyxDQUFDLFVBQVUsQ0FBQyxrQkFBa0IsQ0FDN0QsQ0FBQztLQUNIO0lBRUQ7Ozs7Ozs7Ozs7T0FVRztJQUNILE1BQU0sT0FBTyxHQUFHLENBQ2QsQ0FBWSxFQUNaLE9BQWUsQ0FBQyxFQUNoQixJQUFpQyxJQUFJLEVBQzFCLEVBQUU7UUFDYixJQUFJLENBQUMsS0FBSyxJQUFJLEVBQUU7WUFDZCxNQUFNLEdBQUcsR0FBRyxFQUFFLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQzNCLE1BQU0sR0FBRyxHQUFHLEdBQUcsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDMUIsT0FBTyxFQUFFO2lCQUNOLEdBQUcsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDO2lCQUNYLEdBQUcsQ0FBQyxJQUFJLENBQUM7aUJBQ1QsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQ2I7YUFBTTtZQUNMLE1BQU0sV0FBVyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUM7WUFDM0IsT0FBTyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDO1NBQ2xEO0lBQ0gsQ0FBQyxDQUFDO0lBQ0YsTUFBTSxhQUFhLEdBQUcsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLE1BQU0sRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDO0lBQ3JELE1BQU0sVUFBVSxHQUFHLE9BQU8sQ0FBQyxhQUFhLEVBQUUsQ0FBQyxFQUFFLGFBQWEsQ0FBQyxDQUFDO0lBQzVELE9BQU8sT0FBTyxDQUFDLFVBQVUsQ0FBQyxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQzNDLENBQUM7QUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FvQkc7QUFDSCxNQUFNLDZCQUNKLFNBQXNELElBQUksRUFDMUQsU0FBc0QsSUFBSTtBQUMxRCxVQUFVO0FBQ1Y7QUFDRTs7R0FFRztBQUNILGFBQWEsR0FBRyxJQUFJLEtBR2xCO0lBQ0YsYUFBYSxFQUFFLElBQUk7Q0FDcEI7SUFFRCxNQUFNLFVBQVUsR0FBRyxVQUFVLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDdEMsTUFBTSxVQUFVLEdBQUcsVUFBVSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBRXRDLGtDQUFrQztJQUNsQyxJQUFJLFVBQVUsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLElBQUksVUFBVSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsRUFBRTtRQUM5QyxNQUFNLElBQUksU0FBUyxDQUNqQixVQUFVLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLGVBQWUsSUFBSSxDQUFDLFNBQVMsQ0FDM0QsTUFBTSxDQUNQLGtCQUFrQixDQUNwQixDQUFDO0tBQ0g7SUFFRCwyQkFBMkI7SUFDM0IsSUFBSSxDQUFDLE9BQU8sQ0FBQyxVQUFVLEVBQUUsVUFBVSxDQUFDLEVBQUU7UUFDcEMsTUFBTSxJQUFJLFNBQVMsQ0FDakIsb0JBQW9CLElBQUksQ0FBQyxTQUFTLENBQ2hDLFVBQVUsQ0FDWCxlQUFlLElBQUksQ0FBQyxTQUFTLENBQUMsVUFBVSxDQUFDLGtCQUFrQixDQUM3RCxDQUFDO0tBQ0g7SUFFRCxPQUFPLEVBQUUsQ0FBQyxNQUFNO1NBQ2IsZ0JBQWdCLENBQUMsTUFBTSxFQUFFLE1BQU0sRUFBRSxhQUFhLENBQUM7U0FDL0MsUUFBUSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDbkIsQ0FBQyJ9