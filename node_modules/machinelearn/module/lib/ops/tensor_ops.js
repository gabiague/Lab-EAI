import * as tf from '@tensorflow/tfjs';
import { flattenDeep, isEqual, sortBy, uniq } from 'lodash';
/**
 * Infers shape of a tensor using TF
 *
 * @example
 * inferShape(1) // exception
 * inferShape(true) // exception
 * inferShape([1, 2]) // [2]
 * inferShape([[1, 2], [3, 4]]) // [2, 2]
 *
 * @param X
 * @ignore
 */
export function inferShape(X) {
    return tf.tensor(X).shape;
}
/**
 * Validates the input matrix's types with the targetted types.
 * Specified target types must be one of https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof#Description
 *
 * @example
 * validateMatrixType([['z', 'z']],['string']); // no errors
 * validateMatrixType([['z', 'z']],['test']); // error: Input matrix type of ["string"] does not match with the target types ["test"]
 *
 * @param X - The input matrix
 * @param targetTypes - Target matrix types
 * @ignore
 */
export function validateMatrixType(X, targetTypes) {
    const flatX = flattenDeep(X);
    const xTypes = uniq(flatX.map(x => typeof x));
    const sortedXTypes = sortBy(xTypes, x => x);
    const sortedTargetTypes = sortBy(targetTypes, x => x);
    if (!isEqual(sortedXTypes, sortedTargetTypes)) {
        throw new TypeError(`Input matrix type of ${JSON.stringify(sortedXTypes)} does not match with the target types ${JSON.stringify(sortedTargetTypes)}`);
    }
}
/**
 * Validate typical X and y train data and check they are 2D and 1D shaped respectively
 *
 * @example
 * validateTrainInputs([ [1, 2], [3, 4] ], [ 1, 2 ]) // No errors
 * validateTrainInputs([ [[1, 2], [3, 3]], [[1, 2], [3, 3]] ], [ 1, 2 ]) // Error: The matrix is not 1D shaped: [ [[1, 2], [3, 3]], [[1, 2], [3, 3]] ] of [2, 2, 2]
 *
 * @param X
 * @param y
 * @ignore
 */
export function validateFitInputs(X, y) {
    if ((Array.isArray(X) && X.length === 0) ||
        (Array.isArray(y) && y.length === 0)) {
        throw new Error('Input cannot be an empty array');
    }
    // Check X is always a matrix
    const sampleShape = validateMatrix2D(X);
    // Check y is always a vector
    const targetShape = validateMatrix1D(y);
    if (sampleShape[0] !== targetShape[0]) {
        throw new TypeError(`Number of labels=${targetShape[0]} does not math number of samples=${sampleShape[0]}`);
    }
}
/**
 * Validate the matrix is 1D shaped by checking the shape's length is exactly  1
 * @param X
 * @ignore
 */
export function validateMatrix1D(X) {
    const shape = inferShape(X);
    if (shape.length !== 1 || shape[0] === 0) {
        throw new TypeError(`The matrix is not 1D shaped: ${JSON.stringify(X)} of ${JSON.stringify(shape)}`);
    }
    return shape;
}
/**
 * Validate the matrix is 2D shaped by checking the shape's length is exactly 2
 * @param X - An input array
 * @ignore
 */
export function validateMatrix2D(X) {
    const shape = inferShape(X);
    if (shape.length !== 2) {
        throw new TypeError(`The matrix is not 2D shaped: ${JSON.stringify(X)} of ${JSON.stringify(shape)}`);
    }
    return shape;
}
/**
 * Reshapes any size of array into a new shape.
 *
 * The code was borrowed from math.js (https://github.com/josdejong/mathjs/blob/5750a1845442946d236822505c607a522be23474/src/utils/array.js#L258),
 * which enables us to use a specific method from Math.js instead of installing an entire library.
 *
 * TF.js has implemented an efficient way to return raw values from its Tensor implementation that always returns a 1D array,
 * which is not ideal in situations where we need a return value with correct shapes.
 *
 * Please check out https://github.com/tensorflow/tfjs/issues/939 for more information
 *
 * @example
 * reshape([1, 2, 3, 4, 5, 6], [2, 3]); // [[1, 2, 3], [4, 5, 6]]
 * reshape([1, 2, 3, 4, 5, 6], [2, 3, 1]); // [[[1], [2], [3]], [[4], [5], [6]]]
 *
 * @param array - Target array
 * @param sizes - New array shape to resize into
 * @ignore
 */
export function reshape(array, sizes) {
    // Initial validations
    if (!Array.isArray(array)) {
        throw new TypeError('The input array must be an array!');
    }
    if (!Array.isArray(sizes)) {
        throw new TypeError('The sizes must be an array!');
    }
    const deepFlatArray = flattenDeep(array);
    // If the reshaping is to single dimensional
    if (sizes.length === 1 && deepFlatArray.length === sizes[0]) {
        return deepFlatArray;
    }
    else if (sizes.length === 1 && deepFlatArray.length !== sizes[0]) {
        throw new TypeError(`Target array shape [${deepFlatArray.length}] cannot be reshaped into ${sizes}`);
    }
    // testing if there are enough elements for the requested shape
    let tmpArray = deepFlatArray;
    let tmpArray2;
    // for each dimensions starting by the last one and ignoring the first one
    for (let sizeIndex = sizes.length - 1; sizeIndex > 0; sizeIndex--) {
        const size = sizes[sizeIndex];
        tmpArray2 = [];
        // aggregate the elements of the current tmpArray in elements of the requested size
        const length = tmpArray.length / size;
        for (let i = 0; i < length; i++) {
            tmpArray2.push(tmpArray.slice(i * size, (i + 1) * size));
        }
        // set it as the new tmpArray for the next loop turn or for return
        tmpArray = tmpArray2;
    }
    return tmpArray;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGVuc29yX29wcy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9saWIvb3BzL3RlbnNvcl9vcHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxLQUFLLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQztBQUN2QyxPQUFPLEVBQUUsV0FBVyxFQUFFLE9BQU8sRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLE1BQU0sUUFBUSxDQUFDO0FBRzVEOzs7Ozs7Ozs7OztHQVdHO0FBQ0gsTUFBTSxxQkFBcUIsQ0FBa0I7SUFDM0MsT0FBTyxFQUFFLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQztBQUM1QixDQUFDO0FBRUQ7Ozs7Ozs7Ozs7O0dBV0c7QUFDSCxNQUFNLDZCQUNKLENBQWtCLEVBQ2xCLFdBQXFCO0lBRXJCLE1BQU0sS0FBSyxHQUFHLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUM3QixNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUM5QyxNQUFNLFlBQVksR0FBRyxNQUFNLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDNUMsTUFBTSxpQkFBaUIsR0FBRyxNQUFNLENBQUMsV0FBVyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDdEQsSUFBSSxDQUFDLE9BQU8sQ0FBQyxZQUFZLEVBQUUsaUJBQWlCLENBQUMsRUFBRTtRQUM3QyxNQUFNLElBQUksU0FBUyxDQUNqQix3QkFBd0IsSUFBSSxDQUFDLFNBQVMsQ0FDcEMsWUFBWSxDQUNiLHlDQUF5QyxJQUFJLENBQUMsU0FBUyxDQUN0RCxpQkFBaUIsQ0FDbEIsRUFBRSxDQUNKLENBQUM7S0FDSDtBQUNILENBQUM7QUFFRDs7Ozs7Ozs7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