import * as fs from 'fs-extra';
import 'isomorphic-fetch';
import { parseInt, uniqBy } from 'lodash';
import * as path from 'path';
import { LabelEncoder } from '../preprocessing/label';
/**
 * @ignore
 */
export class BaseDataset {
    /**
     * fetch load from a multiple
     * @param sources - A list of URLs to fetch the data from
     * @param type - type of data; for example CSV or JSON
     * @param delimiter - specify the data delimiter, which will be used to split the row data
     * @param lastIsTarget - tell the underlying processor that the last index of the dataset is the target data
     * @param trainType - data type to enforce on the training dataset
     * @param targetType - target type to enforce on the target dataset
     * @private
     */
    async fetchLoad(sources = [], { 
    // Params
    type = 'csv', delimiter = ',', lastIsTarget = true, trainType = 'float', targetType = 'float' } = {
        // Default object if nothing is provided
        type: 'csv',
        delimiter: ',',
        lastIsTarget: true,
        trainType: 'float',
        targetType: 'float'
    }) {
        let data = null;
        for (let i = 0; i < sources.length; i++) {
            const url = sources[i];
            // TODO: Create a fetch middleware to cache already requested data
            const response = await fetch(url);
            const status = response.ok;
            const textData = await response.text();
            if (status && textData) {
                data = textData;
                // No need to request data anymore
                break;
            }
        }
        if (type === 'csv') {
            return this.processCSV(data, delimiter, lastIsTarget, trainType, targetType);
        }
        return {
            data: null,
            targets: null,
            labels: null
        };
    }
    /**
     * Load data from the local data folder
     */
    async fsLoad(type, { delimiter = ',', lastIsTarget = true, trainType = 'float', targetType = 'float' } = {
        // Default object if nothing is provided
        delimiter: ',',
        lastIsTarget: true,
        trainType: 'float',
        targetType: 'float'
    }) {
        // Make sure the actual data is located under data/type
        const data = fs.readFileSync(path.join(__dirname, `data/${type}/train.csv`), 'utf8');
        return this.processCSV(data, delimiter, lastIsTarget, trainType, targetType);
    }
    /**
     * Processes CSV type dataset. Returns a training and testing data pair
     * @param data - a raw string data
     * @param delimiter - delimiter to split on
     * @param lastIsTarget - flag to indicate that the last element is the target data
     * @param trainType - training data type to enforce
     * @param targetType - target data type to enforce
     */
    processCSV(data, delimiter = ',', lastIsTarget = true, trainType = 'float', targetType = 'float') {
        // Split the rows by newlines
        const splitRows = data.split(/\r\n|\n|\r/);
        // Trim any excessive spaces
        const trimmedRows = splitRows.map(row => row.trim());
        // Filtering out any empty rows
        const filteredRows = trimmedRows.filter(row => row);
        // Organise training and target data
        let result = filteredRows.map(row => row.split(delimiter));
        if (lastIsTarget) {
            result = result.reduce((sum, curValue) => {
                // Building the target values array
                sum[1].push(curValue.pop());
                // Building the train values array
                sum[0].push(curValue);
                return sum;
            }, [[], []]);
        }
        // Encode the classes
        const rawTest = result[1];
        const encoder = new LabelEncoder();
        // Get the unique labels
        const labelX = uniqBy(rawTest, x => x);
        encoder.fit(labelX);
        // Encode the test values
        const targets = encoder.transform(rawTest);
        // Enforcing data type
        // 1. training data
        if (trainType === 'number') {
            result[0] = result[0].map(row => row.map(parseInt));
        }
        else if (trainType === 'float') {
            result[0] = result[0].map(row => row.map(parseFloat));
        }
        // 2. target data
        if (targetType === 'number') {
            result[1] = result[1].map(parseInt);
        }
        else if (targetType === 'float') {
            result[1] = result[1].map(parseFloat);
        }
        return {
            data: result[0],
            targets,
            labels: result[1]
        };
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQmFzZURhdGFzZXQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9zcmMvbGliL2RhdGFzZXRzL0Jhc2VEYXRhc2V0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sS0FBSyxFQUFFLE1BQU0sVUFBVSxDQUFDO0FBQy9CLE9BQU8sa0JBQWtCLENBQUM7QUFDMUIsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLEVBQUUsTUFBTSxRQUFRLENBQUM7QUFDMUMsT0FBTyxLQUFLLElBQUksTUFBTSxNQUFNLENBQUM7QUFDN0IsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLHdCQUF3QixDQUFDO0FBRXREOztHQUVHO0FBQ0gsTUFBTTtJQUNKOzs7Ozs7Ozs7T0FTRztJQUNPLEtBQUssQ0FBQyxTQUFTLENBQ3ZCLE9BQU8sR0FBRyxFQUFFLEVBQ1o7SUFDRSxTQUFTO0lBQ1QsSUFBSSxHQUFHLEtBQUssRUFDWixTQUFTLEdBQUcsR0FBRyxFQUNmLFlBQVksR0FBRyxJQUFJLEVBQ25CLFNBQVMsR0FBRyxPQUFPLEVBQ25CLFVBQVUsR0FBRyxPQUFPLEVBQ3JCLEdBQUc7UUFDRix3Q0FBd0M7UUFDeEMsSUFBSSxFQUFFLEtBQUs7UUFDWCxTQUFTLEVBQUUsR0FBRztRQUNkLFlBQVksRUFBRSxJQUFJO1FBQ2xCLFNBQVMsRUFBRSxPQUFPO1FBQ2xCLFVBQVUsRUFBRSxPQUFPO0tBQ3BCO1FBRUQsSUFBSSxJQUFJLEdBQUcsSUFBSSxDQUFDO1FBQ2hCLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxPQUFPLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO1lBQ3ZDLE1BQU0sR0FBRyxHQUFHLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUN2QixrRUFBa0U7WUFDbEUsTUFBTSxRQUFRLEdBQUcsTUFBTSxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDbEMsTUFBTSxNQUFNLEdBQUcsUUFBUSxDQUFDLEVBQUUsQ0FBQztZQUMzQixNQUFNLFFBQVEsR0FBRyxNQUFNLFFBQVEsQ0FBQyxJQUFJLEVBQUUsQ0FBQztZQUN2QyxJQUFJLE1BQU0sSUFBSSxRQUFRLEVBQUU7Z0JBQ3RCLElBQUksR0FBRyxRQUFRLENBQUM7Z0JBQ2hCLGtDQUFrQztnQkFDbEMsTUFBTTthQUNQO1NBQ0Y7UUFDRCxJQUFJLElBQUksS0FBSyxLQUFLLEVBQUU7WUFDbEIsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUNwQixJQUFJLEVBQ0osU0FBUyxFQUNULFlBQVksRUFDWixTQUFTLEVBQ1QsVUFBVSxDQUNYLENBQUM7U0FDSDtRQUNELE9BQU87WUFDTCxJQUFJLEVBQUUsSUFBSTtZQUNWLE9BQU8sRUFBRSxJQUFJO1lBQ2IsTUFBTSxFQUFFLElBQUk7U0FDYixDQUFDO0lBQ0osQ0FBQztJQUVEOztPQUVHO0lBQ08sS0FBSyxDQUFDLE1BQU0sQ0FDcEIsSUFBWSxFQUNaLEVBQ0UsU0FBUyxHQUFHLEdBQUcsRUFDZixZQUFZLEdBQUcsSUFBSSxFQUNuQixTQUFTLEdBQUcsT0FBTyxFQUNuQixVQUFVLEdBQUcsT0FBTyxFQUNyQixHQUFHO1FBQ0Ysd0NBQXdDO1FBQ3hDLFNBQVMsRUFBRSxHQUFHO1FBQ2QsWUFBWSxFQUFFLElBQUk7UUFDbEIsU0FBUyxFQUFFLE9BQU87UUFDbEIsVUFBVSxFQUFFLE9BQU87S0FDcEI7UUFFRCx1REFBdUQ7UUFDdkQsTUFBTSxJQUFJLEdBQUcsRUFBRSxDQUFDLFlBQVksQ0FDMUIsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsUUFBUSxJQUFJLFlBQVksQ0FBQyxFQUM5QyxNQUFNLENBQ1AsQ0FBQztRQUNGLE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FDcEIsSUFBSSxFQUNKLFNBQVMsRUFDVCxZQUFZLEVBQ1osU0FBUyxFQUNULFVBQVUsQ0FDWCxDQUFDO0lBQ0osQ0FBQztJQUVEOzs7Ozs7O09BT0c7SUFDSyxVQUFVLENBQ2hCLElBQUksRUFDSixTQUFTLEdBQUcsR0FBRyxFQUNmLFlBQVksR0FBRyxJQUFJLEVBQ25CLFNBQVMsR0FBRyxPQUFPLEVBQ25CLFVBQVUsR0FBRyxPQUFPO1FBRXBCLDZCQUE2QjtRQUM3QixNQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLFlBQVksQ0FBQyxDQUFDO1FBQzNDLDRCQUE0QjtRQUM1QixNQUFNLFdBQVcsR0FBRyxTQUFTLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLElBQUksRUFBRSxDQUFDLENBQUM7UUFDckQsK0JBQStCO1FBQy9CLE1BQU0sWUFBWSxHQUFHLFdBQVcsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNwRCxvQ0FBb0M7UUFDcEMsSUFBSSxNQUFNLEdBQUcsWUFBWSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQztRQUMzRCxJQUFJLFlBQVksRUFBRTtZQUNoQixNQUFNLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FDcEIsQ0FBQyxHQUFHLEVBQUUsUUFBUSxFQUFFLEVBQUU7Z0JBQ2hCLG1DQUFtQztnQkFDbkMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQztnQkFFNUIsa0NBQWtDO2dCQUNsQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO2dCQUN0QixPQUFPLEdBQUcsQ0FBQztZQUNiLENBQUMsRUFDRCxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FDVCxDQUFDO1NBQ0g7UUFFRCxxQkFBcUI7UUFDckIsTUFBTSxPQUFPLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQzFCLE1BQU0sT0FBTyxHQUFHLElBQUksWUFBWSxFQUFFLENBQUM7UUFFbkMsd0JBQXdCO1FBQ3hCLE1BQU0sTUFBTSxHQUFhLE1BQU0sQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNqRCxPQUFPLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBRXBCLHlCQUF5QjtRQUN6QixNQUFNLE9BQU8sR0FBRyxPQUFPLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBRTNDLHNCQUFzQjtRQUN0QixtQkFBbUI7UUFDbkIsSUFBSSxTQUFTLEtBQUssUUFBUSxFQUFFO1lBQzFCLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO1NBQ3JEO2FBQU0sSUFBSSxTQUFTLEtBQUssT0FBTyxFQUFFO1lBQ2hDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDO1NBQ3ZEO1FBRUQsaUJBQWlCO1FBQ2pCLElBQUksVUFBVSxLQUFLLFFBQVEsRUFBRTtZQUMzQixNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsQ0FBQztTQUNyQzthQUFNLElBQUksVUFBVSxLQUFLLE9BQU8sRUFBRTtZQUNqQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsQ0FBQztTQUN2QztRQUNELE9BQU87WUFDTCxJQUFJLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQztZQUNmLE9BQU87WUFDUCxNQUFNLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQztTQUNsQixDQUFDO0lBQ0osQ0FBQztDQUNGIn0=