import { map, range, uniqBy } from 'lodash';
import * as Random from 'random-js';
import { validateFitInputs, validateMatrix2D } from '../ops';
/**
 * Question used by decision tree algorithm to determine whether to split branch or not
 * @ignore
 */
export class Question {
    constructor(features = null, column, value) {
        this.features = [];
        this.column = null;
        this.value = null;
        this.features = features;
        this.column = column;
        this.value = value;
    }
    match(example) {
        const val = example[this.column];
        if (typeof val === 'number') {
            return val >= this.value;
        }
        else {
            return val === this.value;
        }
    }
    toString() {
        if (!this.features) {
            throw Error('You must provide feature labels in order to render toString!');
        }
        const condition = typeof this.value === 'number' ? '>=' : '==';
        return `Is ${this.features[this.column]} ${condition} ${this.value}`;
    }
}
/**
 * According to the given targets array, count occurrences into an object.
 * @param {any[]} targets - list of class: count
 * @returns {}
 * @ignore
 */
export function classCounts(targets) {
    const result = {};
    for (let i = 0; i < targets.length; i++) {
        const target = targets[i];
        const count = result[target]; // the current
        if (typeof count === 'number' && count > 0) {
            result[target] = {
                value: target,
                count: count + 1
            };
        }
        else {
            result[target] = {
                value: target,
                count: 1
            };
        }
    }
    return result;
}
/**
 * A leaf node that classifies data.
 * @ignore
 */
export class Leaf {
    constructor(y) {
        this.prediction = null;
        const counts = classCounts(y);
        const keys = Object.keys(counts); // Retrieving the keys for looping
        // Variable holders
        let maxCount = 0;
        let maxValue = null;
        // Finding the max count key(actual prediction value)
        for (let i = 0; i < keys.length; i++) {
            const key = keys[i];
            const count = counts[key].count;
            const value = counts[key].value;
            if (count > maxCount) {
                maxValue = value;
                maxCount = count;
            }
        }
        this.prediction = maxValue;
    }
}
/**
 * It holds a reference to the question, and to the two children nodes
 * @ignore
 */
export class DecisionNode {
    constructor(question, trueBranch, falseBranch) {
        this.question = null;
        this.trueBranch = null;
        this.falseBranch = null;
        this.question = question;
        this.trueBranch = trueBranch;
        this.falseBranch = falseBranch;
    }
}
/**
 * A decision tree classifier.
 *
 * @example
 * import { DecisionTreeClassifier } from 'machinelearn/tree';
 * const features = ['color', 'diameter', 'label'];
 * const decision = new DecisionTreeClassifier({ featureLabels: features });
 *
 * const X = [['Green', 3], ['Yellow', 3], ['Red', 1], ['Red', 1], ['Yellow', 3]];
 * const y = ['Apple', 'Apple', 'Grape', 'Grape', 'Lemon'];
 * decision.fit({ X, y });
 * decision.printTree(); // try it out yourself! =)
 *
 * decision.predict({ X: [['Green', 3]] }); // [ 'Apple' ]
 * decision.predict({ X }); // [ [ 'Apple' ], [ 'Apple', 'Lemon' ], [ 'Grape', 'Grape' ], [ 'Grape', 'Grape' ], [ 'Apple', 'Lemon' ] ]
 *
 * @example
 * import { DecisionTreeClassifier } from 'machinelearn/tree';
 * const decision = new DecisionTreeClassifier({ featureLabels: null });
 *
 * const X = [[0, 0], [1, 1]];
 * const Y = [0, 1];
 * decision.fit({ X, y });
 * decision2.predict({ row: [[2, 2]] }); // [ 1 ]
 */
export class DecisionTreeClassifier {
    /**
     *
     * @param featureLabels - Literal names for each feature to be used while printing the tree out as a string
     * @param verbose - Logs the progress of the tree construction as console.info
     * @param random_state - A seed value for the random engine
     */
    constructor({ featureLabels = null, verbose = false, random_state = null } = {
        featureLabels: null,
        verbose: false,
        random_state: null
    }) {
        this.featureLabels = null;
        this.tree = null;
        this.verbose = true;
        this.randomState = null;
        this.randomEngine = null;
        this.featureLabels = featureLabels;
        this.verbose = verbose;
        this.randomState = random_state;
        if (!Number.isInteger(random_state)) {
            this.randomEngine = Random.engines.mt19937().autoSeed();
        }
        else {
            this.randomEngine = Random.engines.mt19937().seed(random_state);
        }
    }
    /**
     * Fit date, which builds a tree
     * @param {any} X - 2D Matrix of training
     * @param {any} y - 1D Vector of target
     * @returns {Leaf | DecisionNode}
     */
    fit(X = null, y = null) {
        validateFitInputs(X, y);
        this.tree = this.buildTree({ X, y });
    }
    /**
     * Predict multiple rows
     *
     * @param X - 2D Matrix of testing data
     */
    predict(X = []) {
        validateMatrix2D(X);
        const result = [];
        for (let i = 0; i < X.length; i++) {
            const row = X[i];
            result.push(this._predict({ row, node: this.tree }));
        }
        return result;
    }
    /**
     * Returns the model checkpoint
     * @returns {{featureLabels: string[]; tree: any; verbose: boolean}}
     */
    toJSON() {
        return {
            featureLabels: this.featureLabels,
            tree: this.tree,
            verbose: this.verbose,
            random_state: this.randomState
        };
    }
    /**
     * Restores the model from a checkpoint
     * @param {string[]} featureLabels - Literal names for each feature to be used while printing the tree out as a string
     * @param {any} tree - The model's state
     * @param {boolean} verbose - Logs the progress of the tree construction as console.info
     * @param {number} random_state - A seed value for the random engine
     */
    fromJSON({ featureLabels = null, tree = null, verbose = false, random_state = null }) {
        this.featureLabels = featureLabels;
        this.tree = tree;
        this.verbose = verbose;
        this.randomState = random_state;
    }
    /**
     * Recursively print the tree into console
     * @param {string} spacing - Spacing used when printing the tree into the terminal
     */
    printTree(spacing = '') {
        if (!this.tree) {
            throw new Error('You cannot print an empty tree');
        }
        this._printTree({ node: this.tree, spacing });
    }
    /**
     * Partition X and y into true and false branches
     * @param X
     * @param y
     * @param {Question} question
     * @returns {{trueX: Array<any>; trueY: Array<any>; falseX: Array<any>; falseY: Array<any>}}
     */
    partition(X, y, question) {
        const trueX = [];
        const trueY = [];
        const falseX = [];
        const falseY = [];
        for (let i = 0; i < X.length; i++) {
            const row = X[i];
            if (question.match(row)) {
                trueX.push(X[i]);
                trueY.push(y[i]);
            }
            else {
                falseX.push(X[i]);
                falseY.push(y[i]);
            }
        }
        return { trueX, trueY, falseX, falseY };
    }
    /**
     * Calculate the gini impurity of rows
     * Checkout: https://en.wikipedia.org/wiki/Decision_tree_learning#Gini_impurity
     * @param targets
     * @returns {number}
     */
    gini(targets) {
        const counts = classCounts(targets);
        let impurity = 1;
        const keys = Object.keys(counts);
        for (let i = 0; i < keys.length; i++) {
            const key = keys[i];
            const count = counts[key].count;
            if (count === null || count === undefined) {
                throw Error('Invalid class count detected!');
            }
            const probOfClass = count / targets.length;
            impurity -= Math.pow(probOfClass, 2);
        }
        return impurity;
    }
    /**
     * Information Gain.
     *
     * The uncertainty of the starting node, minus the weighted impurity of
     * two child nodes.
     * @param left
     * @param right
     * @param uncertainty
     * @returns {number}
     */
    infoGain(left, right, uncertainty) {
        const p = left.length / (left.length + right.length);
        return uncertainty - p * this.gini(left) - (1 - p) * this.gini(right);
    }
    /**
     * Find the best split for the current X and y.
     * @param X
     * @param y
     * @returns {{bestGain: number; bestQuestion: any}}
     */
    findBestSplit(X, y) {
        const uncertainty = this.gini(y);
        const nFeatures = X[0].length;
        let bestGain = 0;
        let bestQuestion = null;
        let featureIndex = [];
        if (Number.isInteger(this.randomState)) {
            // method 1: Randomly selecting features
            while (featureIndex.length <= nFeatures) {
                const index = Random.integer(0, nFeatures)(this.randomEngine);
                featureIndex.push(index);
            }
        }
        else {
            featureIndex = range(0, X[0].length);
        }
        for (let i = 0; i < featureIndex.length; i++) {
            const col = featureIndex[i];
            const uniqFeatureValues = uniqBy(map(X, row => row[col]), x => x);
            for (let j = 0; j < uniqFeatureValues.length; j++) {
                const feature = uniqFeatureValues[j];
                // featureLabels is for the model interoperability
                const question = new Question(this.featureLabels, col, feature);
                // Try splitting the dataset
                const { trueY, falseY } = this.partition(X, y, question);
                // Skip this dataset if it does not divide
                if (trueY.length === 0 || falseY.length === 0) {
                    continue;
                }
                // Calculate information gained from this split
                const gain = this.infoGain(trueY, falseY, uncertainty);
                if (this.verbose) {
                    console.info(`fn: ${col} fval: ${feature} gini: ${gain}`);
                }
                if (gain >= bestGain) {
                    bestGain = gain;
                    bestQuestion = question;
                }
            }
        }
        return { bestGain, bestQuestion };
    }
    /**
     * Interactively build tree until it reaches the terminal nodes
     * @param {any} X
     * @param {any} y
     * @returns {any}
     */
    buildTree({ X, y }) {
        const { bestGain, bestQuestion } = this.findBestSplit(X, y);
        if (bestGain === 0) {
            return new Leaf(y);
        }
        // Partition the current passed in X ,y
        const { trueX, trueY, falseX, falseY } = this.partition(X, y, bestQuestion);
        // Recursively build the true branch
        const trueBranch = this.buildTree({ X: trueX, y: trueY });
        // Recursively build the false branch
        const falseBranch = this.buildTree({ X: falseX, y: falseY });
        return new DecisionNode(bestQuestion, trueBranch, falseBranch);
    }
    /**
     * Internal predict method separated out for recursion purpose
     * @param {any} row
     * @param {any} node
     * @returns {any}
     * @private
     */
    _predict({ row, node }) {
        if (node instanceof Leaf) {
            // Just return the highest voted
            return node.prediction;
        }
        if (node.question.match(row)) {
            return this._predict({ row, node: node.trueBranch });
        }
        else {
            return this._predict({ row, node: node.falseBranch });
        }
    }
    /**
     * Private method for printing tree; required for recursion
     * @param {any} node
     * @param {any} spacing
     */
    _printTree({ node, spacing = '' }) {
        if (node instanceof Leaf) {
            console.info(spacing + '' + node.prediction);
            return;
        }
        // Print the question of the node
        console.info(spacing + node.question.toString());
        // Call this function recursively for true branch
        console.info(spacing, '--> True');
        this._printTree({ node: node.trueBranch, spacing: spacing + ' ' });
        // Call this function recursively for false branch
        console.info(spacing, '--> False');
        this._printTree({ node: node.falseBranch, spacing: spacing + ' ' });
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJlZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9saWIvdHJlZS90cmVlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxHQUFHLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxNQUFNLFFBQVEsQ0FBQztBQUM1QyxPQUFPLEtBQUssTUFBTSxNQUFNLFdBQVcsQ0FBQztBQUNwQyxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxRQUFRLENBQUM7QUFHN0Q7OztHQUdHO0FBQ0gsTUFBTTtJQUtKLFlBQVksUUFBUSxHQUFHLElBQUksRUFBRSxNQUFNLEVBQUUsS0FBSztRQUpsQyxhQUFRLEdBQUcsRUFBRSxDQUFDO1FBQ2QsV0FBTSxHQUFHLElBQUksQ0FBQztRQUNkLFVBQUssR0FBRyxJQUFJLENBQUM7UUFHbkIsSUFBSSxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUM7UUFDekIsSUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUM7UUFDckIsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7SUFDckIsQ0FBQztJQUVNLEtBQUssQ0FBQyxPQUFPO1FBQ2xCLE1BQU0sR0FBRyxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDakMsSUFBSSxPQUFPLEdBQUcsS0FBSyxRQUFRLEVBQUU7WUFDM0IsT0FBTyxHQUFHLElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQztTQUMxQjthQUFNO1lBQ0wsT0FBTyxHQUFHLEtBQUssSUFBSSxDQUFDLEtBQUssQ0FBQztTQUMzQjtJQUNILENBQUM7SUFFTSxRQUFRO1FBQ2IsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUU7WUFDbEIsTUFBTSxLQUFLLENBQ1QsOERBQThELENBQy9ELENBQUM7U0FDSDtRQUNELE1BQU0sU0FBUyxHQUFHLE9BQU8sSUFBSSxDQUFDLEtBQUssS0FBSyxRQUFRLENBQUMsQ0FB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