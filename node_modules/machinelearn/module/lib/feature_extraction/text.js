import * as _ from 'lodash';
import * as sw from 'stopword';
import { validateMatrix1D } from '../ops';
import { WordTokenizer } from '../utils/nlp';
import { ENGLISH_STOP_WORDS } from './stop_words';
/**
 * The CountVectorizer provides a simple way to both tokenize a collection
 * of text documents and build a vocabulary of known words, but also
 * to encode new documents using that vocabulary.
 *
 * @example
 * import { CountVectorizer } from 'machinelearn/feature_extraction';
 *
 * const corpus = ['deep learning ian good fellow learning jason shin shin', 'yoshua bengio'];
 * const vocabCounts = cv.fit_transform(corpus);
 * console.log(vocabCounts); // [ [ 0, 1, 1, 1, 1, 1, 2, 2, 0 ], [ 1, 0, 0, 0, 0, 0, 0, 0, 1 ] ]
 * console.log(cv.vocabulary); // { bengio: 0, deep: 1, fellow: 2, good: 3, ian: 4, jason: 5, learning: 6, shin: 7, yoshua: 8 }
 * console.log(cv.getFeatureNames()); // [ 'bengio', 'deep', 'fellow', 'good', 'ian', 'jason', 'learning', 'shin', 'yoshua' ]
 *
 * const newVocabCounts = cv.transform(['ian good fellow jason duuog']);
 * console.log(newVocabCounts); // [ [ 0, 0, 1, 1, 1, 1, 0, 0, 0 ] ]
 */
export class CountVectorizer {
    constructor() {
        this.vocabulary = {};
    }
    /**
     * Learn a vocabulary dictionary of all tokens in the raw documents.
     * @param {string[]} doc - An array of strings
     * @returns {CountVectorizer}
     */
    fit(doc = null) {
        validateMatrix1D(doc);
        this.fit_transform(doc);
        return this;
    }
    /**
     * fit transform applies
     * @param {string[]} doc - An array of strings
     * @returns {number[][]}
     */
    fit_transform(doc = null) {
        validateMatrix1D(doc);
        const { internalVocabulary, pubVocabulary } = this.buildVocabulary(doc);
        this.vocabulary = pubVocabulary;
        this.internalVocabulary = internalVocabulary;
        return this.countVocab(doc);
    }
    /**
     * Transform documents to document-term matrix.
     * Extract token counts out of raw text documents using the vocabulary
     * fitted with fit or the one provided to the constructor.
     * @param {string[]} doc - An array of strings
     * @returns {number[][]}
     */
    transform(doc = null) {
        validateMatrix1D(doc);
        return this.countVocab(doc);
    }
    /**
     * Array mapping from feature integer indices to feature name
     * @returns {Object}
     */
    getFeatureNames() {
        if (!this.internalVocabulary) {
            throw new Error('You must fit a document first before you can retrieve the feature names!');
        }
        return this.internalVocabulary;
    }
    /**
     * Build a tokenizer/vectorizer
     * @returns {(x: string) => string[]}
     */
    buildAnalyzer() {
        return x => this.preprocess(x, { removeSW: true });
    }
    /**
     * Calculates list of vocabularies in the entire document and come up with
     * vocab: index pairs
     * @param doc
     */
    buildVocabulary(doc) {
        const analyze = this.buildAnalyzer();
        const processedDoc = _.flowRight((d) => _.uniq(d), (d) => _.sortBy(d, z => z), (d) => _.flatten(d), (d) => _.map(d, text => analyze(text)))(doc);
        const pubVocabulary = _.reduce(processedDoc, (sum, val, index) => {
            return _.set(sum, val, index);
        }, {});
        return {
            internalVocabulary: processedDoc,
            pubVocabulary
        };
    }
    /**
     * @ignore
     * Counting number of vocab occurences in the current token of a sentence
     * ['yoshua', 'bengio', 'deep', 'learning'] = vocabulary
     * ['yohua', 'bengio'] => tokens
     * results in
     * [1, 1, 0, 0]
     * @param doc
     */
    countVocab(doc) {
        const analyze = this.buildAnalyzer();
        // 1. Reducing the doc
        return _.reduce(doc, (sum, text) => {
            const tokens = analyze(text);
            // 2. Looping each vocab for counting
            const sentenceCounted = _.reduce(this.internalVocabulary, (sentenceCounts, vocab) => {
                // 3. Getting number of occurences of vocab in each tokens (tokens of a sentence)
                const vocabCount = _.reduce(tokens, (tokenCounts, t) => {
                    if (_.isEqual(t, vocab)) {
                        return tokenCounts + 1;
                    }
                    else {
                        return tokenCounts;
                    }
                }, 0);
                return _.concat(sentenceCounts, [vocabCount]);
            }, []);
            return _.concat(sum, [sentenceCounted]);
        }, []);
    }
    /**
     * @ignore
     * preprocess a line of text by applying
     * 1) tokenization
     * 2) removing stopwords
     * @param text
     * @param {any} removeSW
     * @returns {any}
     */
    preprocess(text, { removeSW = false }) {
        const tokenizer = new WordTokenizer();
        return _.flowRight((x) => tokenizer.tokenize(x), (x) => x.join(' '), 
        // TODO: Somehow it's removing too many words??!!
        (x) => removeSW ? sw.removeStopwords(x, ENGLISH_STOP_WORDS) : x, (x) => x.split(' '))(text);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGV4dC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9saWIvZmVhdHVyZV9leHRyYWN0aW9uL3RleHQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxLQUFLLENBQUMsTUFBTSxRQUFRLENBQUM7QUFDNUIsT0FBTyxLQUFLLEVBQUUsTUFBTSxVQUFVLENBQUM7QUFDL0IsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sUUFBUSxDQUFDO0FBRTFDLE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSxjQUFjLENBQUM7QUFDN0MsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sY0FBYyxDQUFDO0FBRWxEOzs7Ozs7Ozs7Ozs7Ozs7O0dBZ0JHO0FBQ0gsTUFBTTtJQUFOO1FBQ1MsZUFBVSxHQUFXLEVBQUUsQ0FBQztJQTJKakMsQ0FBQztJQXZKQzs7OztPQUlHO0lBQ0ksR0FBRyxDQUFDLE1BQTRCLElBQUk7UUFDekMsZ0JBQWdCLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDdEIsSUFBSSxDQUFDLGFBQWEsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUN4QixPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7SUFFRDs7OztPQUlHO0lBQ0ksYUFBYSxDQUFDLE1BQTRCLElBQUk7UUFDbkQsZ0JBQWdCLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDdEIsTUFBTSxFQUFFLGtCQUFrQixFQUFFLGFBQWEsRUFBRSxHQUFHLElBQUksQ0FBQyxlQUFlLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDeEUsSUFBSSxDQUFDLFVBQVUsR0FBRyxhQUFhLENBQUM7UUFDaEMsSUFBSSxDQUFDLGtCQUFrQixHQUFHLGtCQUFrQixDQUFDO1FBQzdDLE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUM5QixDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0ksU0FBUyxDQUFDLE1BQTRCLElBQUk7UUFDL0MsZ0JBQWdCLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDdEIsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQzlCLENBQUM7SUFFRDs7O09BR0c7SUFDSSxlQUFlO1FBQ3BCLElBQUksQ0FBQyxJQUFJLENBQUMsa0JBQWtCLEVBQUU7WUFDNUIsTUFBTSxJQUFJLEtBQUssQ0FDYiwwRUFBMEUsQ0FDM0UsQ0FBQztTQUNIO1FBQ0QsT0FBTyxJQUFJLENBQUMsa0JBQWtCLENBQUM7SUFDakMsQ0FBQztJQUVEOzs7T0FHRztJQUNLLGFBQWE7UUFDbkIsT0FBTyxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxFQUFFLEVBQUUsUUFBUSxFQUFFLElBQUksRUFBRSxDQUFDLENBQUM7SUFDckQsQ0FBQztJQUVEOzs7O09BSUc7SUFDSyxlQUFlLENBQ3JCLEdBQXlCO1FBS3pCLE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQztRQUNyQyxNQUFNLFlBQVksR0FBYSxDQUFDLENBQUMsU0FBUyxDQUN4QyxDQUFDLENBQVcsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFDMUIsQ0FBQyxDQUFXLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQ3BDLENBQUMsQ0FBYSxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUMvQixDQUFDLENBQVcsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FDakQsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNQLE1BQU0sYUFBYSxHQUFHLENBQUMsQ0FBQyxNQUFNLENBQzVCLFlBQVksRUFDWixDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsS0FBSyxFQUFFLEVBQUU7WUFDbEIsT0FBTyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFDaEMsQ0FBQyxFQUNELEVBQUUsQ0FDSCxDQUFDO1FBQ0YsT0FBTztZQUNMLGtCQUFrQixFQUFFLFlBQVk7WUFDaEMsYUFBYTtTQUNkLENBQUM7SUFDSixDQUFDO0lBRUQ7Ozs7Ozs7O09BUUc7SUFDSyxVQUFVLENBQUMsR0FBeUI7UUFDMUMsTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDO1FBQ3JDLHNCQUFzQjtRQUN0QixPQUFPLENBQUMsQ0FBQyxNQUFNLENBQ2IsR0FBRyxFQUNILENBQUMsR0FBUSxFQUFFLElBQVksRUFBRSxFQUFFO1lBQ3pCLE1BQU0sTUFBTSxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUU3QixxQ0FBcUM7WUFDckMsTUFBTSxlQUFlLEdBQUcsQ0FBQyxDQUFDLE1BQU0sQ0FDOUIsSUFBSSxDQUFDLGtCQUFrQixFQUN2QixDQUFDLGNBQW1CLEVBQUUsS0FBSyxFQUFFLEVBQUU7Z0JBQzdCLGlGQUFpRjtnQkFDakYsTUFBTSxVQUFVLEdBQUcsQ0FBQyxDQUFDLE1BQU0sQ0FDekIsTUFBTSxFQUNOLENBQUMsV0FBbUIsRUFBRSxDQUFDLEVBQUUsRUFBRTtvQkFDekIsSUFBSSxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsRUFBRSxLQUFLLENBQUMsRUFBRTt3QkFDdkIsT0FBTyxXQUFXLEdBQUcsQ0FBQyxDQUFDO3FCQUN4Qjt5QkFBTTt3QkFDTCxPQUFPLFdBQVcsQ0FBQztxQkFDcEI7Z0JBQ0gsQ0FBQyxFQUNELENBQUMsQ0FDRixDQUFDO2dCQUNGLE9BQU8sQ0FBQyxDQUFDLE1BQU0sQ0FBQyxjQUFjLEVBQUUsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDO1lBQ2hELENBQUMsRUFDRCxFQUFFLENBQ0gsQ0FBQztZQUNGLE9BQU8sQ0FBQyxDQUFDLE1BQU0sQ0FBQyxHQUFHLEVBQUUsQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDO1FBQzFDLENBQUMsRUFDRCxFQUFFLENBQ0gsQ0FBQztJQUNKLENBQUM7SUFFRDs7Ozs7Ozs7T0FRRztJQUNLLFVBQVUsQ0FBQyxJQUFZLEVBQUUsRUFBRSxRQUFRLEdBQUcsS0FBSyxFQUFFO1FBQ25ELE1BQU0sU0FBUyxHQUFHLElBQUksYUFBYSxFQUFFLENBQUM7UUFDdEMsT0FBTyxDQUFDLENBQUMsU0FBUyxDQUNoQixDQUFDLENBQVMsRUFBRSxFQUFFLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsRUFDcEMsQ0FBQyxDQUFXLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDO1FBQzVCLGlEQUFpRDtRQUNqRCxDQUFDLENBQVcsRUFBRSxFQUFFLENBQ2QsUUFBUSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsZUFBZSxDQUFDLENBQUMsRUFBRSxrQkFBa0IsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQzFELENBQUMsQ0FBUyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUM1QixDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ1YsQ0FBQztDQUNGIn0=