/**
 * References:
 * - https://machinelearningmastery.com/implement-simple-linear-regression-scratch-python/
 */
import * as tf from '@tensorflow/tfjs';
import { size } from 'lodash';
import * as numeric from 'numeric';
import { inferShape, reshape } from '../ops';
import math from '../utils/MathExtra';
/**
 * Type of Linear Regression
 * Univariate = It can handle a 1 dimensional input
 * Multivariate = It can handle a 2 dimensional input
 * @ignore
 */
export var TypeLinearReg;
(function (TypeLinearReg) {
    TypeLinearReg["UNIVARIATE"] = "UNIVARIATE";
    TypeLinearReg["MULTIVARIATE"] = "MULTIVARIATE";
})(TypeLinearReg || (TypeLinearReg = {}));
/**
 * Ordinary least squares Linear Regression.
 *
 * It supports both univariate and multivariate linear regressions.
 *
 * @example
 * import { LinearRegression } from './linear_regression';
 * const linearRegression = new LinearRegression();
 * const X = [1, 2, 4, 3, 5];
 * const y = [1, 3, 3, 2, 5];
 * linearRegression.fit(X, y);
 * lr.predict([1, 2]);
 * // [ 1.1999999999999995, 1.9999999999999996 ]
 *
 * const linearRegression2 = new LinearRegression();
 * const X2 = [[1, 1], [1, 2], [2, 2], [2, 3]];
 * const y2 = [1, 1, 2, 2];
 * linearRegression2.fit(X2, y2);
 * lr.predict([[1, 2]]);
 * // [1.0000001788139343]
 */
export class LinearRegression {
    constructor() {
        this.weights = [];
        this.type = TypeLinearReg.MULTIVARIATE;
    }
    /**
     * fit linear model
     * @param {any} X - training values
     * @param {any} y - target values
     */
    fit(X = null, y = null) {
        const xShape = inferShape(X);
        const yShape = inferShape(y);
        if (xShape.length === 1 && yShape.length === 1 && xShape[0] === yShape[0]) {
            // Univariate linear regression
            this.type = TypeLinearReg.UNIVARIATE;
            this.weights = this.calculateUnivariateCoeff(X, y); // getting b0 and b1
        }
        else if (xShape.length === 2 &&
            yShape.length === 1 &&
            xShape[0] === yShape[0]) {
            this.type = TypeLinearReg.MULTIVARIATE;
            this.weights = this.calculateMultiVariateCoeff(X, y);
        }
        else {
            throw new Error(`Sample(${xShape[0]}) and target(${yShape[0]}) sizes do not match`);
        }
    }
    /**
     * Predict using the linear model
     * @param {number} X - Values to predict.
     * @returns {number}
     */
    predict(X = null) {
        const xShape = inferShape(X);
        if (xShape.length === 1 &&
            this.type.toString() === TypeLinearReg.UNIVARIATE.toString()) {
            return this.univariatePredict(X);
        }
        else if (xShape.length === 2 &&
            this.type.toString() === TypeLinearReg.MULTIVARIATE.toString()) {
            return this.multivariatePredict(X);
        }
        else {
            throw new TypeError(`The matrix is incorrectly shaped: while X is ${xShape.length}, type is ${this.type.toString().toLowerCase()}`);
        }
    }
    /**
     * Get the model details in JSON format
     */
    toJSON() {
        return {
            weights: this.weights,
            type: this.type
        };
    }
    /**
     * Restore the model from a checkpoint
     */
    fromJSON({ 
    /**
     * Model's weights
     */
    weights = null, 
    /**
     * Type of linear regression, it can be either UNIVARIATE or MULTIVARIATE
     */
    type = null }) {
        if (!weights || !type) {
            throw new Error('You must provide both weights and type to restore the linear regression model');
        }
        this.weights = weights;
        this.type = type;
    }
    /**
     * Univariate prediction
     * y = b0 + b1 * X
     *
     * @param X
     */
    univariatePredict(X = null) {
        const preds = [];
        for (let i = 0; i < size(X); i++) {
            preds.push(this.weights[0] + this.weights[1] * X[i]);
        }
        return preds;
    }
    /**
     * Multivariate prediction
     * y = (b0 * X0) + (b1 * X1) + (b2 * X2) + ....
     *
     * @param X
     */
    multivariatePredict(X = null) {
        const preds = [];
        for (let i = 0; i < X.length; i++) {
            const row = X[i];
            let yPred = 0;
            for (let j = 0; j < row.length; j++) {
                yPred += this.weights[j] * row[j];
            }
            preds.push(yPred);
        }
        return preds;
    }
    /**
     * Calculates univariate coefficients for linear regression
     * @param X - X values
     * @param y - y targets
     */
    calculateUnivariateCoeff(X, y) {
        const xMean = tf.mean(X).dataSync();
        const yMean = tf.mean(y).dataSync();
        const b1 = math.covariance(X, xMean, y, yMean) / math.variance(X, xMean);
        const b0 = yMean - b1 * xMean;
        return this.weights.concat([b0, b1]);
    }
    /**
     * Calculate multivariate coefficients for linear regression
     * @param X
     * @param y
     */
    calculateMultiVariateCoeff(X, y) {
        const [q, r] = tf.linalg.qr(tf.tensor2d(X));
        const rawR = reshape(Array.from(r.dataSync()), r.shape);
        const weights = tf
            .tensor(numeric.inv(rawR))
            .dot(q.transpose())
            .dot(tf.tensor(y))
            .dataSync();
        return Array.from(weights);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGluZWFyX3JlZ3Jlc3Npb24uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9zcmMvbGliL2xpbmVhcl9tb2RlbC9saW5lYXJfcmVncmVzc2lvbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7O0dBR0c7QUFDSCxPQUFPLEtBQUssRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBQ3ZDLE9BQU8sRUFBRSxJQUFJLEVBQUUsTUFBTSxRQUFRLENBQUM7QUFDOUIsT0FBTyxLQUFLLE9BQU8sTUFBTSxTQUFTLENBQUM7QUFDbkMsT0FBTyxFQUFFLFVBQVUsRUFBRSxPQUFPLEVBQUUsTUFBTSxRQUFRLENBQUM7QUFFN0MsT0FBTyxJQUFJLE1BQU0sb0JBQW9CLENBQUM7QUFFdEM7Ozs7O0dBS0c7QUFDSCxNQUFNLENBQU4sSUFBWSxhQUdYO0FBSEQsV0FBWSxhQUFhO0lBQ3ZCLDBDQUF5QixDQUFBO0lBQ3pCLDhDQUE2QixDQUFBO0FBQy9CLENBQUMsRUFIVyxhQUFhLEtBQWIsYUFBYSxRQUd4QjtBQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQW9CRztBQUNILE1BQU07SUFBTjtRQUNVLFlBQU8sR0FBYSxFQUFFLENBQUM7UUFDdkIsU0FBSSxHQUFrQixhQUFhLENBQUMsWUFBWSxDQUFDO0lBa0szRCxDQUFDO0lBaEtDOzs7O09BSUc7SUFDSSxHQUFHLENBQ1IsSUFBaUQsSUFBSSxFQUNyRCxJQUFpRCxJQUFJO1FBRXJELE1BQU0sTUFBTSxHQUFHLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUM3QixNQUFNLE1BQU0sR0FBRyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDN0IsSUFBSSxNQUFNLENBQUMsTUFBTSxLQUFLLENBQUMsSUFBSSxNQUFNLENBQUMsTUFBTSxLQUFLLENBQUMsSUFBSSxNQUFNLENBQUMsQ0FBQyxDQUFDLEtBQUssTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFO1lBQ3pFLCtCQUErQjtZQUMvQixJ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QyxFQUFFLENBQUM7UUFDckMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDNUMsTUFBTSxJQUFJLEdBQUcsT0FBTyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLFFBQVEsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ3hELE1BQU0sT0FBTyxHQUFHLEVBQUU7YUFDZixNQUFNLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQzthQUN6QixHQUFHLENBQUMsQ0FBQyxDQUFDLFNBQVMsRUFBRSxDQUFDO2FBQ2xCLEdBQUcsQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO2FBQ2pCLFFBQVEsRUFBRSxDQUFDO1FBQ2QsT0FBTyxLQUFLLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQzdCLENBQUM7Q0FDRiJ9