import svmResolver from 'libsvm-js';
import * as _ from 'lodash';
import { validateFitInputs, validateMatrix1D, validateMatrix2D } from '../ops';
/**
 * BaseSVM class used by all parent SVM classes that are based on libsvm
 */
export class BaseSVM {
    constructor(options) {
        this.options = {
            cacheSize: _.get(options, 'cacheSize', 100),
            coef0: _.get(options, 'coef0', 0),
            cost: _.get(options, 'cost', 1),
            degree: _.get(options, 'degree', 3),
            epsilon: _.get(options, 'epsilon', 0.1),
            gamma: _.get(options, 'gamma', null),
            kernel: _.get(options, 'kernel', 'RBF'),
            nu: _.get(options, 'nu', 0.5),
            probabilityEstimates: _.get(options, 'probabilityEstimates', false),
            quiet: _.get(options, 'quiet', true),
            shrinking: _.get(options, 'shrinking', true),
            tolerance: _.get(options, 'tolerance', 0.001),
            weight: _.get(options, 'weight', null)
        };
    }
    /**
     * Fit the model according to the given training data.
     * @param {number[][]} X
     * @param {number[]} y
     * @returns {Promise<void>}
     */
    async fit(X, y) {
        validateFitInputs(X, y);
        if (!this.type) {
            throw new Error(`SVM type is unspecified ${this.type}`);
        }
        const SVM = await this.loadSVM();
        const options = this.processOptions(SVM, this.options, this.type, this.options.kernel);
        this.svm = new SVM(options);
        this.svm.train(X, y);
    }
    /**
     * Predict using the linear model
     * @param {number[][]} X
     * @returns {number[]}
     */
    predict(X) {
        validateMatrix2D(X);
        return this.svm.predict(X);
    }
    /**
     * Predict the label of one sample.
     * @param {number[]} X
     * @returns {number}
     */
    predictOne(X) {
        validateMatrix1D(X);
        return this.svm.predictOne(X);
    }
    /**
     * Saves the current SVM as a JSON object
     * @returns {{svm: any; type: Type; options: SVMOptions}}
     */
    toJSON() {
        return {
            svm: this.svm,
            type: this.type,
            options: this.options
        };
    }
    /**
     * Restores the model from a JSON checkpoint
     * @param {any} svm
     * @param {any} type
     * @param {any} options
     */
    fromJSON({ svm = null, type = null, options = null }) {
        if (!svm || !type || !options) {
            throw new Error('You must provide svm, type and options to restore the model');
        }
        this.svm = svm;
        this.type = type;
        this.options = options;
    }
    /**
     * Load SVM object by resolving the default promise
     * @returns {Promise<any>}
     */
    async loadSVM() {
        return svmResolver;
    }
    /**
     * Get Kernel name type using string Kernel name
     * @param SVM
     * @param {string} name
     * @returns {number}
     */
    getKernel(SVM, name) {
        return _.get(SVM.KERNEL_TYPES, name);
    }
    /**
     * Get Kernel type using string type name
     * @param SVM
     * @param {string} name
     * @returns {number}
     */
    getType(SVM, name) {
        return _.get(SVM.SVM_TYPES, name);
    }
    /**
     * Get a consolidated options including type and Kernel
     * @param SVM
     * @param {Options} options
     * @param {Type} type
     * @param {Kernel} kernel
     * @returns {Object}
     */
    processOptions(SVM, options, type, kernel) {
        return _.flowRight(opts => {
            const foundType = this.getType(SVM, type);
            return _.set(opts, 'type', foundType);
        }, opts => {
            const foundKernal = this.getKernel(SVM, kernel);
            return _.set(opts, 'kernel', foundKernal);
        })(options);
    }
}
/**
 * C-Support Vector Classification.
 *
 * The implementation is based on libsvm. The fit time complexity is more than
 * quadratic with the number of samples which makes it hard to scale to dataset
 * with more than a couple of 10000 samples.
 *
 * The multiclass support is handled according to a one-vs-one scheme.
 *
 * For details on the precise mathematical formulation of the provided kernel
 * functions and how gamma, coef0 and degree affect each other, see the corresponding
 * section in the narrative documentation: Kernel functions.
 */
export class SVC extends BaseSVM {
    constructor(options) {
        super(options);
        this.type = 'C_SVC';
    }
}
/**
 * Linear Support Vector Regression.
 *
 * Similar to SVR with parameter kernel=’linear’, but implemented in terms of
 * liblinear rather than libsvm, so it has more flexibility in the choice of
 * penalties and loss functions and should scale better to large numbers of samples.
 *
 * This class supports both dense and sparse input.
 */
export class SVR extends BaseSVM {
    constructor(options) {
        super(options);
        this.type = 'EPSILON_SVR';
    }
}
/**
 * Unsupervised Outlier Detection.
 *
 * Estimate the support of a high-dimensional distribution.
 *
 * The implementation is based on libsvm.
 */
export class OneClassSVM extends BaseSVM {
    constructor(options) {
        super(options);
        this.type = 'ONE_CLASS';
    }
}
/**
 * Nu-Support Vector Classification.
 *
 * Similar to SVC but uses a parameter to control the number of support vectors.
 *
 * The implementation is based on libsvm.
 */
export class NuSVC extends BaseSVM {
    constructor(options) {
        super(options);
        this.type = 'NU_SVC';
    }
}
/**
 * Nu Support Vector Regression.
 *
 * Similar to NuSVC, for regression, uses a parameter nu to control the number
 * of support vectors. However, unlike NuSVC, where nu replaces C, here nu
 * replaces the parameter epsilon of epsilon-SVR.
 *
 * The implementation is based on libsvm.
 */
export class NuSVR extends BaseSVM {
    constructor(options) {
        super(options);
        this.type = 'NU_SVR';
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2xhc3Nlcy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9saWIvc3ZtL2NsYXNzZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxXQUFXLE1BQU0sV0FBVyxDQUFDO0FBQ3BDLE9BQU8sS0FBSyxDQUFDLE1BQU0sUUFBUSxDQUFDO0FBQzVCLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxnQkFBZ0IsRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLFFBQVEsQ0FBQztBQWtFL0U7O0dBRUc7QUFDSCxNQUFNO0lBS0osWUFBWSxPQUFvQjtRQUM5QixJQUFJLENBQUMsT0FBTyxHQUFHO1lBQ2IsU0FBUyxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsT0FBTyxFQUFFLFdBQVcsRUFBRSxHQUFHLENBQUM7WUFDM0MsS0FBSyxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsT0FBTyxFQUFFLE9BQU8sRUFBRSxDQUFDLENBQUM7WUFDakMsSUFBSSxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsT0FBTyxFQUFFLE1BQU0sRUFBRSxDQUFDLENBQUM7WUFDL0IsTUFBTSxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsT0FBTyxFQUFFLFFBQVEsRUFBRSxDQUFDLENBQUM7WUFDbkMsT0FBTyxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsT0FBTyxFQUFFLFNBQVMsRUFBRSxHQUFHLENBQUM7WUFDdkMsS0FBSyxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsT0FBTyxFQUFFLE9BQU8sRUFBRSxJQUFJLENBQUM7WUFDcEMsTUFBTSxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsT0FBTyxFQUFFLFFBQVEsRUFBRSxLQUFLLENBQUM7WUFDdkMsRUFBRSxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsT0FBTyxFQUFFLElBQUksRUFBRSxHQUFHLENBQUM7WUFDN0Isb0JBQW9CLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxPQUFPLEVBQUUsc0JB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