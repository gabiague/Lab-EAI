import * as tf from '@tensorflow/tfjs';
import { zip } from 'lodash';
import { reshape, validateFitInputs, validateMatrix2D } from '../ops';
const SQRT_2PI = Math.sqrt(Math.PI * 2);
/**
 * The Naive is an intuitive method that uses probabilistic of each attribute
 * being in each class to make a prediction. It uses Gaussian function to estimate
 * probability of a given class.
 *
 * @example
 * import { GaussianNB } from 'machinelearn/naive_bayes';
 *
 * const nb = new GaussianNB();
 * const X = [[1, 20], [2, 21], [3, 22], [4, 22]];
 * const y = [1, 0, 1, 0];
 * nb.fit({ X, y });
 * nb.predict({ X: [[1, 20]] }); // returns [ 1 ]
 *
 */
export class GaussianNB {
    /**
     * @param X - array-like or sparse matrix of shape = [n_samples, n_features]
     * @param y - array-like, shape = [n_samples] or [n_samples, n_outputs]
     */
    fit(X = null, y = null) {
        validateFitInputs(X, y);
        const { classCategories, mean, variance } = this.fitModel(X, y);
        this.classCategories = classCategories;
        this.mean = mean;
        this.variance = variance;
    }
    /**
     * @param X - array-like, shape = [n_samples, n_features]
     */
    predict(X = null) {
        validateMatrix2D(X);
        return X.map((x) => this.singlePredict(x));
    }
    /**
     * Restore the model from saved states
     * @param modelState
     */
    fromJSON({ classCategories = null, mean = null, variance = null }) {
        this.classCategories = classCategories;
        this.mean = tf.tensor2d(mean);
        this.variance = tf.tensor2d(variance);
    }
    /**
     * Save the model's states
     */
    toJSON() {
        return {
            classCategories: this.classCategories,
            mean: reshape([...this.mean.dataSync()], this.mean.shape),
            variance: reshape([...this.variance.dataSync()], this.variance.shape)
        };
    }
    /**
     * Make a single prediction
     *
     * @param  {ReadonlyArray<number>} X- values to predict in Matrix format
     * @returns T
     */
    singlePredict(X) {
        const matrixX = tf.tensor1d(X, 'float32');
        const numFeatures = matrixX.shape[0];
        // Comparing input and summary shapes
        const summaryLength = this.mean.shape[1];
        if (numFeatures !== summaryLength) {
            throw new Error(`Prediction input ${matrixX.shape[0]} length must be equal or less than summary length ${summaryLength}`);
        }
        const meanValPow = matrixX
            .sub(this.mean)
            .pow(tf.scalar(2))
            .mul(tf.scalar(-1));
        const exponent = meanValPow
            .div(this.variance.mul(tf.scalar(2)))
            .exp();
        const innerDiv = tf.scalar(SQRT_2PI).mul(this.variance.sqrt());
        const probabilityArray = tf
            .scalar(1)
            .div(innerDiv)
            .mul(exponent);
        const selectionIndex = probabilityArray
            .prod(1)
            .argMax()
            .dataSync()[0];
        return this.classCategories[selectionIndex];
    }
    /**
     * Summarise the dataset per class using "probability density function"
     *
     * @param  {Type2DMatrix<number>} X
     * @param  {ReadonlyArray<T>} y
     * @returns InterfaceFitModel
     */
    fitModel(X, y) {
        const classCategories = [...new Set(y)].sort();
        // Separates X by classes specified by y argument
        const separatedByCategory = zip(X, y).reduce((groups, [row, category]) => {
            groups[category.toString()] = groups[category.toString()] || [];
            groups[category.toString()].push(row);
            return groups;
        }, {});
        const momentStack = classCategories.map((category) => {
            const classFeatures = tf.tensor2d(separatedByCategory[category.toString()], null, 'float32');
            return tf.moments(classFeatures, [0]);
        });
        // For every class we have a mean and variance for each feature
        const mean = tf.stack(momentStack.map(m => m.mean));
        const variance = tf.stack(momentStack.map(m => m.variance));
        // TODO check for NaN or 0 variance
        // setTimeout(() => {
        //   if ([...variance.dataSync()].some(i => i === 0)) {
        //     console.error('No variance on one of the features. Errors may result.');
        //   }
        // }, 100);
        return {
            classCategories,
            mean,
            variance
        };
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2F1c3NpYW4uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9zcmMvbGliL25haXZlX2JheWVzL2dhdXNzaWFuLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sS0FBSyxFQUFFLE1BQU0sa0JBQWtCLENBQUM7QUFDdkMsT0FBTyxFQUFFLEdBQUcsRUFBRSxNQUFNLFFBQVEsQ0FBQztBQUM3QixPQUFPLEVBQUUsT0FBTyxFQUFFLGlCQUFpQixFQUFFLGdCQUFnQixFQUFFLE1BQU0sUUFBUSxDQUFDO0FBR3RFLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQztBQUV4Qzs7Ozs7Ozs7Ozs7Ozs7R0FjRztBQUNILE1BQU07SUFNSjs7O09BR0c7SUFDSSxHQUFHLENBQUMsSUFBMEIsSUFBSSxFQUFFLElBQXFCLElBQUk7UUFDbEUsaUJBQWlCLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQ3hCLE1BQU0sRUFBRSxlQUFlLEVBQUUsSUFBSSxFQUFFLFFBQVEsRUFBRSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQ2hFLElBQUksQ0FBQyxlQUFlLEdBQUcsZUFBZSxDQUFDO1FBQ3ZDLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDO1FBQ2pCLElBQUksQ0FBQyxRQUFRLEdBQUcsUUFBUSxDQUFDO0lBQzNCLENBQUM7SUFFRDs7T0FFRztJQUNJLE9BQU8sQ0FBQyxJQUEwQixJQUFJO1FBQzNDLGdCQUFnQixDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3BCLE9BQU8sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBSyxFQUFFLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ2hELENBQUM7SUFFRDs7O09BR0c7SUFDSSxRQUFRLENB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