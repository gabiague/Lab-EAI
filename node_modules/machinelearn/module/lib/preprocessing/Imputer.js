import * as _ from 'lodash';
import { validateMatrix2D } from '../ops';
import math from '../utils/MathExtra';
/**
 * Imputation transformer for completing missing values.
 *
 * @example
 * import { Imputer } from 'preprocessing/Imputer';
 *
 * const testX = [[1, 2], [null, 3], [7, 6]];
 * const imp = new Imputer({ missingValues: null, axis: 0 });
 * imp.fit(testX);
 * const impResult = imp.fit_transform([[null, 2], [6, null], [7, 6]]);
 * // [ [ 4, 2 ], [ 6, 3.6666666666666665 ], [ 7, 6 ] ]
 */
export class Imputer {
    /**
     *
     * @param {any} missingValues - Target missing value to impute
     * @param {any} strategy - Missing value replacement strategy
     * @param {any} axis - Direction to impute
     * @param {any} copy - To clone the input value
     */
    constructor({ missingValues = null, strategy = 'mean', axis = 0, 
    // verbose = 0,
    copy = false }) {
        /**
         * Calculate array of numbers as array of mean values
         * Examples:
         * [ [ 1, 2 ], [ null, 3 ], [ 123, 3 ] ]
         * => [ 1.5, 3, 63 ]
         *
         * [ [ 1, 123 ], [ 2, 3, 3 ] ]
         * => [ 62, 2.6666666666666665 ]
         *
         * @param matrix
         * @param {string[]} steps
         */
        this.calcArrayMean = (matrix, steps) => 
        // TODO: Fix any return type
        // TODO: Fix matrix type any
        _.reduce(steps, (result, step) => {
            switch (step) {
                case 'flatten':
                    return _.map(result, _.flatten);
                case 'filter':
                    return _.map(result, 
                    // Expecting any type of matrics array
                    // TODO: implement a correct type
                    (arr) => {
                        return _.filter(arr, z => z !== this.missingValues);
                    });
                case 'mean':
                    return _.map(result, _.mean);
                default:
                    return result;
            }
        }, matrix);
        this.missingValues = missingValues;
        this.strategy = strategy;
        this.axis = axis;
        // this.verbose = verbose;
        this.copy = copy;
        this.means = [];
    }
    /**
     * Fit the imputer on X.
     * @param {any[]} X - Input data in array or sparse matrix format
     */
    fit(X = null) {
        validateMatrix2D(X);
        const _X = this.copy ? _.clone(X) : X;
        const rowLen = math.size(_X, 0);
        const colLen = math.size(_X, 1);
        const rowRange = math.range(0, rowLen);
        const colRange = math.range(0, colLen);
        if (this.strategy === 'mean') {
            if (this.axis === 0) {
                const colNumbers = _.map(colRange, col => math.subset(_X, rowRange, [col]));
                this.means = this.calcArrayMean(colNumbers, [
                    'flatten',
                    'filter',
                    'mean'
                ]);
            }
            else if (this.axis === 1) {
                const rowNumbers = _.map(rowRange, row => _.get(_X, `[${row}]`));
                this.means = this.calcArrayMean(rowNumbers, ['filter', 'mean']);
            }
        }
        else {
            throw new Error(`Unsupported strategy ${this.strategy} was given`);
        }
    }
    /**
     * Fit to data, then transform it.
     * @param {any[]} X - Input data in array or sparse matrix format
     * @returns {any[]}
     */
    fit_transform(X = null) {
        validateMatrix2D(X);
        const _X = _.clone(X);
        if (this.strategy === 'mean' && this.axis === 0) {
            // Mean column direction transform
            for (let row = 0; row < _.size(_X); row++) {
                for (let col = 0; col < _.size(_X[row]); col++) {
                    const value = _X[row][col];
                    _X[row][col] = value === this.missingValues ? this.means[row] : value;
                }
            }
        }
        else if (this.strategy === 'mean' && this.axis === 1) {
            // Mean row direction transform
            for (let row = 0; row < _.size(_X); row++) {
                for (let col = 0; col < _.size(_X[row]); col++) {
                    const value = _X[row][col];
                    _X[row][col] = value === this.missingValues ? this.means[col] : value;
                }
            }
        }
        else {
            throw new Error(`Unknown transformation with strategy ${this.strategy} and axis ${this.axis}`);
        }
        return _X;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSW1wdXRlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9saWIvcHJlcHJvY2Vzc2luZy9JbXB1dGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sS0FBSyxDQUFDLE1BQU0sUUFBUSxDQUFDO0FBQzVCLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLFFBQVEsQ0FBQztBQUUxQyxPQUFPLElBQUksTUFBTSxvQkFBb0IsQ0FBQztBQUV0Qzs7Ozs7Ozs7Ozs7R0FXRztBQUNILE1BQU07SUFRSjs7Ozs7O09BTUc7SUFDSCxZQUFZLEVBQ1YsYUFBYSxHQUFHLElBQUksRUFDcEIsUUFBUSxHQUFHLE1BQU0sRUFDakIsSUFBSSxHQUFHLENBQUM7SUFDUixlQUFlO0lBQ2YsSUFBSSxHQUFHLEtBQUssRUFDYjtRQTJFRDs7Ozs7Ozs7Ozs7V0FXRztRQUNLLGtCQUFhLEdBQUcsQ0FBQyxNQUFXLEVBQUUsS0FBZSxFQUFPLEVBQUU7UUFDNUQsNEJBQTRCO1FBQzVCLDRCQUE0QjtRQUM1QixDQUFDLENBQUMsTUFBTSxDQUNOLEtBQUssRUFDTCxDQUFDLE1BQU0sRUFBRSxJQUFZLEVBQUUsRUFBRTtZQUN2QixRQUFRLElBQUksRUFBRTtnQkFDWixLQUFLLFNBQVM7b0JBQ1osT0FBTyxDQUFDLENBQUMsR0FBRyxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUM7Z0JBQ2xDLEtBQUssUUFBUTtvQkFDWCxPQUFPLENBQUMsQ0FBQyxHQUFHLENBQ1YsTUFBTTtvQkFDTixzQ0FBc0M7b0JBQ3RDLGlDQUFpQztvQkFDakMsQ0FBQyxHQUFVLEVBQUUsRUFBRTt3QkFDYixPQUFPLENBQUMsQ0FBQyxNQUFNLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxLQUFLLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQztvQkFDdEQsQ0FBQyxDQUNGLENBQUM7Z0JBQ0osS0FBSyxNQUFN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