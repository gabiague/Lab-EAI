"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var lodash_1 = require("lodash");
var ops_1 = require("../ops");
var tree_1 = require("../tree");
/**
 * Base RandomForest implementation used by both classifier and regressor
 * @ignore
 */
var BaseRandomForest = /** @class */ (function () {
    /**
     *
     * @param {number} nEstimator - Number of trees.
     * @param random_state - Random seed value for DecisionTrees
     */
    function BaseRandomForest(_a) {
        var _b = _a === void 0 ? {
            // Default value on empty constructor
            nEstimator: 10,
            random_state: null
        } : _a, 
        // Each object param default value
        _c = _b.nEstimator, 
        // Each object param default value
        nEstimator = _c === void 0 ? 10 : _c, _d = _b.random_state, random_state = _d === void 0 ? null : _d;
        this.trees = [];
        this.randomState = null;
        this.nEstimator = nEstimator;
        this.randomState = random_state;
    }
    /**
     * Build a forest of trees from the training set (X, y).
     * @param {Array} X - array-like or sparse matrix of shape = [n_samples, n_features]
     * @param {Array} y - array-like, shape = [n_samples] or [n_samples, n_outputs]
     * @returns void
     */
    BaseRandomForest.prototype.fit = function (X, y) {
        var _this = this;
        if (X === void 0) { X = null; }
        if (y === void 0) { y = null; }
        ops_1.validateFitInputs(X, y);
        this.trees = lodash_1.reduce(lodash_1.range(0, this.nEstimator), function (sum) {
            var tree = new tree_1.DecisionTreeClassifier({
                featureLabels: null,
                random_state: _this.randomState
            });
            tree.fit(X, y);
            return lodash_1.concat(sum, [tree]);
        }, []);
    };
    /**
     * Returning the current model's checkpoint
     * @returns {{trees: any[]}}
     */
    BaseRandomForest.prototype.toJSON = function () {
        return {
            trees: this.trees
        };
    };
    /**
     * Restore the model from a checkpoint
     * @param {any[]} trees - Decision trees
     */
    BaseRandomForest.prototype.fromJSON = function (_a) {
        var _b = _a.trees, trees = _b === void 0 ? null : _b;
        if (!trees) {
            throw new Error('You must provide both tree to restore the model');
        }
        this.trees = trees;
    };
    /**
     * Internal predict function used by either RandomForestClassifier or Regressor
     * @param X
     * @private
     */
    BaseRandomForest.prototype.predict = function (X) {
        if (X === void 0) { X = null; }
        ops_1.validateMatrix2D(X);
        return lodash_1.map(this.trees, function (tree) {
            // TODO: Check if it's a matrix or an array
            return tree.predict(X);
        });
    };
    return BaseRandomForest;
}());
exports.BaseRandomForest = BaseRandomForest;
/**
 * Random forest classifier creates a set of decision trees from randomly selected subset of training set.
 * It then aggregates the votes from different decision trees to decide the final class of the test object.
 *
 * @example
 * import { RandomForestClassifier } from 'machinelearn/ensemble';
 *
 * const X = [[0, 0], [1, 1], [2, 1], [1, 5], [3, 2]];
 * const y = [0, 1, 2, 3, 7];
 *
 * const randomForest = new RandomForestClassifier();
 * randomForest.fit(X, y);
 *
 * // Results in a value such as [ '0', '2' ].
 * // Predictions will change as we have not set a seed value.
 */
var RandomForestClassifier = /** @class */ (function (_super) {
    __extends(RandomForestClassifier, _super);
    function RandomForestClassifier() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Predict class for X.
     *
     * The predicted class of an input sample is a vote by the trees in the forest, weighted by their probability estimates.
     * That is, the predicted class is the one with highest mean probability estimate across the trees.
     * @param {Array} X - array-like or sparse matrix of shape = [n_samples]
     * @returns {string[]}
     */
    RandomForestClassifier.prototype.predict = function (X) {
        if (X === void 0) { X = null; }
        var predictions = _super.prototype.predict.call(this, X);
        return this.votePredictions(predictions);
    };
    /**
     * @hidden
     * Bagging prediction helper method
     * According to the predictions returns by the trees, it will select the
     * class with the maximum number (votes)
     * @param {Array<any>} predictions - List of initial predictions that may look like [ [1, 2], [1, 1] ... ]
     * @returns {string[]}
     */
    RandomForestClassifier.prototype.votePredictions = function (predictions) {
        var counts = lodash_1.countBy(predictions, function (x) { return x; });
        var countsArray = lodash_1.reduce(lodash_1.keys(counts), function (sum, k) {
            var returning = {};
            returning[k] = counts[k];
            return lodash_1.concat(sum, returning);
        }, []);
        var max = lodash_1.maxBy(countsArray, function (x) { return lodash_1.head(lodash_1.values(x)); });
        var key = lodash_1.head(lodash_1.keys(max));
        // Find the actual class values from the predictions
        return lodash_1.find(predictions, function (pred) {
            return lodash_1.isEqual(pred.join(','), key);
        });
    };
    return RandomForestClassifier;
}(BaseRandomForest));
exports.RandomForestClassifier = RandomForestClassifier;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZm9yZXN0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2xpYi9lbnNlbWJsZS9mb3Jlc3QudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUEsaUNBWWdCO0FBQ2hCLDhCQUE2RDtBQUM3RCxnQ0FBaUQ7QUFHakQ7OztHQUdHO0FBQ0g7SUFLRTs7OztPQUlHO0lBQ0gsMEJBQ0UsRUFZQztZQVpEOzs7O2NBWUM7UUFYQyxrQ0FBa0M7UUFDbEMsa0JBQWU7UUFEZixrQ0FBa0M7UUFDbEMsb0NBQWUsRUFDZixvQkFBbUIsRUFBbkIsd0NBQW1CO1FBYmIsVUFBSyxHQUFHLEVBQUUsQ0FBQztRQUVYLGdCQUFXLEdBQUcsSUFBSSxDQUFDO1FBc0IzQixJQUFJLENBQUMsVUFBVSxHQUFHLFVBQVUsQ0FBQztRQUM3QixJQUFJLENBQUMsV0FBVyxHQUFHLFlBQVksQ0FBQztJQUNsQyxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSSw4QkFBRyxHQUFWLFVBQ0UsQ0FBOEIsRUFDOUIsQ0FBOEI7UUFGaEMsaUJBaUJDO1FBaEJDLGtCQUFBLEVBQUEsUUFBOEI7UUFDOUIsa0JBQUEsRUFBQSxRQUE4QjtRQUU5Qix1QkFBaUIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDeEIsSUFBSSxDQUFDLEtBQUssR0FBRyxlQUFNLENBQ2pCLGNBQUssQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLFVBQVUsQ0FBQyxFQUN6QixVQUFBLEdBQUc7WUFDRCxJQUFNLElBQUksR0FBRyxJQUFJLDZCQUFzQixDQUFDO2dCQUN0QyxhQUFhLEVBQUUsSUFBSTtnQkFDbkIsWUFBWSxFQUFFLEtBQUksQ0FBQyxXQUFXO2FBQy9CLENBQUMsQ0FBQztZQUNILElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1lBQ2YsT0FBTyxlQUFNLENBQUMsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztR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