"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var libsvm_js_1 = __importDefault(require("libsvm-js"));
var _ = __importStar(require("lodash"));
var ops_1 = require("../ops");
/**
 * BaseSVM class used by all parent SVM classes that are based on libsvm
 */
var BaseSVM = /** @class */ (function () {
    function BaseSVM(options) {
        this.options = {
            cacheSize: _.get(options, 'cacheSize', 100),
            coef0: _.get(options, 'coef0', 0),
            cost: _.get(options, 'cost', 1),
            degree: _.get(options, 'degree', 3),
            epsilon: _.get(options, 'epsilon', 0.1),
            gamma: _.get(options, 'gamma', null),
            kernel: _.get(options, 'kernel', 'RBF'),
            nu: _.get(options, 'nu', 0.5),
            probabilityEstimates: _.get(options, 'probabilityEstimates', false),
            quiet: _.get(options, 'quiet', true),
            shrinking: _.get(options, 'shrinking', true),
            tolerance: _.get(options, 'tolerance', 0.001),
            weight: _.get(options, 'weight', null)
        };
    }
    /**
     * Fit the model according to the given training data.
     * @param {number[][]} X
     * @param {number[]} y
     * @returns {Promise<void>}
     */
    BaseSVM.prototype.fit = function (X, y) {
        return __awaiter(this, void 0, void 0, function () {
            var SVM, options;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        ops_1.validateFitInputs(X, y);
                        if (!this.type) {
                            throw new Error("SVM type is unspecified " + this.type);
                        }
                        return [4 /*yield*/, this.loadSVM()];
                    case 1:
                        SVM = _a.sent();
                        options = this.processOptions(SVM, this.options, this.type, this.options.kernel);
                        this.svm = new SVM(options);
                        this.svm.train(X, y);
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Predict using the linear model
     * @param {number[][]} X
     * @returns {number[]}
     */
    BaseSVM.prototype.predict = function (X) {
        ops_1.validateMatrix2D(X);
        return this.svm.predict(X);
    };
    /**
     * Predict the label of one sample.
     * @param {number[]} X
     * @returns {number}
     */
    BaseSVM.prototype.predictOne = function (X) {
        ops_1.validateMatrix1D(X);
        return this.svm.predictOne(X);
    };
    /**
     * Saves the current SVM as a JSON object
     * @returns {{svm: any; type: Type; options: SVMOptions}}
     */
    BaseSVM.prototype.toJSON = function () {
        return {
            svm: this.svm,
            type: this.type,
            options: this.options
        };
    };
    /**
     * Restores the model from a JSON checkpoint
     * @param {any} svm
     * @param {any} type
     * @param {any} options
     */
    BaseSVM.prototype.fromJSON = function (_a) {
        var _b = _a.svm, svm = _b === void 0 ? null : _b, _c = _a.type, type = _c === void 0 ? null : _c, _d = _a.options, options = _d === void 0 ? null : _d;
        if (!svm || !type || !options) {
            throw new Error('You must provide svm, type and options to restore the model');
        }
        this.svm = svm;
        this.type = type;
        this.options = options;
    };
    /**
     * Load SVM object by resolving the default promise
     * @returns {Promise<any>}
     */
    BaseSVM.prototype.loadSVM = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, libsvm_js_1.default];
            });
        });
    };
    /**
     * Get Kernel name type using string Kernel name
     * @param SVM
     * @param {string} name
     * @returns {number}
     */
    BaseSVM.prototype.getKernel = function (SVM, name) {
        return _.get(SVM.KERNEL_TYPES, name);
    };
    /**
     * Get Kernel type using string type name
     * @param SVM
     * @param {string} name
     * @returns {number}
     */
    BaseSVM.prototype.getType = function (SVM, name) {
        return _.get(SVM.SVM_TYPES, name);
    };
    /**
     * Get a consolidated options including type and Kernel
     * @param SVM
     * @param {Options} options
     * @param {Type} type
     * @param {Kernel} kernel
     * @returns {Object}
     */
    BaseSVM.prototype.processOptions = function (SVM, options, type, kernel) {
        var _this = this;
        return _.flowRight(function (opts) {
            var foundType = _this.getType(SVM, type);
            return _.set(opts, 'type', foundType);
        }, function (opts) {
            var foundKernal = _this.getKernel(SVM, kernel);
            return _.set(opts, 'kernel', foundKernal);
        })(options);
    };
    return BaseSVM;
}());
exports.BaseSVM = BaseSVM;
/**
 * C-Support Vector Classification.
 *
 * The implementation is based on libsvm. The fit time complexity is more than
 * quadratic with the number of samples which makes it hard to scale to dataset
 * with more than a couple of 10000 samples.
 *
 * The multiclass support is handled according to a one-vs-one scheme.
 *
 * For details on the precise mathematical formulation of the provided kernel
 * functions and how gamma, coef0 and degree affect each other, see the corresponding
 * section in the narrative documentation: Kernel functions.
 */
var SVC = /** @class */ (function (_super) {
    __extends(SVC, _super);
    function SVC(options) {
        var _this = _super.call(this, options) || this;
        _this.type = 'C_SVC';
        return _this;
    }
    return SVC;
}(BaseSVM));
exports.SVC = SVC;
/**
 * Linear Support Vector Regression.
 *
 * Similar to SVR with parameter kernel=’linear’, but implemented in terms of
 * liblinear rather than libsvm, so it has more flexibility in the choice of
 * penalties and loss functions and should scale better to large numbers of samples.
 *
 * This class supports both dense and sparse input.
 */
var SVR = /** @class */ (function (_super) {
    __extends(SVR, _super);
    function SVR(options) {
        var _this = _super.call(this, options) || this;
        _this.type = 'EPSILON_SVR';
        return _this;
    }
    return SVR;
}(BaseSVM));
exports.SVR = SVR;
/**
 * Unsupervised Outlier Detection.
 *
 * Estimate the support of a high-dimensional distribution.
 *
 * The implementation is based on libsvm.
 */
var OneClassSVM = /** @class */ (function (_super) {
    __extends(OneClassSVM, _super);
    function OneClassSVM(options) {
        var _this = _super.call(this, options) || this;
        _this.type = 'ONE_CLASS';
        return _this;
    }
    return OneClassSVM;
}(BaseSVM));
exports.OneClassSVM = OneClassSVM;
/**
 * Nu-Support Vector Classification.
 *
 * Similar to SVC but uses a parameter to control the number of support vectors.
 *
 * The implementation is based on libsvm.
 */
var NuSVC = /** @class */ (function (_super) {
    __extends(NuSVC, _super);
    function NuSVC(options) {
        var _this = _super.call(this, options) || this;
        _this.type = 'NU_SVC';
        return _this;
    }
    return NuSVC;
}(BaseSVM));
exports.NuSVC = NuSVC;
/**
 * Nu Support Vector Regression.
 *
 * Similar to NuSVC, for regression, uses a parameter nu to control the number
 * of support vectors. However, unlike NuSVC, where nu replaces C, here nu
 * replaces the parameter epsilon of epsilon-SVR.
 *
 * The implementation is based on libsvm.
 */
var NuSVR = /** @class */ (function (_super) {
    __extends(NuSVR, _super);
    function NuSVR(options) {
        var _this = _super.call(this, options) || this;
        _this.type = 'NU_SVR';
        return _this;
    }
    return NuSVR;
}(BaseSVM));
exports.NuSVR = NuSVR;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2xhc3Nlcy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9saWIvc3ZtL2NsYXNzZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsd0RBQW9DO0FBQ3BDLHdDQUE0QjtBQUM1Qiw4QkFBK0U7QUFrRS9FOztHQUVHO0FBQ0g7SUFLRSxpQkFBWSxPQUFvQjtRQUM5QixJQUFJLENBQUMsT0FBTyxHQUFHO1lBQ2IsU0FBUyxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsT0FBTyxFQUFFLFdBQVcsRUFBRSxHQUFHLENBQUM7WUFDM0MsS0FBSyxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsT0FBTyxFQUFFLE9BQU8sRUFBRSxDQUFDLENBQUM7WUFDakMsSUFBSSxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsT0FBTyxFQUFFLE1BQU0sRUFBRSxDQUFDLENBQUM7WUFDL0IsTUFBTSxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsT0FBTyxFQUFFLFFBQVEsRUFBRSxDQUFDLENBQUM7WUFDbkMsT0FBTyxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsT0FBTyxFQUFFLFNBQVMsRUFBRSxHQUFHLENBQUM7WUFDdkMsS0FBSyxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsT0FBTyxFQUFFLE9BQU8sRUFBRSxJQUFJLENBQUM7WUFDcEMsTUFBTSxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsT0FBTyxFQUFFLFFBQVEsRUFBRSxLQUFLLENBQUM7WUFDdkMsRUFBRSxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsT0FBTyxFQUFFLElBQUksRUFBRSxHQUFHLENBQUM7WUFDN0Isb0JBQW9CLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxPQUFPLEVBQUUsc0JBQXNCLEVBQUUsS0FBSyxDQUFDO1lBQ25FLEtBQUssRUFBRSxDQUFDLENBQUMsR0FB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